{
    "$namespaces": {
        "sbg": "https://sevenbridges.com"
    },
    "class": "Workflow",
    "cwlVersion": "v1.0",
    "doc": "This Whole Exome Sequencing (WES) workflow identifies variants from a human exome experiment by using the [Broad Institute's](https://software.broadinstitute.org/gatk/best-practices/) best-practices workflow for alignment and variant calling.\n\nThe WES workflos analyzes all protein-coding genes in a genome, known as the exome. The exome is estimated to comprise ~1-2% of the genome yet contains ~85% of recognized disease-causing mutations.\n\nExome sequencing achieves better coverage compared to whole genome sequencing. However, variations affecting a gene\u2019s coding regions can leave potential effects on regulatory regions and various control mechanisms undetected. As such, the WES workflow is optimally applied to areas where changes in proteins are expected with a greater probability or are of a higher significance. For example, WES can be used for detecting variants (i.e. mutations) in known disease-causing genes as well as for the detection of novel gene-disease associations.\n\n##Workflow structure\n\nThe workflow follows the Broad Institute\u2019s best practices and utilizes the Broad Institute's GATK tools with additional quality metrics reporting tools. Sequenced reads are first aligned with the BWA-MEM Bundle tool, which optionally removes duplicates and sorts BAM files. In parallel with the alignment the assessment of the quality of sequenced reads is performed using Babraham Institute's tool, FastQC. The next step uses algorithms developed by the Broad Institute to improve the qualities of sequenced bases (Base Quality Score Recalibration - BQSR). Generated BAM files are passed to GATK HaplotypeCaller for variant calling.  Detected variants are subjected to filtering with predefined hard thresholds and annotation (SnpEff).  For more information on how variant calling is performed, please refer to the [Broad Institute's web site](https://software.broadinstitute.org/gatk/best-practices/).\n\nThe WES workflow utilizes human reference genome hg19, hg37, and hg38, as well as several public databases. All reference files must correspond to the same reference genome (HG19, GRCh 37, HG38, etc.). If some of the reference files have contigs not listed in the reference genome, the workflow cannot be executed.\n\n## Required inputs\n\n- Reference genome or TAR with BWA reference indices\n- FASTQ reads Illumina paired-end reads from the sequencer\n- Target exome BED file\n- DBSNP database - Database with known variants from the population used with BQSR and for annotation in variant calling (HaplotypeCaller)\n- Mills indel database used for BQSR (VCF)\n- Known indels 1000g for BQSR\n- SnpEff database archive used for variant annotation (ZIP)\n\n\n## Outputs\n- Coverage metrics showing the distribution of the number of reads covering regions of the exome\n- Alignment metrics with statistics about the quality of the alignment\n- Aligned Reads from BWA-MEM (BAM)\n- Annotated and filtered variant calling format file (VCF)\n- Raw variant calling format file (VCF)\n- Genomic variant calling format file (gVCF)\n- FastQC Report containing reports about quality of the sequenced data (adapter contamination, quality distribution, GC content,...)\n\n## Expected workflow performance\n\nBelow, we present three benchmarks showcasing the expected variant detection and run-time performance of the WES workflow.\n \nWe use the [Genome in a bottle](ftp://ftp-trace.ncbi.nlm.nih.gov/giab/ftp/release) truth dataset and the [hap.py](https://github.com/Illumina/hap.py) variant evaluation tool to determine the sensitivity and precision of the workflow for both SNPs and Indels following the GA4GH recommended practices. We note that the observed precision and sensitivity measures are in line with the expected performance for this sample. Further, we observe that both the transition to transversion ratio for SNPs and the ratio of heterozygous to homozygous indels calls are in the expected ranges for a whole-genome context. Only the calls that have the PASS flag in the VCF filter column were used for calculating the reported performance metrics, reflecting the performance that can be expected when the workflow is used in a production scenario.\n\n| Sample            | SNP Precision | SNP Recall | SNP F-measure | INDEL Precision | INDEL Recall | INDEL F-measure |\n|-------------------|---------------|------------|---------------|-----------------|--------------|-----------------|\n| HG001 TruSeq 135x | 99.3156       | 96.4127    | 97.8426       | 77.8433         | 79.5941      | 78.709          |\n| HG002 Oslo 190x   | 99.828        | 99.4878    | 99.6576       | 92.88           | 90.3208      | 91.5825         |\n\n\nFinally, we measured the end-to-end run-time of the workflow. The total execution time for 135x sample is 2 hours and 53 minutes on the C4.2xlarge AWS instance.\n\n| Sample-coverage | Size of Gzipped FASTQs [Gb] | Alignment and BAM preparation | Variant calling | Variant filtering and annotation | TotalCost (AWS spot instance) |\n|-----------------|-----------------------------|-------------------------------|-----------------|-------------------|-------------------------------|\n| NA12878-135x    | 7.6                         | 2h 14m                        | 30m             | 6m                | 0.40                          |\n| HG002 Oslo 190x | 7.2                          | 2h 21m                         | 26m             | 6m                | 0.47                          |\n\n## Important issues\n\n- In order to complete the execution of the workflow, the following fields in the metadata of FASTQ files must be set: **Paired-end, Sample ID, Platform and Library**.\n- BWA-MEM index files are packed together with the reference genome in the TAR files which are available on SBG Public files. With that indexing step in the pipeline can be skipped and its total execution will be faster.\n- If HG38 reference and high-coverage FASTQ files (e.g. larger than 150x) are used the GATK HaplotypeCaller might fail due to lack of memory. Providing more memory to its Java virtual machine and larger instance for the workflow should be done in that case.\n- If HG38 is used it will automatically perform alt contig processing from [Broad](https://gatkforums.broadinstitute.org/gatk/discussion/8017/how-to-map-reads-to-a-reference-with-alternate-contigs-like-grch38) by including additional alt index from bwa.kit. The alignments on primary assembly reference will be done correctly and for proper alignment on alt contigs please run additional post processing.",
    "hints": [
        {
            "class": "sbg:AWSInstanceType",
            "value": "c4.2xlarge;ebs-gp2;160"
        },
        {
            "class": "sbg:GoogleInstanceType",
            "value": "n1-standard-8;pd-ssd;160"
        },
        {
            "class": "sbg:OpenStackInstanceHint",
            "value": "c4.2xlarge;storage;160"
        }
    ],
    "id": "https://api.sbgenomics.com/v2/apps/admin/sbg-public-data/whole-exome-sequencing-bwa-gatk-4-0/33/raw/",
    "inputs": [
        {
            "doc": "FASTQ reads Illumina paired-end reads from the sequencer.",
            "id": "fastq",
            "label": "FASTQ",
            "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ, BAM, SAM",
            "sbg:includeInPorts": true,
            "sbg:x": -237.3809733195281,
            "sbg:y": 212.7619826084788,
            "type": "File[]"
        },
        {
            "doc": "Known indels 1000g for BQSR",
            "id": "indels_1000g_phase1",
            "label": "1000g phase1 indels",
            "sbg:includeInPorts": true,
            "sbg:suggestedValue": {
                "class": "File",
                "name": "1000G_phase1.indels.b37.vcf",
                "path": "578cf947507c17681a3117ce"
            },
            "sbg:x": 493.33349747128557,
            "sbg:y": 784.4874569371318,
            "type": "File"
        },
        {
            "doc": "SnpEff database archive used for variant annotation (ZIP)",
            "id": "database",
            "label": "SnpEff Database",
            "sbg:fileTypes": "ZIP",
            "sbg:includeInPorts": true,
            "sbg:suggestedValue": {
                "class": "File",
                "name": "GRCh37.75.zip",
                "path": "5772b6be507c1752674486c6"
            },
            "sbg:x": 2847.91709198551,
            "sbg:y": 476.01190258491454,
            "type": "File"
        },
        {
            "doc": "Reference or TAR with BWA reference indices",
            "id": "reference",
            "label": "Reference or TAR with BWA reference indices",
            "sbg:fileTypes": "TAR,FA,FASTA,FA.GZ,FASTA.GZ",
            "sbg:includeInPorts": true,
            "sbg:suggestedValue": {
                "class": "File",
                "name": "human_g1k_v37_decoy.fasta.tar",
                "path": "5772b6d9507c1752674486e7"
            },
            "sbg:x": -235.00006026692077,
            "sbg:y": 64.99434392959608,
            "type": "File"
        },
        {
            "doc": "Mills indel database used for BQSR (VCF)",
            "id": "mills",
            "label": "Mills",
            "sbg:includeInPorts": true,
            "sbg:suggestedValue": {
                "class": "File",
                "name": "Mills_and_1000G_gold_standard.indels.b37.sites.vcf",
                "path": "5772b6c9507c1752674486d4"
            },
            "sbg:x": 497.69248452113357,
            "sbg:y": 959.6157861927989,
            "type": "File"
        },
        {
            "doc": "Database with known variants from the population for BQSR",
            "id": "dbsnp",
            "label": "dbsnp",
            "sbg:fileTypes": "VCF,BED",
            "sbg:includeInPorts": true,
            "sbg:suggestedValue": {
                "class": "File",
                "name": "dbsnp_137.b37.vcf",
                "path": "5772b6cd507c1752674486d8"
            },
            "sbg:x": 501.4478761867981,
            "sbg:y": 1125.5502524576098,
            "type": "File"
        },
        {
            "doc": "Chromosomal intervals of this BED are used for base recalibration and variant calling",
            "id": "intervals_file",
            "label": "Target BED",
            "sbg:fileTypes": "BED",
            "sbg:includeInPorts": true,
            "sbg:suggestedValue": {
                "class": "File",
                "name": "exome_targets.b37.sorted.bed",
                "path": "589b4e30507c177ca71a6361"
            },
            "sbg:x": 483.0086106992533,
            "sbg:y": 622.1183731735439,
            "type": "File"
        }
    ],
    "label": "Whole Exome Sequencing - BWA + GATK 4.0 (with Metrics)",
    "outputs": [
        {
            "id": "annotated",
            "label": "SnpEff Annotated VCF",
            "outputSource": [
                "SnpEff/annotated"
            ],
            "sbg:fileTypes": "VCF, TXT, GATK, BED, BEDANN",
            "sbg:includeInPorts": true,
            "sbg:x": 3311.488591299131,
            "sbg:y": 420.8334095279316,
            "type": "File?"
        },
        {
            "id": "summary_metrics",
            "label": "Alignment Summary Metrics",
            "outputSource": [
                "GATK_CollectAlignmentSummaryMetrics/summary_metrics"
            ],
            "sbg:fileTypes": "TXT",
            "sbg:includeInPorts": true,
            "sbg:x": 1452.9683194545223,
            "sbg:y": -361.7214598280106,
            "type": "File"
        },
        {
            "id": "raw_vcf",
            "label": "Raw VCF",
            "outputSource": [
                "GATK_MergeVcfs/output"
            ],
            "sbg:fileTypes": "VCF",
            "sbg:includeInPorts": true,
            "sbg:x": 2176.446981402047,
            "sbg:y": 584.3873356308401,
            "type": "File?"
        },
        {
            "id": "b64html",
            "label": "FastQC report",
            "outputSource": [
                "FastQC/report_html"
            ],
            "sbg:fileTypes": "HTML, B64HTML",
            "sbg:includeInPorts": true,
            "sbg:x": 492.33342430326985,
            "sbg:y": 420.00009813573973,
            "type": "File?"
        },
        {
            "id": "b64html_1",
            "label": "SnpEff summary",
            "outputSource": [
                "SnpEff/summary"
            ],
            "sbg:fileTypes": "HTML, CSV",
            "sbg:includeInPorts": true,
            "sbg:x": 3313.833806077601,
            "sbg:y": 222.16667213042462,
            "type": "File?"
        },
        {
            "id": "gvcf",
            "label": "gVCF",
            "outputSource": [
                "GATK_MergeVcfs_1/output"
            ],
            "sbg:fileTypes": "VCF",
            "sbg:includeInPorts": true,
            "sbg:x": 1857.9685866276025,
            "sbg:y": 441.6121204267674,
            "type": "File?"
        },
        {
            "id": "coverage",
            "label": "coverage",
            "outputSource": [
                "SAMtools_Depth/coverage"
            ],
            "sbg:includeInPorts": true,
            "sbg:x": 1447.6925506140449,
            "sbg:y": -512.3077108112308,
            "type": "string?"
        },
        {
            "id": "percentage_coverage_larger_than_20",
            "label": "percentage_coverage_larger_than_20",
            "outputSource": [
                "SAMtools_Depth/percentage_coverage_larger_than_limit"
            ],
            "sbg:includeInPorts": true,
            "sbg:x": 1452.3078681787822,
            "sbg:y": -655.3846382897277,
            "type": "float?"
        },
        {
            "id": "aligned_reads_bwa_mem",
            "label": "Aligned Reads Bwa mem",
            "outputSource": [
                "Sambamba_Merge/merged_bam"
            ],
            "sbg:fileTypes": "BAM",
            "sbg:includeInPorts": true,
            "sbg:x": 1555.2566554546452,
            "sbg:y": -132.30771636962982,
            "type": "File?"
        },
        {
            "id": "hs_metrics",
            "label": "HS Metrics",
            "outputSource": [
                "GATK_CollectHsMetrics/output"
            ],
            "sbg:fileTypes": "TXT",
            "sbg:includeInPorts": true,
            "sbg:x": 1456.0000813802087,
            "sbg:y": -846.666687011719,
            "type": "File?"
        }
    ],
    "requirements": [
        {
            "class": "ScatterFeatureRequirement"
        }
    ],
    "sbg:appVersion": [
        "v1.0"
    ],
    "sbg:canvas_x": 225,
    "sbg:canvas_y": 211,
    "sbg:canvas_zoom": 0.6499999999999997,
    "sbg:categories": [
        "WES-(WXS)",
        "GATK-4"
    ],
    "sbg:content_hash": null,
    "sbg:contributors": [
        "admin"
    ],
    "sbg:createdBy": "admin",
    "sbg:createdOn": 1509554705,
    "sbg:expand_workflow": false,
    "sbg:id": "admin/sbg-public-data/whole-exome-sequencing-bwa-gatk-4-0/33",
    "sbg:image_url": "https://igor.sbgenomics.com/ns/brood/images/admin/sbg-public-data/whole-exome-sequencing-bwa-gatk-4-0/33.png",
    "sbg:latestRevision": 33,
    "sbg:license": "Open source BSD (3-clause) license",
    "sbg:modifiedBy": "admin",
    "sbg:modifiedOn": 1539595318,
    "sbg:project": "admin/sbg-public-data",
    "sbg:projectName": "SBG Public Data",
    "sbg:publisher": "sbg",
    "sbg:revision": 33,
    "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/163",
    "sbg:revisionsInfo": [
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554705,
            "sbg:revision": 0,
            "sbg:revisionNotes": "Take GATK CollectAlignmentSummaryMetrics from GATK 4.0 Demo project"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554705,
            "sbg:revision": 1,
            "sbg:revisionNotes": "wes name"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554705,
            "sbg:revision": 2,
            "sbg:revisionNotes": "Update Untar FASTA"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554705,
            "sbg:revision": 3,
            "sbg:revisionNotes": "Description updated. Unnecessary outputs removed."
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554705,
            "sbg:revision": 4,
            "sbg:revisionNotes": "description title removed"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554705,
            "sbg:revision": 5,
            "sbg:revisionNotes": "Update descriptions for GATK tools"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554705,
            "sbg:revision": 6,
            "sbg:revisionNotes": "Update GATK tools to new 4.beta.2 image"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554706,
            "sbg:revision": 7,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/78"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554706,
            "sbg:revision": 8,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/80"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554706,
            "sbg:revision": 9,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/102"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554706,
            "sbg:revision": 10,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/106"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554706,
            "sbg:revision": 11,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/107"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554707,
            "sbg:revision": 12,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/110"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554707,
            "sbg:revision": 13,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/113"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554707,
            "sbg:revision": 14,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/117"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554707,
            "sbg:revision": 15,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/121"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1509554708,
            "sbg:revision": 16,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/122"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1517583113,
            "sbg:revision": 17,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/127"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1517583114,
            "sbg:revision": 18,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/128"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1517583114,
            "sbg:revision": 19,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/133"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1517583115,
            "sbg:revision": 20,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/145"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1519745465,
            "sbg:revision": 21,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/147"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1519745466,
            "sbg:revision": 22,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/149"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1519853729,
            "sbg:revision": 23,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/150"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1521478772,
            "sbg:revision": 24,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/153"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1521478772,
            "sbg:revision": 25,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/155"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1521737847,
            "sbg:revision": 26,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/156"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1528984442,
            "sbg:revision": 27,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/157"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1529424682,
            "sbg:revision": 28,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/158"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1530629817,
            "sbg:revision": 29,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/159"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1531304265,
            "sbg:revision": 30,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/160"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1532539346,
            "sbg:revision": 31,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/161"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1532539347,
            "sbg:revision": 32,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/162"
        },
        {
            "sbg:modifiedBy": "admin",
            "sbg:modifiedOn": 1539595318,
            "sbg:revision": 33,
            "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/whole-exome-pipeline-bwa-gatk-4-0-with-metrics/163"
        }
    ],
    "sbg:sbgMaintained": false,
    "sbg:toolAuthor": "Broad Institute",
    "sbg:toolkit": "GATK",
    "sbg:toolkitVersion": "4.0.2.0",
    "sbg:validationErrors": [],
    "steps": [
        {
            "id": "SBG_Untar_fasta",
            "in": [
                {
                    "id": "input_tar_with_reference",
                    "source": [
                        "reference"
                    ]
                }
            ],
            "out": [
                {
                    "id": "output_fasta"
                }
            ],
            "run": {
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "${\n    reference_file = inputs.input_tar_with_reference.path.split('/')[inputs.input_tar_with_reference.path.split('/').length - 1]\n    ext = reference_file.split('.')[reference_file.split('.').length - 1]\n    if (ext == 'tar') {\n        return 'tar -xf ' + reference_file\n    } else {\n        return 'echo Passing input file '\n    }\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "SBG Untar fasta is primarily used for extracting FASTA file from TAR with more different files. For example, extracting FASTA from BWA-MEM's index TAR.\n\n**Inputs**\n\nTAR (containing FASTA).\n\n**Outputs**\n\nFA/FASTA/FA.GZ/FASTA.GZ from TAR.\n\n\n\n**Important: TAR.GZ format is not supported. \nIf only decompress operation is required use SBG Decompressor tool.**",
                "hints": [],
                "id": "bix-demo/sbgtools-demo/sbg-untar-fasta/11",
                "inputs": {
                    "input_tar_with_reference": {
                        "doc": "The input archive file to be unpacked.",
                        "label": "Input archive file with fasta",
                        "sbg:fileTypes": "TAR,FA,FASTA,FA.GZ,FASTA.GZ",
                        "type": "File"
                    }
                },
                "label": "SBG Untar fasta",
                "outputs": {
                    "output_fasta": {
                        "doc": "Unpacked fasta file from the input archive.",
                        "label": "Unpacked fasta file",
                        "outputBinding": {
                            "glob": "{*.fasta,*.fa,*.fa.gz,*.fasta.gz}",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.input_tar_with_reference)\n\n}"
                        },
                        "type": "File"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "58b79c627f95",
                        "dockerPull": "images.sbgenomics.com/markop/sbg-decompressor:1.0"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": 1000
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": [
                            "$(inputs.input_tar_with_reference)"
                        ]
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "Other"
                ],
                "sbg:cmdPreview": "echo Passing input file",
                "sbg:contributors": [
                    "bix-demo",
                    "vladimirk"
                ],
                "sbg:createdBy": "bix-demo",
                "sbg:homepage": "https://igor.sbgenomics.com/",
                "sbg:id": "admin/sbg-public-data/sbg-untar-fasta/12",
                "sbg:image_url": null,
                "sbg:latestRevision": 11,
                "sbg:license": "Apache License 2.0",
                "sbg:project": "bix-demo/sbgtools-demo",
                "sbg:revisionNotes": "description - bold important",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Vladimir Kovacevic, Seven Bridges Genomics",
                "sbg:toolkit": "SBGTools",
                "sbg:toolkitVersion": "v1.0",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 108.33339318964445,
            "sbg:y": -130.5728811650625
        },
        {
            "id": "Sambamba_Merge",
            "in": [
                {
                    "default": 1,
                    "id": "reserved_threads"
                },
                {
                    "default": 4,
                    "id": "num_of_threads"
                },
                {
                    "id": "mem_mb"
                },
                {
                    "id": "compression_level"
                },
                {
                    "id": "bams",
                    "source": [
                        "BWA_MEM_Bundle/aligned_reads"
                    ]
                }
            ],
            "out": [
                {
                    "id": "merged_bam"
                }
            ],
            "run": {
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.bams instanceof Array) { // VK\n        if (inputs.bams[0] instanceof Array) {\n\n            // Support for input received as list of one-element-lists \n            in_var = []\n            for (i = 0; i < inputs.bams.length; i++)\n                in_var = in_var.concat(inputs.bams[i]);\n\n        } else {\n            in_var = [].concat(inputs.bams)\n        }\n\n\n    } else {\n        in_var = [].concat(inputs.bams)\n    }\n    comm = ''\n    if (in_var instanceof Array) // Always true\n    {\n        if (in_var.length == 1) {\n            comm += 'cp '\n\n        } else if (in_var.length > 1) {\n\n            comm += '/opt/sambamba_0.5.9/sambamba_v0.5.9 merge '\n            if (inputs.num_of_threads) {\n                comm += ' -t '\n                comm += inputs.num_of_threads\n            }\n            if (inputs.compression_level) {\n                comm += ' -l '\n                comm += inputs.compression_level\n            }\n\n        }\n\n\n\n    }\n    return comm\n}"
                    },
                    {
                        "position": 11,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.bams instanceof Array) { // VK\n        if (inputs.bams[0] instanceof Array) {\n\n            // Support for input received as list of one-element-lists \n            in_var = []\n            for (i = 0; i < inputs.bams.length; i++)\n                in_var = in_var.concat(inputs.bams[i]);\n\n        } else {\n            in_var = [].concat(inputs.bams)\n        }\n\n\n    } else {\n        in_var = [].concat(inputs.bams)\n    }\n\n    comm = ''\n    if (in_var.length == 1) {\n        comm += '. '\n\n        if (in_var[0].secondaryFiles != undefined && in_var[0].secondaryFiles.length > 0) {\n            comm += '| cp '\n            comm += in_var[0].secondaryFiles[0].path\n            comm += ' . '\n        }\n    }\n    return comm\n}"
                    },
                    {
                        "position": 6,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n\n    function common_end(strs) {\n\n        // Find minimum length of file name\n\n        ls = [];\n        whole = [];\n        for (i = 0; i < strs.length; i++) {\n            ls = ls.concat(strs[i].path.split('/').pop().length);\n            whole = whole.concat(strs[i].path.length);\n        }\n        l = Math.min.apply(Math, ls);\n\n        // Loop from the end through characters and check if they are the same for all\n\n        ind = 0;\n        flag = 0;\n        for (i = 1; i <= l; i++) {\n            for (j = 1; j < strs.length; j++) {\n                if (strs[0].path[whole[0] - i] != strs[j].path[whole[j] - i]) {\n                    flag = 1;\n                    break\n                }\n            }\n            if (flag == 1) {\n                break\n            } else {\n                ind = ind + 1;\n            }\n        }\n\n        // Assign and return longest ending common substring\n        if (ind > 0) {\n            comstr = strs[0].path.slice(-ind);\n        } else {\n            comstr = 'different_extensions'\n        }\n\n        return comstr\n\n    }\n\n    if (inputs.bams instanceof Array) { // VK\n        if (inputs.bams[0] instanceof Array) {\n\n            // Support for input received as list of one-element-lists \n            in_var = []\n            for (i = 0; i < inputs.bams.length; i++)\n                in_var = in_var.concat(inputs.bams[i]);\n\n        } else {\n            in_var = [].concat(inputs.bams)\n        }\n\n\n    } else {\n        in_var = [].concat(inputs.bams)\n    }\n\n    prefix = ''\n\n    if (in_var.length == 1) {\n        return '' // Input will be just passed to output\n    } else if (in_var[0].metadata) {\n        if (\"sample_id\" in in_var[0].metadata) {\n            prefix = in_var[0].metadata[\"sample_id\"];\n        } else {\n            prefix = 'sample_unknown';\n        }\n\n    } else {\n        prefix = 'sample_unknown';\n    }\n\n    // Create joint name and add the merged suffix\n    joint_name = prefix + '_' + common_end(in_var);\n    name = joint_name.split('.').slice(0, -1).join('.') + '.merged.bam'\n\n\n\n    return name\n\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Sambamba Merge is used for merging several sorted BAM files into one. The sorting order of all the files must be the same, and it is maintained in the output file.",
                "hints": [],
                "id": "bix-demo/sambamba-0-5-9-demo/sambamba-merge-0-5-9/18",
                "inputs": {
                    "bams": {
                        "doc": "Input BAM files.",
                        "inputBinding": {
                            "position": 6,
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "BAM files",
                        "sbg:category": "Merge",
                        "sbg:fileTypes": "BAM",
                        "type": "File[]"
                    },
                    "compression_level": {
                        "doc": "Level of compression for merged BAM file, number from 0 to 9.",
                        "label": "Compression level",
                        "sbg:category": "Merge",
                        "type": "int?"
                    },
                    "mem_mb": {
                        "doc": "Memory in MB.",
                        "label": "Memory in MB",
                        "sbg:category": "Execution",
                        "sbg:toolDefaultValue": "1024",
                        "type": "int?"
                    },
                    "num_of_threads": {
                        "doc": "Number of threads to use for compression/decompression.",
                        "label": "Number of threads to use",
                        "sbg:category": "Merge",
                        "type": "int?"
                    },
                    "reserved_threads": {
                        "doc": "Number of threads reserved on the instance passed to the scheduler (number of jobs).",
                        "label": "Number of threads reserved on the instance",
                        "sbg:category": "Execution",
                        "sbg:toolDefaultValue": "1",
                        "type": "int?"
                    }
                },
                "label": "Sambamba Merge",
                "outputs": {
                    "merged_bam": {
                        "doc": "Merged bam.",
                        "label": "Merged bam",
                        "outputBinding": {
                            "glob": "*.bam",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.bams)\n\n}"
                        },
                        "sbg:fileTypes": "BAM",
                        "secondaryFiles": [
                            ".bai",
                            "^.bai"
                        ],
                        "type": "File?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": "${\n    if (inputs.reserved_threads) {\n\n        return inputs.reserved_threads\n\n    } else if (inputs.num_of_threads) {\n\n        return inputs.num_of_threads\n\n    } else {\n\n        return 1\n    }\n\n}",
                        "ramMin": "${\n    if (inputs.mem_mb) {\n\n        return inputs.mem_mb\n\n    } else {\n\n        return 1024\n\n    }\n\n}"
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "",
                        "dockerPull": "images.sbgenomics.com/mladenlsbg/sambamba:0.5.9"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": []
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "SAM/BAM-Processing"
                ],
                "sbg:cmdPreview": "/opt/sambamba_0.5.9/sambamba_v0.5.9 merge  -t 6  /path/to/uuu_bams.bam  /path/to/uyyy_bams.bam  testmeta__bams.merged.bam",
                "sbg:contributors": [
                    "nevenam",
                    "nevenam.sudo",
                    "vladimirk",
                    "ognjenm"
                ],
                "sbg:createdBy": "nevenam.sudo",
                "sbg:id": "admin/sbg-public-data/sambamba-merge-0-5-9/18",
                "sbg:image_url": null,
                "sbg:latestRevision": 18,
                "sbg:license": "GNU General Public License v2.0 only",
                "sbg:links": [
                    {
                        "id": "http://lomereiter.github.io/sambamba/docs/sambamba-view.html",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://github.com/lomereiter/sambamba",
                        "label": "Source code"
                    },
                    {
                        "id": "https://github.com/lomereiter/sambamba/wiki",
                        "label": "Wiki"
                    },
                    {
                        "id": "https://github.com/lomereiter/sambamba/releases/tag/v0.5.9",
                        "label": "Download"
                    },
                    {
                        "id": "http://lomereiter.github.io/sambamba/docs/sambamba-view.html",
                        "label": "Publication"
                    }
                ],
                "sbg:project": "bix-demo/sambamba-0-5-9-demo",
                "sbg:revisionNotes": "Added reserved number of threads.",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Artem Tarasov",
                "sbg:toolkit": "Sambamba",
                "sbg:toolkitVersion": "0.5.9",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 632.4362270437216,
            "sbg:y": 11.538349064137936
        },
        {
            "id": "SAMtools_Depth",
            "in": [
                {
                    "id": "truncate_depth"
                },
                {
                    "id": "total_memory_GB"
                },
                {
                    "id": "output_all_positions"
                },
                {
                    "id": "output_absolutely_all_positions"
                },
                {
                    "id": "mapping_quality_min"
                },
                {
                    "id": "ignore_short_reads"
                },
                {
                    "default": 20,
                    "id": "coverage_limit"
                },
                {
                    "id": "bed",
                    "source": [
                        "intervals_file"
                    ]
                },
                {
                    "id": "base_quality_min"
                },
                {
                    "id": "alignment_input_file",
                    "source": [
                        "Sambamba_Merge/merged_bam"
                    ]
                }
            ],
            "out": [
                {
                    "id": "percentage_coverage_larger_than_limit"
                },
                {
                    "id": "coverage_per_position"
                },
                {
                    "id": "coverage"
                }
            ],
            "run": {
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/samtools-1.3/samtools"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "depth"
                    },
                    {
                        "position": 1002,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n\n    filepath = [].concat(inputs.alignment_input_file)[0].path\n    filename = filepath.split(\"/\").pop()\n    file_dot_sep = filename.split(\".\")\n    file_ext = file_dot_sep[file_dot_sep.length - 1]\n\n    filename = filename + '.depth'\n    cmd = ' > ' + filename\n\n    if (inputs.coverage_limit)\n        cov_limit = inputs.coverage_limit\n    else\n        cov_limit = 20\n\n    cmd2 = 'awk \\'BEGIN {FS = \\\"\\\\t\\\"; } ; {sum+=$3;cnt+=1;if($3 > ' + cov_limit + ') perc+=1} END {printf(\\\"%.0f %.2f%% \\\", sum / cnt ,perc / cnt * 100)}\\' ' + filename\n\n    return cmd + ';' + cmd2 + ' > coverage.txt'\n\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "**SAMtools depth** computes the depth at each position or region.",
                "hints": [],
                "id": "marouf/samtools-1-3-demo/samtools-depth-1-3/8",
                "inputs": {
                    "alignment_input_file": {
                        "doc": "Alignment input file.",
                        "inputBinding": {
                            "position": 9,
                            "separate": true,
                            "shellQuote": false,
                            "valueFrom": "${\n    inputs.alignment_input_file.path\n    path = inputs.alignment_input_file.path\n    len = path.split('/').length\n    path = path.split('/')[len - 1]\n    return path\n\n}"
                        },
                        "label": "Alignment input file",
                        "sbg:category": "Input Files",
                        "sbg:fileTypes": "BAM,CRAM,SAM",
                        "type": "File"
                    },
                    "base_quality_min": {
                        "doc": "Only count reads with base quality greater than value.",
                        "inputBinding": {
                            "position": 2,
                            "prefix": "-q",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Base quality minimum",
                        "sbg:category": "configuration",
                        "type": "int?"
                    },
                    "bed": {
                        "doc": "Compute depth at list of positions or regions in specified BED FILE.",
                        "inputBinding": {
                            "position": 2,
                            "prefix": "-b",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "BED file",
                        "sbg:category": "Configuration",
                        "sbg:fileTypes": "BED",
                        "type": "File?"
                    },
                    "coverage_limit": {
                        "doc": "Used with calculation of percentage of coverage larger than this value.",
                        "label": "Set limit coverage",
                        "sbg:category": "Configuration",
                        "sbg:toolDefaultValue": "20",
                        "type": "int?"
                    },
                    "ignore_short_reads": {
                        "doc": "Ignore reads shorter than INT.",
                        "inputBinding": {
                            "position": 2,
                            "prefix": "-l",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ignore short reads",
                        "sbg:category": "configuration",
                        "type": "int?"
                    },
                    "mapping_quality_min": {
                        "doc": "Only count reads with mapping quality greater than value.",
                        "inputBinding": {
                            "position": 2,
                            "prefix": "-Q",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mapping quality minimum",
                        "sbg:category": "configuration",
                        "type": "int?"
                    },
                    "output_absolutely_all_positions": {
                        "doc": "Output absolutely all positions, including unused reference sequences. Note that when used in conjunction with a BED file the -a option may sometimes operate as if -aa was specified if the reference sequence has coverage outside of the region specified in the BED file.",
                        "inputBinding": {
                            "position": 2,
                            "prefix": "-aa",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Output absolutely all positions",
                        "sbg:category": "configuration",
                        "type": "boolean?"
                    },
                    "output_all_positions": {
                        "doc": "Output all positions (including those with zero depth).",
                        "inputBinding": {
                            "position": 2,
                            "prefix": "-a",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Output all positions",
                        "sbg:category": "configuration",
                        "type": "boolean?"
                    },
                    "total_memory_GB": {
                        "doc": "In GB, default 1.",
                        "label": "Total memory",
                        "sbg:category": "Configuration",
                        "type": "int?"
                    },
                    "truncate_depth": {
                        "doc": "Truncate reported depth at a maximum of INT reads.",
                        "inputBinding": {
                            "position": 2,
                            "prefix": "-m",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Truncate reported depth",
                        "sbg:category": "configuration",
                        "sbg:toolDefaultValue": "8000",
                        "type": "int?"
                    }
                },
                "label": "SAMtools Depth",
                "outputs": {
                    "coverage": {
                        "doc": "Calculated average coverage per position.",
                        "label": "Average coverage",
                        "outputBinding": {
                            "glob": "coverage.txt",
                            "loadContents": true,
                            "outputEval": "${\n    return self[0].contents.split(' ')[0]\n}"
                        },
                        "type": "string?"
                    },
                    "coverage_per_position": {
                        "doc": "Coverage per position.",
                        "label": "Coverage per position",
                        "outputBinding": {
                            "glob": "*.depth",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.alignment_input_file)\n\n}"
                        },
                        "sbg:fileTypes": "DEPTH",
                        "type": "File?"
                    },
                    "percentage_coverage_larger_than_limit": {
                        "doc": "Percentage of coverage larger than limit.",
                        "label": "Percentage of coverage larger than limit",
                        "outputBinding": {
                            "glob": "coverage.txt",
                            "loadContents": true,
                            "outputEval": "${\n    return self[0].contents.split(' ')[1]\n}"
                        },
                        "type": "float?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n\n    if (inputs.total_memory_GB) {\n        total_memory_MB = 1024 * inputs.total_memory_GB\n    } else {\n        total_memory_MB = 1024 * 1\n    }\n\n    return (total_memory_MB)\n}"
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "",
                        "dockerPull": "images.sbgenomics.com/marouf/samtools:1.3"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": [
                            "$(inputs.alignment_input_file)"
                        ]
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "SAM/BAM-Processing"
                ],
                "sbg:cmdPreview": "/opt/samtools-1.3/samtools depth  input.bam   > input.bam.depth;awk 'BEGIN {FS = \"\\t\"; } ; {sum+=$3;cnt+=1;if($3 > 4) perc+=1} END {printf(\"%.0f %.2f%% \", sum / cnt ,perc / cnt * 100)}' input.bam.depth > coverage.txt",
                "sbg:contributors": [
                    "vladimir_obucina",
                    "vladimirk"
                ],
                "sbg:createdBy": "vladimirk",
                "sbg:id": "admin/sbg-public-data/samtools-depth-1-3/8",
                "sbg:image_url": null,
                "sbg:latestRevision": 8,
                "sbg:license": "BSD License, MIT License",
                "sbg:links": [
                    {
                        "id": "http://www.htslib.org",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://github.com/samtools/",
                        "label": "Source Code"
                    },
                    {
                        "id": "https://sourceforge.net/projects/samtools/files/samtools/",
                        "label": "Download"
                    },
                    {
                        "id": "http://www.ncbi.nlm.nih.gov/pubmed/19505943",
                        "label": "Publication"
                    },
                    {
                        "id": "http://www.htslib.org/doc/samtools-1.3.html",
                        "label": "Wiki"
                    }
                ],
                "sbg:project": "marouf/samtools-1-3-demo",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Changed some descriptions after CWL validation(capital letter, dots...), but the code is the same.",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Heng Li/Sanger Institute,  Bob Handsaker/Broad Institute, James Bonfield/Sanger Institute,",
                "sbg:toolkit": "SAMtools",
                "sbg:toolkitVersion": "v1.3",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 1243.0769230769238,
            "sbg:y": -580.0000000000002
        },
        {
            "id": "GATK_CollectAlignmentSummaryMetrics",
            "in": [
                {
                    "id": "verbosity"
                },
                {
                    "id": "validation_stringency"
                },
                {
                    "id": "stop_after"
                },
                {
                    "id": "reference",
                    "source": [
                        "SBG_FASTA_Indices/fasta_reference"
                    ]
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "metric_accumulation_level"
                },
                {
                    "id": "memory_per_job"
                },
                {
                    "id": "max_records_in_ram"
                },
                {
                    "id": "max_insert_size"
                },
                {
                    "id": "is_bisulfite_sequenced"
                },
                {
                    "id": "input_bam",
                    "source": [
                        "Sambamba_Merge/merged_bam"
                    ]
                },
                {
                    "id": "gcs_max_retries"
                },
                {
                    "id": "compression_level"
                },
                {
                    "id": "assume_sorted"
                },
                {
                    "id": "adapter_sequence"
                }
            ],
            "out": [
                {
                    "id": "summary_metrics"
                }
            ],
            "run": {
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk-launch"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--javaOptions"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "CollectAlignmentSummaryMetrics"
                    },
                    {
                        "position": 7,
                        "prefix": "--output",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.input_bam) {\n        filename = [].concat(inputs.input_bam)[0].path\n        filebase = filename.split('.').slice(0, -1)\n\n        return filebase.concat(\"summary_metrics.txt\").join(\".\").replace(/^.*[\\\\\\/]/, '')\n    }\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Produces from a SAM/BAM/CRAM file containing summary alignment metrics.\n\n###**Overview**  \n\nCollectAlignmentSummaryMetrics assesses the quality of alignment by analyzing a SAM or BAM file. It compares it with the reference file (FASTA) and provides alignment statistics, such as the number of input reads and the percent of reads that are mapped. It produces a file which contains summary alignment metrics from a SAM or BAM file.\n\nNote: This tool requires the exact same FASTA file as the one to which raw reads were aligned.\n\n###**Inputs**  \nA BAM or SAM file.\n\n###**Outputs**  \nAn alignment summary file. \n\n###**Usage example**\n\n    java -Xmx4g -jar gatk.jar \\  \n         CollectAlignmentSummaryMetrics \\  \n         --reference reference.fasta \\\n         --input input.bam \\\n         --output summary_metrics.txt\n\n###**Common issues**\n\n1) BAM file - Sort order should be coordinate based.\n2) Reference sequence file - Note that while this argument is not required, without it only a small subset of the metrics will be calculated. If reference sequence file is used, sequence index and dictionary are required. This tool requires the exact same FASTA file as the one to which raw reads were aligned.\n\n###**IMPORTANT NOTICE**  \n\nTools in GATK that require a fasta reference file also look for the reference file's corresponding *.fai* (fasta index) and *.dict* (fasta dictionary) files. The fasta index file allows random access to reference bases and the dictionary file is a dictionary of the contig names and sizes contained within the fasta reference. These two secondary files are essential for GATK to work properly. To append these two files to your fasta reference please use the '***SBG FASTA Indices***' tool within your GATK based workflow before using any of the GATK tools.",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-4-0-collectalignmentsummarymetrics/7",
                "inputs": {
                    "adapter_sequence": {
                        "doc": "List of adapter sequences to use when processing the alignment metrics. Default value: [AATGATACGGCGACCACCGAGATCTACACTCTTTCCCTACACGACGCTCTTCCGATCT, AGATCGGAAGAGCTCGTATGCCGTCTTCTGCTTG, AATGATACGGCGACCACCGAGATCTACACTCTTTCCCTACACGACGCTCTTCCGATCT, AGATCGGAAGAGCGGTTCAGCAGGAATGCCGAGACCGATCTCGTATGCCGTCTTCTGCTTG, AATGATACGGCGACCACCGAGATCTACACTCTTTCCCTACACGACGCTCTTCCGATCT, AGATCGGAAGAGCACACGTCTGAACTCCAGTCACNNNNNNNNATCTCGTATGCCGTCTTCTGCTTG]. This option can be set to 'null' to clear the default value. This option may be specified 0 or more times. This option can be set to 'null' to clear the default list.",
                        "inputBinding": {
                            "itemSeparator": " --ADAPTER_SEQUENCE ",
                            "position": 12,
                            "prefix": "--ADAPTER_SEQUENCE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Adapter sequence",
                        "sbg:category": "Options",
                        "sbg:toolDefaultValue": "AATGATACGGCGACCACCGAGATCTACACTCTTTCCCTACACGACGCTCTTCCGATCT",
                        "type": "string[]?"
                    },
                    "assume_sorted": {
                        "doc": "If this parameter is set to true, the sort order in the header file will be ignored. Default value: true. This option can be set to 'null' to clear the default value. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ASSUME_SORTED",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Assume sorted",
                        "sbg:altPrefix": "-AS",
                        "sbg:category": "Options",
                        "sbg:toolDefaultValue": "true",
                        "type": "boolean?"
                    },
                    "compression_level": {
                        "doc": "Compression level for all compressed files created (e.g. BAM and GELI). Default value: 5. This option can be set to 'null' to clear the default value.",
                        "inputBinding": {
                            "position": 8,
                            "prefix": "--COMPRESSION_LEVEL",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Compression level",
                        "sbg:category": "Options",
                        "sbg:toolDefaultValue": "5",
                        "type": "int?"
                    },
                    "gcs_max_retries": {
                        "doc": "If the GCS bucket channel errors out, how many times it will attempt to re-initiate the connection.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--gcs_max_retries",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "GCS Max Retries",
                        "sbg:altPrefix": "-gcs_retries",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "20",
                        "type": "int?"
                    },
                    "input_bam": {
                        "doc": "Input SAM or BAM file.  Required. Note: Sort order should be coordinate based.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--input",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Input file",
                        "sbg:altPrefix": "-I",
                        "sbg:category": "File inputs",
                        "sbg:fileTypes": "BAM, SAM",
                        "type": "File"
                    },
                    "is_bisulfite_sequenced": {
                        "doc": "This parameter indicates whether the SAM or BAM file consists of bisulfite sequenced reads. Default value: false. This option can be set to 'null' to clear the default value. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 12,
                            "prefix": "--IS_BISULFITE_SEQUENCED",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Is bisulfite sequenced",
                        "sbg:altPrefix": "-BS",
                        "sbg:category": "Options",
                        "sbg:toolDefaultValue": "false",
                        "type": "float?"
                    },
                    "max_insert_size": {
                        "doc": "Paired end reads above this insert size will be considered chimeric along with inter-chromosomal pairs. Default value: 100000. This option can be set to 'null' to clear the default value.",
                        "inputBinding": {
                            "position": 13,
                            "prefix": "--MAX_INSERT_SIZE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max insert size",
                        "sbg:category": "Options",
                        "sbg:toolDefaultValue": "100000",
                        "type": "int?"
                    },
                    "max_records_in_ram": {
                        "doc": "When writing SAM files that need to be sorted, this parameter will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort a SAM file, and increases the amount of RAM needed. Default value: 500000. This option can be set to 'null' to clear the default value.",
                        "inputBinding": {
                            "position": 8,
                            "prefix": "--MAX_RECORDS_IN_RAM",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max records in RAM",
                        "sbg:category": "Options",
                        "sbg:toolDefaultValue": "500000",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "doc": "Amount of RAM memory to be used per job. Defaults to 2048 MB for single threaded jobs.",
                        "label": "Memory per job",
                        "sbg:category": "Execution options",
                        "sbg:toolDefaultValue": "2048",
                        "type": "int?"
                    },
                    "metric_accumulation_level": {
                        "doc": "This parameter indicates the level(s) at which to accumulate metrics. Default value: [ALL_READS]. This option can be set to 'null' to clear the default value. Possible values: {ALL_READS, SAMPLE, LIBRARY, READ_GROUP}. This option may be specified 0 or more times. This option can be set to 'null' to clear the default list.",
                        "inputBinding": {
                            "itemSeparator": " --METRIC_ACCUMULATION_LEVEL ",
                            "position": 12,
                            "prefix": "--METRIC_ACCUMULATION_LEVEL",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Metric accumulation level",
                        "sbg:altPrefix": "-LEVEL",
                        "sbg:category": "Options",
                        "sbg:toolDefaultValue": "ALL_READS",
                        "type": [
                            "null",
                            {
                                "items": {
                                    "name": "metric_accumulation_level",
                                    "symbols": [
                                        "ALL_READS",
                                        "SAMPLE",
                                        "LIBRARY",
                                        "READ_GROUP"
                                    ],
                                    "type": "enum"
                                },
                                "type": "array"
                            }
                        ]
                    },
                    "quiet": {
                        "doc": "This parameter indicates whether to suppress job-summary info on System.err. Default value: false. This option can be set to 'null' to clear the default value. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 8,
                            "prefix": "--QUIET",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:category": "Options",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "reference": {
                        "doc": "Reference sequence file. Note that while this argument is not required, without it only a small subset of the metrics will be calculated. If reference sequence file is used, sequence index and dictionary are required. This tool requires the exact same FASTA file as the one to which raw reads were aligned. Default value: null.",
                        "inputBinding": {
                            "position": 7,
                            "prefix": "--reference",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reference sequence",
                        "sbg:altPrefix": "-R",
                        "sbg:category": "File inputs",
                        "sbg:fileTypes": "FASTA",
                        "type": "File?"
                    },
                    "stop_after": {
                        "doc": "Stop after processing N reads, mainly for debugging. Default value: 0. This option can be set to 'null' to clear the default value.",
                        "inputBinding": {
                            "position": 13,
                            "prefix": "--STOP_AFTER",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Stop after",
                        "sbg:category": "Options",
                        "sbg:toolDefaultValue": "0",
                        "type": "int?"
                    },
                    "validation_stringency": {
                        "doc": "Validation stringency for all SAM files read by this program. Setting stringency to SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: STRICT. This option can be set to 'null' to clear the default value. Possible values: {STRICT, LENIENT, SILENT}.",
                        "inputBinding": {
                            "position": 8,
                            "prefix": "--VALIDATION_STRINGENCY",
                            "separate": true,
                            "shellQuote": false,
                            "valueFrom": "${\n    if (inputs.validation_stringency) {\n        return inputs.validation_stringency\n    } else {\n        return \"SILENT\"\n    }\n}"
                        },
                        "label": "Validation stringency",
                        "sbg:category": "Options",
                        "sbg:toolDefaultValue": "SILENT",
                        "type": [
                            "null",
                            {
                                "name": "validation_stringency",
                                "symbols": [
                                    "STRICT",
                                    "LENIENT",
                                    "SILENT"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. This option can be set to 'null' to clear the default value. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 10,
                            "prefix": "--verbosity",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:altPrefix": "-verbosity",
                        "sbg:category": "Options",
                        "sbg:toolDefaultValue": "INFO",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "GATK CollectAlignmentSummaryMetrics",
                "outputs": {
                    "summary_metrics": {
                        "doc": "File to which the output will be written.",
                        "label": "Summary metrics",
                        "outputBinding": {
                            "glob": "*.summary_metrics.txt",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.input_bam)\n\n}"
                        },
                        "sbg:fileTypes": "TXT",
                        "secondaryFiles": [],
                        "type": "File"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "eab0e70b6629",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.beta.2"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        return inputs.memory_per_job\n    }\n    return 2048\n}"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": []
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "SAM/BAM-Processing",
                    "Quality-Control",
                    "Quantification",
                    "GATK-4.0"
                ],
                "sbg:cmdPreview": "/opt/gatk-launch --javaOptions \"-Xmx2048M\" CollectAlignmentSummaryMetrics --input /root/folder/example.bam --output example.summary_metrics.txt",
                "sbg:contributors": [
                    "teodora.aleksic"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/Picard_CollectAlignmentSummaryMetrics/14",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-4-0-collectalignmentsummarymetrics/7",
                "sbg:image_url": null,
                "sbg:latestRevision": 7,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/index.php",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://github.com/broadinstitute/gatk",
                        "label": "Source Code"
                    },
                    {
                        "id": "https://gatkforums.broadinstitute.org/gatk/discussion/9881/howto-get-started-with-gatk4-beta",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/Picard_CollectAlignmentSummaryMetrics/14",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK 4.0",
                "sbg:toolkitVersion": "Beta 2",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 1080.0004099210255,
            "sbg:y": -361.6667013830619
        },
        {
            "id": "SnpEff",
            "in": [
                {
                    "id": "variants_file",
                    "source": [
                        "GATK_MergeVcfs_2/output"
                    ]
                },
                {
                    "id": "use_csv_stats"
                },
                {
                    "id": "up_down_stream_len"
                },
                {
                    "id": "total_memory"
                },
                {
                    "id": "threads"
                },
                {
                    "id": "strict"
                },
                {
                    "id": "stats"
                },
                {
                    "id": "splicesitesize"
                },
                {
                    "id": "splice_region_exons_size"
                },
                {
                    "id": "sequenceontology"
                },
                {
                    "id": "reg"
                },
                {
                    "id": "output_format"
                },
                {
                    "id": "onlyreg"
                },
                {
                    "id": "only_protein"
                },
                {
                    "id": "oicr"
                },
                {
                    "id": "nostats"
                },
                {
                    "id": "no_utr"
                },
                {
                    "id": "no_upstream"
                },
                {
                    "id": "no_shift_hgvs"
                },
                {
                    "id": "no_next_prot"
                },
                {
                    "id": "no_motif"
                },
                {
                    "id": "no_lof"
                },
                {
                    "id": "no_intron"
                },
                {
                    "id": "no_intergenic"
                },
                {
                    "id": "no_interaction"
                },
                {
                    "id": "no_hgvs"
                },
                {
                    "id": "no_genome"
                },
                {
                    "id": "no_downstream"
                },
                {
                    "id": "nextprot"
                },
                {
                    "id": "motif"
                },
                {
                    "id": "max_tsl"
                },
                {
                    "id": "interval"
                },
                {
                    "id": "interaction"
                },
                {
                    "id": "input_format"
                },
                {
                    "id": "hgvs_tr_id"
                },
                {
                    "id": "hgvs_1_letter"
                },
                {
                    "id": "geneid"
                },
                {
                    "id": "format_eff"
                },
                {
                    "id": "filterinterval"
                },
                {
                    "id": "database",
                    "source": [
                        "database"
                    ]
                },
                {
                    "id": "csvstats"
                },
                {
                    "id": "configuration_file"
                },
                {
                    "id": "classic"
                },
                {
                    "id": "canon"
                },
                {
                    "id": "cancersamples"
                },
                {
                    "id": "cancer"
                },
                {
                    "id": "assembly"
                },
                {
                    "id": "add_lof_tag"
                },
                {
                    "id": "add_hgvs_anno"
                }
            ],
            "out": [
                {
                    "id": "summary_text"
                },
                {
                    "id": "summary"
                },
                {
                    "id": "csvstats_file"
                },
                {
                    "id": "annotated"
                }
            ],
            "run": {
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "${\n    return 'unzip -o ' + inputs.database.path + ' -d /opt/snpEff ;'\n}"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "java"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    //java -Xmx4g path/to/snpEff/snpEff.jar -c path/to/snpEff/snpEff.config GRCh37.75 path/to/snps.vcf\n    if (inputs.total_memory) {\n        mem_mb = parseInt(inputs.total_memory) * 1024\n        return '-Xmx'.concat(mem_mb, 'M')\n    }\n    return '-Xmx8192M'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "-jar"
                    },
                    {
                        "position": 4,
                        "shellQuote": false,
                        "valueFrom": "/opt/snpEff/snpEff.jar"
                    },
                    {
                        "position": 5005,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    filename = [].concat(inputs.variants_file)[0].path\n    basename = filename.split('.').slice(0, filename.split('.').length - 1).join('.').replace(/^.*[\\\\\\/]/, '')\n\n\n    if (inputs.output_format === \"txt\") {\n        name = basename.concat(\".snpEff_annotated.txt\")\n    } else if (inputs.output_format === \"bed\" || inputs.output_format === \"bedAnn\") {\n        name = basename.concat(\".snpEff_annotated.bed\")\n    } else {\n        name = basename.concat(\".snpEff_annotated.vcf\")\n    }\n    return '> ' + name\n}"
                    },
                    {
                        "position": 5,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "-nodownload"
                    },
                    {
                        "position": 5,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "-noLog"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "SnpEff is a variant annotation and effect prediction\u200b tool. It annotates and predicts the effects of variants on genes, such as amino acid changes.\n\nTypical usage assumes the user chooses inputs that are predicted variants (SNPs, insertions, deletions, and MNPs). This input file is usually the result of a sequencing experiment, and it is usually in variant call format (VCF). SnpEff analyzes the input variants and, in the process, it annotates the variants and calculates the effects they produce on known genes (e.g. amino acid changes). The output file can be in several file formats. The most common format is VCF.\n\nThere is also a command line option to control the amount of RAM in MB [-Xmx%m] for java, which is a custom parameter.",
                "hints": [],
                "id": "vladimirk/snpeff-4-2-demo/snpeff-4-2/38",
                "inputs": {
                    "add_hgvs_anno": {
                        "doc": "Use HGVS annotations for amino acid sub-field. Default: true.",
                        "inputBinding": {
                            "position": 175,
                            "prefix": "-hgvs",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use HGVS annotations for amino acid sub-field",
                        "sbg:category": "Annotations options",
                        "sbg:toolDefaultValue": "TRUE",
                        "type": "boolean?"
                    },
                    "add_lof_tag": {
                        "doc": "Add loss of function (LOF) and Nonsense mediated decay (NMD) tags.",
                        "inputBinding": {
                            "position": 205,
                            "prefix": "-lof",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Add loss of function (LOF) and Nonsense mediated decay (NMD) tags",
                        "sbg:category": "Other input types",
                        "type": "boolean?"
                    },
                    "assembly": {
                        "doc": "Assembly corresponding to the snpEff database used (e.g. GRCh37.75; GRCh38.p19; hg19).",
                        "label": "Assembly",
                        "sbg:category": "Options",
                        "type": "string?"
                    },
                    "cancer": {
                        "doc": "Perform 'cancer' comparisons (Somatic vs Germline).",
                        "inputBinding": {
                            "position": 145,
                            "prefix": "-cancer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Perform 'cancer' comparisons (Somatic vs Germline)",
                        "sbg:category": "Annotations options",
                        "sbg:toolDefaultValue": "FALSE",
                        "type": "boolean?"
                    },
                    "cancersamples": {
                        "doc": "Two column TXT file defining 'original \\t derived' samples.",
                        "inputBinding": {
                            "position": 155,
                            "prefix": "-cancerSamples",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Two column TXT file defining 'original and derived' samples",
                        "sbg:category": "Annotations options",
                        "sbg:fileTypes": "TXT",
                        "type": "File?"
                    },
                    "canon": {
                        "doc": "Only use canonical transcripts.",
                        "inputBinding": {
                            "position": 305,
                            "prefix": "-canon",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Only use canonical transcripts",
                        "sbg:category": "Database options",
                        "type": "boolean?"
                    },
                    "classic": {
                        "doc": "Use old style annotations instead of Sequence Ontology and Hgvs.",
                        "inputBinding": {
                            "position": 15,
                            "prefix": "-classic",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use old style annotations",
                        "sbg:category": "General options",
                        "type": "boolean?"
                    },
                    "configuration_file": {
                        "doc": "Specify config file.",
                        "inputBinding": {
                            "position": 265,
                            "prefix": "-c",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Configuration file",
                        "sbg:category": "Generic options",
                        "sbg:fileTypes": "config",
                        "type": "File?"
                    },
                    "csvstats": {
                        "doc": "Create CSV summary file instead of HTML.",
                        "inputBinding": {
                            "position": 25,
                            "separate": true,
                            "shellQuote": false,
                            "valueFrom": "${\n    if (inputs.csvstats) {\n        return '-csvStats ' + inputs.csvstats.concat(\".csv\")\n    }\n}"
                        },
                        "label": "Create CSV summary file instead of HTML",
                        "sbg:category": "Other input types",
                        "type": "string?"
                    },
                    "database": {
                        "doc": "SnpEff database file is zip archive that can be downloaded from the SnpEff official site, or using the SnpEff download app.",
                        "inputBinding": {
                            "position": 2005,
                            "separate": true,
                            "shellQuote": false,
                            "valueFrom": "${\n    if (!inputs.assembly) {\n        input_database = inputs.database\n        full_name = input_database.path.split('/')[input_database.path.split('/').length - 1]\n        name = full_name.slice(0, -4) // Cut .zip extension\n        return name\n    } else {\n        return inputs.assembly\n    }\n}"
                        },
                        "label": "SnpEff database file",
                        "sbg:category": "File type inputs",
                        "sbg:fileTypes": "ZIP",
                        "type": "File"
                    },
                    "filterinterval": {
                        "doc": "Only analyze changes that intersect with the intervals specified in this file.",
                        "inputBinding": {
                            "position": 85,
                            "prefix": "--filterInterval",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Only analyze changes that intersect with the intervals specified in this file (you may use this option many times)",
                        "sbg:altPrefix": "-fi",
                        "sbg:category": "Results filter options",
                        "sbg:fileTypes": "interval",
                        "type": "File[]?"
                    },
                    "format_eff": {
                        "doc": "Use 'EFF' field compatible with older versions (instead of 'ANN').",
                        "inputBinding": {
                            "position": 165,
                            "prefix": "-formatEff",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use EFF field",
                        "sbg:category": "Annotations options",
                        "type": "boolean?"
                    },
                    "geneid": {
                        "doc": "Use gene ID instead of gene name (VCF output). Default: false.",
                        "inputBinding": {
                            "position": 175,
                            "prefix": "-geneId",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use gene ID instead of gene name (VCF output)",
                        "sbg:category": "Annotations options",
                        "sbg:toolDefaultValue": "FALSE",
                        "type": "boolean?"
                    },
                    "hgvs_1_letter": {
                        "doc": "Use one letter Amino acid codes in HGVS notation. Default: false.",
                        "inputBinding": {
                            "position": 185,
                            "prefix": "-hgvs1LetterAa",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use one letter Amino acid codes in HGVS",
                        "sbg:category": "Annotations options",
                        "type": "boolean?"
                    },
                    "hgvs_tr_id": {
                        "doc": "Use transcript ID in HGVS notation. Default: false.",
                        "inputBinding": {
                            "position": 195,
                            "prefix": "-hgvsTrId",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use transcript ID in HGVS",
                        "sbg:category": "Configuration",
                        "type": "boolean?"
                    },
                    "input_format": {
                        "doc": "Input format. Possible values: {vcf, txt, pileup, bed}. [Default: vcf].",
                        "inputBinding": {
                            "position": 45,
                            "prefix": "-i",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Input format",
                        "sbg:category": "Other input types",
                        "sbg:toolDefaultValue": "vcf",
                        "type": [
                            "null",
                            {
                                "name": "input_format",
                                "symbols": [
                                    "vcf",
                                    " txt",
                                    " pileup",
                                    " bed"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "interaction": {
                        "doc": "Annotate using inteactions (requires interaciton database). Default: true.",
                        "inputBinding": {
                            "position": 315,
                            "prefix": "-interaction",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Annotate using interactions",
                        "sbg:category": "Database options",
                        "sbg:toolDefaultValue": "TRUE",
                        "type": "boolean?"
                    },
                    "interval": {
                        "doc": "Use a custom intervals in TXT/BED/BigBed/VCF/GFF file (you may use this option many times).",
                        "inputBinding": {
                            "position": 325,
                            "prefix": "-interval",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use a custom intervals in TXT/BED/BigBed/VCF/GFF file (you may use this option many times)",
                        "sbg:category": "Other input types",
                        "sbg:fileTypes": "interval",
                        "type": "File?"
                    },
                    "max_tsl": {
                        "doc": "Only use transcripts having Transcript Support Level lower than <TSL_number>.",
                        "inputBinding": {
                            "position": 335,
                            "prefix": "-maxTSL",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max TSL",
                        "sbg:category": "Database options",
                        "type": "int?"
                    },
                    "motif": {
                        "doc": "Annotate using motifs (requires Motif database).",
                        "inputBinding": {
                            "position": 345,
                            "prefix": "-motif",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Annotate using motifs (requires Motif database)",
                        "sbg:category": "Other input types",
                        "type": "boolean?"
                    },
                    "nextprot": {
                        "doc": "Annotate using NextProt (requires NextProt database).",
                        "inputBinding": {
                            "position": 355,
                            "prefix": "-nextProt",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Annotate using NextProt (requires NextProt database)",
                        "sbg:category": "Other input types",
                        "type": "boolean?"
                    },
                    "no_downstream": {
                        "doc": "Do not show DOWNSTREAM changes.",
                        "inputBinding": {
                            "position": 95,
                            "prefix": "-no-downstream",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Do not show DOWNSTREAM changes",
                        "sbg:category": "Results filter options",
                        "type": "boolean?"
                    },
                    "no_genome": {
                        "doc": "Do not load any genomic database (e.g. annotate using custom files).",
                        "inputBinding": {
                            "position": 365,
                            "prefix": "-noGenome",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Do not load any genomic database",
                        "sbg:category": "Database options",
                        "type": "boolean?"
                    },
                    "no_hgvs": {
                        "doc": "Do not add HGVS annotations.",
                        "inputBinding": {
                            "position": 215,
                            "prefix": "-noHgvs",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Do not add HGVS annotations",
                        "sbg:category": "Annotations options",
                        "type": "boolean?"
                    },
                    "no_interaction": {
                        "doc": "Disable interaction annotations. Default: false.",
                        "inputBinding": {
                            "position": 375,
                            "prefix": "-noInteraction",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable interaction annotations",
                        "sbg:category": "Database options",
                        "sbg:toolDefaultValue": "FALSE",
                        "type": "boolean?"
                    },
                    "no_intergenic": {
                        "doc": "Do not show INTERGENIC changes.",
                        "inputBinding": {
                            "position": 105,
                            "prefix": "-no-intergenic",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Do not show INTERGENIC changes",
                        "sbg:category": "Results filter options",
                        "type": "boolean?"
                    },
                    "no_intron": {
                        "doc": "Do not show INTRON changes.",
                        "inputBinding": {
                            "position": 115,
                            "prefix": "-no-intron",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Do not show INTRON changes",
                        "sbg:category": "Results filter options",
                        "type": "boolean?"
                    },
                    "no_lof": {
                        "doc": "Do not add LOF and NMD annotations.",
                        "inputBinding": {
                            "position": 225,
                            "prefix": "-noLof",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Do not add LOF and NMD annotations",
                        "sbg:category": "Annotations options",
                        "sbg:toolDefaultValue": "False",
                        "type": "boolean?"
                    },
                    "no_motif": {
                        "doc": "Disable motif annotations.",
                        "inputBinding": {
                            "position": 385,
                            "prefix": "-noMotif",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable motif annotations",
                        "sbg:category": "Database options",
                        "type": "boolean?"
                    },
                    "no_next_prot": {
                        "doc": "Disable NextProt annotations.",
                        "inputBinding": {
                            "position": 395,
                            "prefix": "-noNextProt",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable NextProt annotations",
                        "sbg:category": "Database options",
                        "type": "boolean?"
                    },
                    "no_shift_hgvs": {
                        "doc": "Do not shift variants according to HGVS notation (most 3prime end).",
                        "inputBinding": {
                            "position": 235,
                            "prefix": "-noShiftHgvs",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Do not shift variants according to HGVS",
                        "sbg:category": "Annotations options",
                        "sbg:toolDefaultValue": "False",
                        "type": "boolean?"
                    },
                    "no_upstream": {
                        "doc": "Do not show UPSTREAM changes.",
                        "inputBinding": {
                            "position": 125,
                            "prefix": "-no-upstream",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Do not show UPSTREAM changes",
                        "sbg:category": "Results filter options",
                        "type": "boolean?"
                    },
                    "no_utr": {
                        "doc": "Do not show 5_PRIME_UTR or 3_PRIME_UTR changes.",
                        "inputBinding": {
                            "position": 135,
                            "prefix": "-no-utr",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Do not show 5_PRIME_UTR or 3_PRIME_UTR changes",
                        "sbg:category": "Results filter options",
                        "type": "boolean?"
                    },
                    "nostats": {
                        "doc": "Do not create stats (summary) file.",
                        "inputBinding": {
                            "position": 75,
                            "prefix": "-noStats",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Do not create stats (summary) file",
                        "sbg:category": "Other input types",
                        "type": "boolean?"
                    },
                    "oicr": {
                        "doc": "Add OICR tag in VCF file. Default: false.",
                        "inputBinding": {
                            "position": 245,
                            "prefix": "-oicr",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Add OICR tag in VCF file",
                        "sbg:category": "Annotations options",
                        "sbg:toolDefaultValue": "FALSE",
                        "type": "boolean?"
                    },
                    "only_protein": {
                        "doc": "Only use protein coding transcripts. Default: false.",
                        "inputBinding": {
                            "position": 415,
                            "prefix": "-onlyProtein",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Only protein",
                        "sbg:category": "Database optins",
                        "sbg:toolDefaultValue": "FALSE",
                        "type": "boolean?"
                    },
                    "onlyreg": {
                        "doc": "Only use regulation tracks.",
                        "inputBinding": {
                            "position": 405,
                            "prefix": "-onlyReg",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Only use regulation tracks",
                        "sbg:category": "Other input types",
                        "type": "boolean?"
                    },
                    "output_format": {
                        "doc": "Ouput format. Possible values: {txt, vcf, gatk, bed, bedAnn}.",
                        "inputBinding": {
                            "position": 55,
                            "prefix": "-o",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ouput format",
                        "sbg:category": "Other input types",
                        "sbg:toolDefaultValue": "vcf",
                        "type": [
                            "null",
                            {
                                "name": "output_format",
                                "symbols": [
                                    "txt",
                                    "vcf",
                                    "gatk",
                                    "bed",
                                    "bedAnn"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "reg": {
                        "doc": "Regulation track to use (this option can be used add several times).",
                        "inputBinding": {
                            "itemSeparator": " -reg ",
                            "position": 425,
                            "prefix": "-reg",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Regulation track to use (this option can be used add several times)",
                        "sbg:category": "Other input types",
                        "type": [
                            "null",
                            {
                                "items": {
                                    "type": "string"
                                },
                                "name": "reg",
                                "type": "array"
                            }
                        ]
                    },
                    "sequenceontology": {
                        "doc": "Use Sequence Ontology terms. Default: false.",
                        "inputBinding": {
                            "position": 255,
                            "prefix": "-sequenceOntology",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Sequence Ontology terms",
                        "sbg:category": "Annotations options",
                        "sbg:toolDefaultValue": "FALSE",
                        "type": "boolean?"
                    },
                    "splice_region_exons_size": {
                        "doc": "Set size for splice site region within exons. Default: 3 bases.",
                        "inputBinding": {
                            "position": 445,
                            "prefix": "-spliceRegionExonSize",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Set size for splice site region within exons",
                        "sbg:category": "Database options",
                        "sbg:toolDefaultValue": "3",
                        "type": "int?"
                    },
                    "splicesitesize": {
                        "doc": "Set size for splice sites (donor and acceptor) in bases.",
                        "inputBinding": {
                            "position": 435,
                            "prefix": "--spliceSiteSize",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Set size for splice sites (donor and acceptor) in bases",
                        "sbg:altPrefix": "-ss",
                        "sbg:category": "Other input types",
                        "sbg:toolDefaultValue": "2",
                        "type": "int?"
                    },
                    "stats": {
                        "doc": "Name of stats file (summary).",
                        "inputBinding": {
                            "position": 65,
                            "prefix": "-stats",
                            "separate": true,
                            "shellQuote": false,
                            "valueFrom": "${\n    if (inputs.stats) {\n        return inputs.stats.concat(\".snpeffsummary.html\")\n    } else {\n        return [].concat(inputs.variants_file)[0].path.split(\"/\").splice(-1)[0].split(\".\")[0].concat(\".snpeffsummary.html\")\n    }\n}"
                        },
                        "label": "Name of stats file (summary)",
                        "sbg:altPrefix": "-s",
                        "sbg:category": "Other input types",
                        "sbg:toolDefaultValue": "snpEff_summary.html",
                        "type": "string?"
                    },
                    "strict": {
                        "doc": "Only use 'validated' transcripts (i.e. sequence has been checked). Default: false.",
                        "inputBinding": {
                            "position": 485,
                            "prefix": "-strict",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Only use validated transcripts",
                        "sbg:category": "Database optins",
                        "type": "boolean?"
                    },
                    "threads": {
                        "doc": "Use multiple threads (implies '-noStats'). Default: False.",
                        "inputBinding": {
                            "position": 285,
                            "prefix": "-t",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use multiple threads (implies '-noStats')",
                        "sbg:category": "Other input types",
                        "sbg:toolDefaultValue": "FALSE",
                        "type": "boolean?"
                    },
                    "total_memory": {
                        "doc": "RAM requirement for the java process execution [Gb].",
                        "label": "Memory for the task [Gb]",
                        "sbg:category": "Other input types",
                        "sbg:toolDefaultValue": "8",
                        "type": "int?"
                    },
                    "up_down_stream_len": {
                        "doc": "Set upstream downstream interval length (in bases).",
                        "inputBinding": {
                            "position": 495,
                            "prefix": "-upDownStreamLen",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Upstream downstream interval length",
                        "sbg:category": "Database optins",
                        "type": "int?"
                    },
                    "use_csv_stats": {
                        "doc": "Use CSV statistics for metrics output.",
                        "inputBinding": {
                            "position": 5,
                            "separate": true,
                            "shellQuote": false,
                            "valueFrom": "${\n    if (inputs.use_csv_stats) {\n        if (inputs.csvstats) {\n            return '-csvStats ' + inputs.csvstats.concat(\".snpeffsummary.csv\")\n        } else {\n            return '-csvStats ' + [].concat(inputs.variants_file)[0].path.split(\"/\").splice(-1)[0].split(\".\")[0].concat(\".snpeffsummary.csv\")\n        }\n    }\n}"
                        },
                        "label": "Use CSV statistics",
                        "sbg:category": "Statistics",
                        "sbg:toolDefaultValue": "CSV",
                        "type": "boolean?"
                    },
                    "variants_file": {
                        "doc": "Input variants file.",
                        "inputBinding": {
                            "position": 2006,
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Input variants file",
                        "sbg:category": "File type inputs",
                        "sbg:fileTypes": "VCF, TXT, PILEUP, BED",
                        "type": "File"
                    }
                },
                "label": "SnpEff",
                "outputs": {
                    "annotated": {
                        "doc": "SnpEff Annotated file.",
                        "label": "SnpEff Annotated file",
                        "outputBinding": {
                            "glob": "${\n    filename = [].concat(inputs.variants_file)[0].path\n    basename = filename.split('.').slice(0, filename.split('.').length - 1).join('.').replace(/^.*[\\\\\\/]/, '')\n\n\n    if (inputs.output_format === \"txt\") {\n        return basename.concat(\".snpEff_annotated.txt\")\n    } else if (inputs.output_format === \"bed\" || inputs.output_format === \"bedAnn\") {\n        return basename.concat(\".snpEff_annotated.bed\")\n    } else {\n        return basename.concat(\".snpEff_annotated.vcf\")\n    }\n}",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.variants_file)\n\n}"
                        },
                        "sbg:fileTypes": "VCF, TXT, GATK, BED, BEDANN",
                        "type": "File?"
                    },
                    "csvstats_file": {
                        "doc": "CSV summary file.",
                        "label": "CSV summary file",
                        "outputBinding": {
                            "glob": "*.csv"
                        },
                        "sbg:fileTypes": "CSV",
                        "type": "File?"
                    },
                    "summary": {
                        "doc": "SnpEff summary file in HTML or CSV file format.",
                        "label": "Summary file",
                        "outputBinding": {
                            "glob": "*.html",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.variants_file)\n\n}"
                        },
                        "sbg:fileTypes": "HTML, CSV",
                        "type": "File?"
                    },
                    "summary_text": {
                        "doc": "SnpEff Summary in text format.",
                        "label": "Summary",
                        "outputBinding": {
                            "glob": "*.txt",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.variants_file)\n\n}"
                        },
                        "sbg:fileTypes": "TXT",
                        "type": "File?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "aae3dcb89b53",
                        "dockerPull": "images.sbgenomics.com/vladimirk/snpeff:4.2"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.total_memory) {\n        return inputs.total_memory * 1024\n    } else {\n        return 8192\n    }\n}"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": [
                            "$(inputs.interval)",
                            "$(inputs.configuration_file)"
                        ]
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "Annotation",
                    "VCF-Processing"
                ],
                "sbg:cmdPreview": "unzip -o /path/to/database/GRCh37.75.zip -d /opt/snpEff ; java -Xmx3072M -jar /opt/snpEff/snpEff.jar  -nodownload  -noLog  assembly-string-value  path/to/variants.vcf  > variants.snpEff_annotated.vcf",
                "sbg:contributors": [
                    "jrandjelovic",
                    "vladimirk"
                ],
                "sbg:createdBy": "vladimirk",
                "sbg:id": "admin/sbg-public-data/snpeff-4-2/51",
                "sbg:image_url": null,
                "sbg:latestRevision": 38,
                "sbg:license": "GNU Lesser General Public License v3.0 only",
                "sbg:links": [
                    {
                        "id": "http://snpeff.sourceforge.net/index.html",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://github.com/pcingola/SnpEff",
                        "label": "Source Code"
                    },
                    {
                        "id": "http://snpeff.sourceforge.net/SnpEff_manual.html",
                        "label": "Wiki"
                    },
                    {
                        "id": "http://sourceforge.net/projects/snpeff/files/snpEff_latest_core.zip",
                        "label": "Download"
                    },
                    {
                        "id": "http://snpeff.sourceforge.net/SnpEff_paper.pdf",
                        "label": "Publication"
                    }
                ],
                "sbg:project": "vladimirk/snpeff-4-2-demo",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "updated description",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Pablo Cingolani/Broad Institue",
                "sbg:toolkit": "SnpEff",
                "sbg:toolkitVersion": "4.2",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 3091.2505723833606,
            "sbg:y": 304.61225467251097
        },
        {
            "id": "SBG_FASTQ_Quality_Adjuster",
            "in": [
                {
                    "id": "used_quality_scale"
                },
                {
                    "id": "total_memory"
                },
                {
                    "id": "fastq",
                    "source": [
                        "fastq"
                    ]
                }
            ],
            "out": [
                {
                    "id": "result"
                }
            ],
            "run": {
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "${\n    qscale = \"to be detected\"\n\n    if (inputs.fastq.metadata)\n        if (inputs.fastq.metadata[\"quality_scale\"])\n            qscale = inputs.fastq.metadata[\"quality_scale\"]\n\n    if (inputs.used_quality_scale)\n        if (inputs.used_quality_scale != null)\n            qscale = inputs.used_quality_scale\n\n\n    if (qscale == \"sanger\" || qscale == \"illumina18\") { // no conversion\n        return \"echo No conversion\"\n    } else {\n        return \"python sbg_fastq_quality_scale_adjuster.py\"\n    }\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "This app detects quality score format used in input FASTQ file. FASTQ quality score is then converted to standard Sanger quality score if conversion is required. It is basically a compact merged version of \"SBG Fastq Quality Detector\" and \"SBG Fastq Quality Converter\", created to speed up the execution of pipelines. Supported source formats are: Solexa, Illumina 1.3, Illumina 1.5 and Illumina 1.8.",
                "hints": [],
                "id": "bix-demo/sbgtools-demo/sbg-fastq-quality-adjuster/15",
                "inputs": {
                    "fastq": {
                        "doc": "Input FASTQ file.",
                        "inputBinding": {
                            "position": 2,
                            "separate": true,
                            "shellQuote": false,
                            "valueFrom": "${\n    qscale = \"to be detected\"\n\n    if (inputs.fastq.metadata)\n        if (inputs.fastq.metadata[\"quality_scale\"])\n            qscale = inputs.fastq.metadata[\"quality_scale\"]\n\n    if (inputs.used_quality_scale)\n        if (inputs.used_quality_scale != null)\n            qscale = inputs.used_quality_scale\n\n\n    if (qscale == \"sanger\" || qscale == \"illumina18\") {\n        return \"\"\n    } else {\n        return \"--fastq \" + inputs.fastq.path\n    }\n}"
                        },
                        "label": "Fastq file",
                        "sbg:category": "Input",
                        "sbg:fileTypes": "FASTQ,FASTQ.GZ,FQ,FQ.GZ",
                        "type": "File"
                    },
                    "total_memory": {
                        "doc": "Total memory in GB.",
                        "label": "Total memory [GB]",
                        "sbg:category": "Execution",
                        "sbg:toolDefaultValue": "1",
                        "type": "int?"
                    },
                    "used_quality_scale": {
                        "doc": "Used quality scale of FASTQ reads.",
                        "label": "Used quality scale",
                        "sbg:category": "Input",
                        "type": [
                            "null",
                            {
                                "name": "used_quality_scale",
                                "symbols": [
                                    "sanger",
                                    "illumina18",
                                    "illumina13",
                                    "illumina15",
                                    "solexa"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "SBG FASTQ Quality Adjuster",
                "outputs": {
                    "result": {
                        "doc": "Resulting file in FASTQ format.",
                        "label": "Result",
                        "outputBinding": {
                            "glob": "${\n\n    qscale = \"to be detected\"\n\n    if (inputs.fastq.metadata)\n        if (inputs.fastq.metadata[\"quality_scale\"])\n            qscale = inputs.fastq.metadata[\"quality_scale\"]\n\n    if (inputs.used_quality_scale)\n        if (inputs.used_quality_scale != null)\n            qscale = inputs.used_quality_scale\n\n\n    if (qscale == \"sanger\" || qscale == \"illumina18\") {\n        return inputs.fastq.path.replace(/^.*[\\\\\\/]/, '')\n    } else {\n        file = inputs.fastq.path\n        file_split = file.split('.')\n        basename = file_split\n        if (basename.length > 1) {\n            l_ext = basename.splice(basename.length - 1)\n            if (l_ext == 'gz') {\n                basename = basename.slice(0, basename.length - 1)\n            }\n        }\n        retval = basename.concat('std.fastq')\n        return retval.join('.').replace(/^.*[\\\\\\/]/, '') + \"*\"\n    }\n}",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.fastq)\n\n}"
                        },
                        "sbg:fileTypes": "FASTQ",
                        "type": "File?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.total_memory) {\n        return inputs.total_memory * 1024\n    } else {\n        return 1000\n    }\n}"
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "",
                        "dockerPull": "images.sbgenomics.com/bogdang/sbg_quality_scale_adjuster:1.0"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": [
                            {
                                "entry": "\"\"\"\nUsage:\n    sbg_fastq_quality_scale_adjuster.py --fastq FILE\n\nOptions:\n    -h, --help          Show this message.\n\n    -f, --fastq FILE    Input FASTQ file.\n\n\"\"\"\n\nfrom docopt import docopt\nimport os\nimport gzip\nimport itertools as it\nimport shutil\nimport sys\nfrom math import log10\nfrom subprocess import Popen\n\n\n\nargs = docopt(__doc__, version='1.0')\n\ninput_file = args['--fastq'] \n\nbase_name = input_file[input_file.rfind('/')+1:input_file.rfind('.') if input_file.rfind('.') != -1 else None]\nr_ext = input_file[input_file.rfind('.')+1:] if input_file.rfind('.') else \"\"\nl_ext = base_name.split('.')[-1].lower()\nif l_ext == 'fastq' or l_ext == 'fq':\n    if not r_ext == 'fastq' and not r_ext == 'fq':\n        base_name = base_name[:base_name.rfind('.')]\noutput_file = base_name + '.std.fastq'\n\n\n\"\"\"input and output names defined above\"\"\"\n\nclass myGzipFile(gzip.GzipFile):\n    def __enter__(self, *args, **kwargs):\n        if self.fileobj is None:\n            raise ValueError(\"I/O operation on closed GzipFile object\")\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        self.close()\n\n\ndef extremes(a, b):\n    if a is False:\n        return b, b\n    return min(a[0], b), max(a[1], b)\n\n\ndef walk_qualities(f, sample_size=1000):\n    for i in xrange(sample_size * 4):\n        try:\n            line = f.next()\n        except StopIteration:\n            return\n        if i % 4 == 3:\n            yield line.rstrip(\"\\n\\r\")\n\n\ndef sniff(path):\n    with open(path, 'rb') as f:\n        gz = f.read(2) == '\\x1f\\x8b'\n    opn = myGzipFile if gz else open\n    with opn(path) as f:\n        return get_scale(*map(ord, reduce(extremes, it.chain(*walk_qualities(f)), False)))\n\n\ndef get_scale(ord_min, ord_max):\n    options = {\n        'illumina13': (64, 105),\n        'illumina15': (66, 105),\n        'sanger': (33, 126),\n        'solexa': (59, 105),\n    }\n    fits = [(k, v) for k, v in options.iteritems() if v[0] <= ord_min and v[1] >= ord_max]\n    if not fits:\n        message = 'Quality scale for range (%s, %s) not found.' % (ord_min, ord_max)\n        raise Exception(message)\n        # Return narrowest range\n    return reduce(lambda a, b: a if a[1][1] - a[1][0] < b[1][1] - b[1][0] else b, fits)[0]\n\ndef qsolexa(x):\n    return chr(int(round(10 * log10(10.0**((ord(x)-64)/10.0)+1))) + 33)\n\n\ndef qillumina13(x):\n    return chr(ord(x) - 31)\n\n\ndef qillumina15(x):\n    return chr(ord(x) - 31) if ord(x)-64 > 2 else chr(33)\n\n\ndef qillumina18(x):\n    return x\n\n\n\"\"\"detect quality scale format\"\"\"\n\nmeta_qual = sniff(input_file)\n\n\n\"\"\"adjust quality scale if needed\"\"\"\n\nif meta_qual == 'illumina13':\n    proc = qillumina13\nelif meta_qual == 'illumina15':\n    proc = qillumina15\nelif meta_qual == 'solexa':\n    proc = qsolexa\nelse:\n    proc = None\n\nif proc == qsolexa: \n    with open(input_file, 'rb') as f:\n        gz = f.read(2) == '\\x1f\\x8b'\n    open_gz = myGzipFile if gz else open\n    with open(output_file, 'w') as out:\n        for i, line in enumerate(open_gz(input_file)):\n            if i % 4 == 3:\n                line = line.strip()\n                converted = ''.join(map(proc, line))\n                out.write(converted + '\\n')\n            else:\n                out.write(line)\n    contents = \"Original fastq quality scale format was \" + meta_qual + \", and is converted to illumina18.\\n\"\nelif proc is not None: #seqtk converter from illumina13-15\n    with open(input_file, 'rb') as f:\n        gz = f.read(2) == '\\x1f\\x8b'\n    f.close()\n    if gz:#gunzip file to temp.fastq\n        temp_file = 'temp.fastq'\n        \n        inF = gzip.GzipFile(input_file, 'rb')\n        outF = file(temp_file, 'wb')\n        \n        newline = ''\n        for lines in inF:\n            outF.write(newline + lines.rstrip('\\n'))\n            newline = '\\n'\n            \n        inF.close()\n        outF.close()\n\n    else:\n        temp_file = input_file\n\n    cmd = ['seqtk','seq','-Q64','-V',temp_file,'>',output_file]\n    with open(output_file, 'w') as out:\n        p = Popen(cmd, stdout = out)\n        p.communicate()\n    contents = \"Original fastq quality scale format was \" + meta_qual + \", and is converted to illumina18.\\n\"\nelse:\n    if input_file.rfind(\".gz\") == len(input_file) - 3:\n        output_file = output_file + \".gz\"\n    #shutil.copyfile(input_file, output_file)\n    #os.symlink(input_file, output_file)\n    os.rename(input_file, output_file)\n    contents = \"Original fastq quality scale format was illumina18. No conversion performed.\\n\"\n\nsys.stderr.write(contents) #Write conversion to error log",
                                "entryname": "sbg_fastq_quality_scale_adjuster.py"
                            },
                            "$(inputs.fastq)"
                        ]
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "Converters",
                    "FASTQ-Processing"
                ],
                "sbg:cmdPreview": "python sbg_fastq_quality_scale_adjuster.py  --fastq /path/to/test.1.fastq",
                "sbg:contributors": [
                    "vladimirk",
                    "bogdang"
                ],
                "sbg:createdBy": "vladimirk",
                "sbg:id": "admin/sbg-public-data/sbg-fastq-quality-adjuster/15",
                "sbg:image_url": null,
                "sbg:latestRevision": 15,
                "sbg:license": "Apache License 2.0",
                "sbg:project": "bix-demo/sbgtools-demo",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "No change",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Seven Bridges Genomics",
                "sbg:toolkit": "SBGTools",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 41.66666196452224,
            "sbg:y": 213.33336724175462,
            "scatter": "fastq"
        },
        {
            "id": "GATK_CollectHsMetrics",
            "in": [
                {
                    "id": "verbosity"
                },
                {
                    "id": "validation_stringency"
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "target_intervals",
                    "source": [
                        "GATK_BedToIntervalList/output"
                    ]
                },
                {
                    "id": "sample_size"
                },
                {
                    "id": "reference_sequence",
                    "source": [
                        "SBG_FASTA_Indices/fasta_reference"
                    ]
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "per_target_coverage"
                },
                {
                    "id": "per_base_coverage"
                },
                {
                    "id": "near_distance"
                },
                {
                    "id": "minimum_mapping_quality"
                },
                {
                    "id": "minimum_base_quality"
                },
                {
                    "id": "metric_accumulation_level"
                },
                {
                    "default": 4096,
                    "id": "memory_per_job"
                },
                {
                    "id": "memory_overhead_per_job"
                },
                {
                    "id": "max_records_in_ram"
                },
                {
                    "id": "input",
                    "source": [
                        "Sambamba_Merge/merged_bam"
                    ]
                },
                {
                    "id": "ga4_gh_client_secrets"
                },
                {
                    "id": "create_md5_file"
                },
                {
                    "id": "create_index"
                },
                {
                    "id": "coverage_cap"
                },
                {
                    "id": "compression_level"
                },
                {
                    "id": "clip_overlapping_reads"
                },
                {
                    "id": "bait_set_name"
                },
                {
                    "id": "bait_intervals",
                    "source": [
                        "GATK_BedToIntervalList/output"
                    ]
                }
            ],
            "out": [
                {
                    "id": "output"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "CollectHsMetrics"
                    },
                    {
                        "position": 4,
                        "prefix": "--OUTPUT",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    read_name = [].concat(inputs.input)[0].path.replace(/^.*[\\\\\\/]/, '').split('.')\n    read_namebase = read_name.slice(0, read_name.length - 1).join('.')\n    return read_namebase + '.txt'\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Collects hybrid-selection (HS) metrics for a SAM or BAM file.\n\n###**Overview**  \n\nCollects hybrid-selection (HS) metrics for a SAM or BAM file.  This tool takes a SAM/BAM file input and collects metrics that are specific for sequence datasets generated through hybrid-selection. Hybrid-selection (HS) is the most commonly used technique to capture exon-specific sequences for targeted sequencing experiments such as exome sequencing; for more information, please see the corresponding [GATK Dictionary entry](http://www.broadinstitute.org/gatk/guide/article?id=6331).\n\nThis tool requires an aligned SAM or BAM file as well as bait and target interval files in Picard interval list format. You should use the bait and interval files that correspond to the capture kit that was used to generate the capture libraries for sequencing, which can generally be obtained from the kit manufacturer. If the baits and target intervals are provided in BED format, you can convert them to the Picard interval list format using Picard's [BedToInterval tool](http://broadinstitute.github.io/picard/command-line-overview.html#BedToIntervalList). If a reference sequence is provided, this program will calculate both AT_DROPOUT and GC_DROPOUT metrics. Dropout metrics are an attempt to measure the reduced representation of reads, in regions that deviate from 50% G/C content. This reduction in the number of aligned reads is due to the increased numbers of errors associated with sequencing regions with excessive or deficient numbers of G/C bases, ultimately leading to poor mapping efficiencies and lowcoverage in the affected regions. If you are interested in getting G/C content and mean sequence depth information for every target interval, use the PER_TARGET_COVERAGE option.\n\nNote: Metrics labeled as percentages are actually expressed as fractions!\n\nPlease see [CollectHsMetrics](http://broadinstitute.github.io/picard/picard-metric-definitions.html#HsMetrics) for detailed descriptions of the output metrics produced by this tool.\n\n###**Input**  \n\nAn aligned SAM or BAM file.\nAn interval list file that contains the locations of the baits used.\n\n###**Output**  \n\nA metrics file.\n\n###**Usage examples**   \n\n    ./gatk-launch CollectHsMetrics \\\n     \t -I=input.bam \\\n     \t -O=hs_metrics.txt \\\n     \t -R=reference_sequence.fasta \\\n     \t -BAIT_INTERVALS=bait.interval_list \\\n     \t -TARGET_INTERVALS=target.interval_list\n\n###**IMPORTANT NOTICE**  \n\nTools in GATK that require a fasta reference file also look for the reference file's corresponding *.fai* (fasta index) and *.dict* (fasta dictionary) files. The fasta index file allows random access to reference bases and the dictionary file is a dictionary of the contig names and sizes contained within the fasta reference. These two secondary files are essential for GATK to work properly. To append these two files to your fasta reference please use the '***SBG FASTA Indices***' tool within your GATK based workflow before using any of the GATK tools.",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-collecthsmetrics/8",
                "inputs": {
                    "bait_intervals": {
                        "doc": "An interval list file that contains the locations of the baits used. This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--BAIT_INTERVALS",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Bait Intervals",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "sbg:fileTypes": "INTERVAL_LIST",
                        "type": "File"
                    },
                    "bait_set_name": {
                        "doc": "Bait set name. If not provided it is inferred from the filename of the bait intervals. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--BAIT_SET_NAME",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Bait Set Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "null",
                        "type": "string?"
                    },
                    "clip_overlapping_reads": {
                        "doc": "True if we are to clip overlapping reads, false otherwise. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--CLIP_OVERLAPPING_READS",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Clip Overlapping Reads",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "true",
                        "type": "boolean?"
                    },
                    "compression_level": {
                        "doc": "Compression level for all compressed files created (e.g. BAM and GELI). Default value: 5.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--COMPRESSION_LEVEL",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Compression Level",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "5",
                        "type": "int?"
                    },
                    "coverage_cap": {
                        "doc": "To set a max coverage limit for Theoretical Sensitivity calculations. Default is 200. Default value: 200.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--COVERAGE_CAP",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Coverage Cap",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "200",
                        "type": "int?"
                    },
                    "create_index": {
                        "doc": "Whether to create a BAM index when writing a coordinate-sorted BAM file. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--CREATE_INDEX",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "create_md5_file": {
                        "doc": "Whether to create an MD5 digest for any BAM or FASTQ files created. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--CREATE_MD5_FILE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Md5 File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "ga4_gh_client_secrets": {
                        "doc": "Google Genomics API client_secrets.json file path. Default value: client_secrets.json.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--GA4GH_CLIENT_SECRETS",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ga4 Gh Client Secrets",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "client_secrets",
                        "type": "string?"
                    },
                    "input": {
                        "doc": "An aligned SAM or BAM file. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--INPUT",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Input",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "sbg:fileTypes": "BAM",
                        "secondaryFiles": [
                            ".bai"
                        ],
                        "type": "File"
                    },
                    "max_records_in_ram": {
                        "doc": "When writing SAM files that need to be sorted, this will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort a SAM file, and increases the amount of RAM needed. Default value: 500000.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--MAX_RECORDS_IN_RAM",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Records In Ram",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "500000",
                        "type": "int?"
                    },
                    "memory_overhead_per_job": {
                        "doc": "Memory Overhead Per Job",
                        "label": "Memory Overhead Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "doc": "Memory Per Job",
                        "label": "Memory Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "metric_accumulation_level": {
                        "doc": "The level(s) at which to accumulate metrics. This argument may be specified 0 or more times. Default value: [ALL_READS]. Possible values: {ALL_READS, SAMPLE, LIBRARY, READ_GROUP}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--METRIC_ACCUMULATION_LEVEL",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Metric Accumulation Level",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "[ALL_READS]",
                        "type": [
                            "null",
                            {
                                "name": "metric_accumulation_level",
                                "symbols": [
                                    "ALL_READS",
                                    "SAMPLE",
                                    "LIBRARY",
                                    "READ_GROUP"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "minimum_base_quality": {
                        "doc": "Minimum base quality for a base to contribute coverage. Default value: 20.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--MINIMUM_BASE_QUALITY",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Minimum Base Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "20",
                        "type": "int?"
                    },
                    "minimum_mapping_quality": {
                        "doc": "Minimum mapping quality for a read to contribute coverage. Default value: 20.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--MINIMUM_MAPPING_QUALITY",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Minimum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "20",
                        "type": "int?"
                    },
                    "near_distance": {
                        "doc": "The maximum distance between a read and the nearest probe/bait/amplicon for the read to be considered 'near probe' and included in percent selected. Default value: 250.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--NEAR_DISTANCE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Near Distance",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "250",
                        "type": "int?"
                    },
                    "per_base_coverage": {
                        "doc": "An optional file to output per base coverage information to. The per-base file contains one line per target base and can grow very large. It is not recommended for use with large target sets. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--PER_BASE_COVERAGE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Per Base Coverage",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "null",
                        "type": "File?"
                    },
                    "per_target_coverage": {
                        "doc": "An optional file to output per target coverage information to. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--PER_TARGET_COVERAGE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Per Target Coverage",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "null",
                        "type": "File?"
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--QUIET",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "reference_sequence": {
                        "doc": "Reference sequence file. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--REFERENCE_SEQUENCE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reference Sequence",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "FASTA, FA",
                        "secondaryFiles": [
                            ".fai",
                            "^.dict"
                        ],
                        "type": "File?"
                    },
                    "sample_size": {
                        "doc": "Sample Size used for Theoretical Het Sensitivity sampling. Default is 10000. Default value: 10000.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--SAMPLE_SIZE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample Size",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "10000",
                        "type": "int?"
                    },
                    "target_intervals": {
                        "doc": "An interval list file that contains the locations of the targets. This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--TARGET_INTERVALS",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Target Intervals",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "sbg:fileTypes": "INTERVAL_LIST",
                        "type": "File"
                    },
                    "use_jdk_deflater": {
                        "doc": "Use the JDK Deflater instead of the Intel Deflater for writing compressed output Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--USE_JDK_DEFLATER",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Use the JDK Inflater instead of the Intel Inflater for reading compressed input Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--USE_JDK_INFLATER",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "validation_stringency": {
                        "doc": "Validation stringency for all SAM files read by this program. Setting stringency to SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: STRICT. Possible values: {STRICT, LENIENT, SILENT}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--VALIDATION_STRINGENCY",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Validation Stringency",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "STRICT",
                        "type": [
                            "null",
                            {
                                "name": "validation_stringency",
                                "symbols": [
                                    "STRICT",
                                    "LENIENT",
                                    "SILENT"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--VERBOSITY",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "INFO",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "GATK CollectHsMetrics",
                "outputs": {
                    "output": {
                        "doc": "Hybrid-selection (HS) metrics file.",
                        "label": "Output metrics",
                        "outputBinding": {
                            "glob": "*.txt"
                        },
                        "sbg:fileTypes": "TXT",
                        "type": "File?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        if (inputs.memory_overhead_per_job) {\n            return inputs.memory_per_job + inputs.memory_overhead_per_job\n        } else\n            return inputs.memory_per_job\n    } else if (!inputs.memory_per_job && inputs.memory_overhead_per_job) {\n        return 2048 + inputs.memory_overhead_per_job\n    } else\n        return 2048\n}"
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": []
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk --java-options \"-Xmx3M\" CollectHsMetrics --BAIT_INTERVALS /path/to/bait.ext --INPUT /path/to/input.ext --TARGET_INTERVALS /path/to/target.ext --OUTPUT input.txt",
                "sbg:contributors": [
                    "teodora.aleksic"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-collecthsmetrics/17",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-collecthsmetrics/8",
                "sbg:image_url": null,
                "sbg:latestRevision": 8,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-collecthsmetrics/17",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "sbg:wrapperAuthor": "teodora.aleksic",
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 1256.6667480468755,
            "sbg:y": -845.9739379882814
        },
        {
            "id": "GATK_BedToIntervalList",
            "in": [
                {
                    "id": "verbosity"
                },
                {
                    "id": "validation_stringency"
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "unique"
                },
                {
                    "id": "sort"
                },
                {
                    "id": "reference_sequence",
                    "source": [
                        "SBG_FASTA_Indices/fasta_reference"
                    ]
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "max_records_in_ram"
                },
                {
                    "id": "input",
                    "source": [
                        "intervals_file"
                    ]
                },
                {
                    "id": "ga4_gh_client_secrets"
                },
                {
                    "id": "create_md5_file"
                },
                {
                    "id": "create_index"
                },
                {
                    "id": "compression_level"
                }
            ],
            "out": [
                {
                    "id": "output"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "BedToIntervalList"
                    },
                    {
                        "position": 4,
                        "prefix": "--OUTPUT",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    read_name = [].concat(inputs.input)[0].path.replace(/^.*[\\\\\\/]/, '').split('.')\n    read_namebase = read_name.slice(0, read_name.length - 1).join('.')\n    return read_namebase + '.interval_list'\n}"
                    },
                    {
                        "position": 4,
                        "prefix": "--SEQUENCE_DICTIONARY",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    reference_path = inputs.reference_sequence.path\n    dict_path = reference_path.split('.').slice(0, -1).join('.') + '.dict'\n    return dict_path\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Converts a BED file to a Picard Interval List.\n\n###**Overview**  \n\nThis tool provides easy conversion from BED to the Picard interval_list format which is required by many Picard processing tools. Note that the coordinate system of BED files is such that the first base or position in a sequence is numbered \"0\", while in interval list files it is numbered \"1\". BED files contain sequence data displayed in a flexible format that includes nine optional fields, in addition to three required fields within the annotation tracks. The required fields of a BED file include:\n\n- chrom - The name of the chromosome (e.g. chr20) or scaffold (e.g. scaffold10671)\n- chromStart - The starting position of the feature in the chromosome or scaffold. The first base in a chromosome is numbered \"0\"\n- chromEnd - The ending position of the feature in the chromosome or scaffold.  The chromEnd base is not included in the display of the feature. For example, the first 100 bases of a chromosome are defined as chromStart=0, chromEnd=100, and span the bases numbered 0-99\n\nIn each annotation track, the number of fields per line must be consistent throughout a data set. For additional information regarding BED files and the annotation field options, please see: [FAQformat](http://genome.ucsc.edu/FAQ/FAQformat.html#format1). Interval list files contain sequence data distributed into intervals. The interval list file format is relatively simple and reflects the SAM alignment format to a degree. A SAM style header must be present in the file that lists the sequence records against which the intervals are described. After the header, the file then contains records, one per line in plain text format with the following values tab-separated:\n\n- Sequence name (SN) - The name of the sequence in the file for identification purposes, can be chromosome number e.g. chr20\n- Start position - Interval start position (starts at +1)\n- End position - Interval end position (1-based, end inclusive)\n- Strand - Indicates +/- strand for the interval (either + or -)\n- Interval name - (Each interval should have a unique name)\n\nThis tool requires a sequence dictionary, provided with the SEQUENCE_DICTIONARY or SD argument. The value given to this argument can be any of the following:\n\n- A file with .dict extension generated using Picard's CreateSequenceDictionaryTool\n- A reference.fa or reference.fasta file with a reference.dict in the same directory\n- Another IntervalList with @SQ lines in the header from which to generate a dictionary\n- A VCF that contains #contig lines from which to generate a sequence dictionary\n- A SAM or BAM file with @SQ lines in the header from which to generate a dictionary\n\n###**Input**  \n\nThe input BED file.\nThe sequence dictionary, or BAM/VCF/IntervalList from which a dictionary can be extracted.\n\n###**Output**  \n\nThe output Picard Interval List.\n\n###**Usage examples**   \n\n    ./gatk-launch BedToIntervalList \\\n    \t-I=input.bed \\\n    \t-O=list.interval_list \\\n    \t-SD=reference_sequence.dict\n\n###**IMPORTANT NOTICE**  \n\nTools in GATK that require a fasta reference file also look for the reference file's corresponding *.fai* (fasta index) and *.dict* (fasta dictionary) files. The fasta index file allows random access to reference bases and the dictionary file is a dictionary of the contig names and sizes contained within the fasta reference. These two secondary files are essential for GATK to work properly. To append these two files to your fasta reference please use the '***SBG FASTA Indices***' tool within your GATK based workflow before using any of the GATK tools.",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-bedtointervallist/4",
                "inputs": {
                    "compression_level": {
                        "doc": "Compression level for all compressed files created (e.g. BAM and GELI). Default value: 5.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--COMPRESSION_LEVEL",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Compression Level",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "5",
                        "type": "int?"
                    },
                    "create_index": {
                        "doc": "Whether to create a BAM index when writing a coordinate-sorted BAM file. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--CREATE_INDEX",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "create_md5_file": {
                        "doc": "Whether to create an MD5 digest for any BAM or FASTQ files created. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--CREATE_MD5_FILE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Md5 File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "ga4_gh_client_secrets": {
                        "doc": "Google Genomics API client_secrets.json file path. Default value: client_secrets.json.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--GA4GH_CLIENT_SECRETS",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ga4 Gh Client Secrets",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "client_secrets",
                        "type": "string?"
                    },
                    "input": {
                        "doc": "The input BED file Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--INPUT",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Input",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "sbg:fileTypes": "BED",
                        "type": "File"
                    },
                    "max_records_in_ram": {
                        "doc": "When writing SAM files that need to be sorted, this will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort a SAM file, and increases the amount of RAM needed. Default value: 500000.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--MAX_RECORDS_IN_RAM",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Records In Ram",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "500000",
                        "type": "int?"
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--QUIET",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "reference_sequence": {
                        "doc": "Reference sequence file. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--REFERENCE_SEQUENCE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reference Sequence",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "FASTA, FA",
                        "sbg:toolDefaultValue": null,
                        "secondaryFiles": [
                            "^.dict"
                        ],
                        "type": "File"
                    },
                    "sort": {
                        "doc": "If true, sort the output interval list before writing it. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--SORT",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sort",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "true",
                        "type": "boolean?"
                    },
                    "unique": {
                        "doc": "If true, unique the output interval list by merging overlapping regions, before writing it (implies sort=true). Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--UNIQUE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Unique",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "use_jdk_deflater": {
                        "doc": "Use the JDK Deflater instead of the Intel Deflater for writing compressed output Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--USE_JDK_DEFLATER",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Use the JDK Inflater instead of the Intel Inflater for reading compressed input Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--USE_JDK_INFLATER",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "validation_stringency": {
                        "doc": "Validation stringency for all SAM files read by this program. Setting stringency to SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: STRICT. Possible values: {STRICT, LENIENT, SILENT}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--VALIDATION_STRINGENCY",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Validation Stringency",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "STRICT",
                        "type": [
                            "null",
                            {
                                "name": "validation_stringency",
                                "symbols": [
                                    "STRICT",
                                    "LENIENT",
                                    "SILENT"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--VERBOSITY",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "INFO",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "GATK BedToIntervalList",
                "outputs": {
                    "output": {
                        "doc": "The output Picard Interval List",
                        "label": "Interval List",
                        "outputBinding": {
                            "glob": "*.interval_list"
                        },
                        "sbg:fileTypes": "INTERVAL_LIST",
                        "type": "File?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        if (inputs.memory_overhead_per_job) {\n            return inputs.memory_per_job + inputs.memory_overhead_per_job\n        } else\n            return inputs.memory_per_job\n    } else if (!inputs.memory_per_job && inputs.memory_overhead_per_job) {\n        return 2048 + inputs.memory_overhead_per_job\n    } else\n        return 2048\n}"
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": []
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk --java-options \"-Xmx2048M\" BedToIntervalList --INPUT /path/to/input.bed --REFERENCE_SEQUENCE /path/to/reference.fa --OUTPUT input.interval_list --SEQUENCE_DICTIONARY /path/to/reference.dict",
                "sbg:contributors": [
                    "teodora.aleksic"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-bedtointervallist/10",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-bedtointervallist/4",
                "sbg:image_url": null,
                "sbg:latestRevision": 4,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-bedtointervallist/10",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "sbg:wrapperAuthor": "teodora.aleksic",
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 793.0001627604171,
            "sbg:y": -841.6406962076826
        },
        {
            "id": "SNP_GATK_VariantFiltration",
            "in": [
                {
                    "id": "verbosity"
                },
                {
                    "id": "variant",
                    "source": [
                        "SNP_GATK_SelectVariants/select_variants_vcf"
                    ]
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "split_filter_expressions"
                },
                {
                    "id": "set_filtered_gt_to_nocall"
                },
                {
                    "id": "seconds_between_progress_updates"
                },
                {
                    "id": "sample"
                },
                {
                    "id": "reference",
                    "source": [
                        "SBG_FASTA_Indices/fasta_reference"
                    ]
                },
                {
                    "id": "read_validation_stringency"
                },
                {
                    "id": "read_name"
                },
                {
                    "id": "read_index"
                },
                {
                    "id": "read_filter"
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "pl_filter_name"
                },
                {
                    "id": "missing_values_in_expressions_should_evaluate_as_failing"
                },
                {
                    "id": "minimum_mapping_quality"
                },
                {
                    "id": "min_read_length"
                },
                {
                    "default": 2048,
                    "id": "memory_per_job"
                },
                {
                    "id": "memory_overhead_per_job"
                },
                {
                    "id": "maximum_mapping_quality"
                },
                {
                    "id": "max_read_length"
                },
                {
                    "id": "max_fragment_length"
                },
                {
                    "id": "mask_name"
                },
                {
                    "id": "mask_extension"
                },
                {
                    "id": "mask"
                },
                {
                    "id": "library"
                },
                {
                    "id": "lenient"
                },
                {
                    "id": "keep_reverse"
                },
                {
                    "id": "keep_read_group"
                },
                {
                    "id": "invert_genotype_filter_expression"
                },
                {
                    "id": "invert_filter_expression"
                },
                {
                    "id": "invalidate_previous_filters"
                },
                {
                    "id": "intervals_string"
                },
                {
                    "id": "intervals_file"
                },
                {
                    "id": "interval_set_rule"
                },
                {
                    "id": "interval_padding"
                },
                {
                    "id": "interval_merging_rule"
                },
                {
                    "id": "interval_exclusion_padding"
                },
                {
                    "id": "input"
                },
                {
                    "id": "genotype_filter_name"
                },
                {
                    "id": "genotype_filter_expression"
                },
                {
                    "id": "gcs_max_retries"
                },
                {
                    "id": "filter_too_short"
                },
                {
                    "id": "filter_not_in_mask"
                },
                {
                    "default": "GATKBestPracticeSNPFilter",
                    "id": "filter_name"
                },
                {
                    "default": [
                        "QD < 2.0",
                        "MQ < 40.0",
                        "FS > 60.0",
                        "MQRankSum < -12.5",
                        "ReadPosRankSum < -8.0",
                        "SOR > 3.0"
                    ],
                    "id": "filter_expression"
                },
                {
                    "id": "exclude_intervals_string"
                },
                {
                    "id": "exclude_intervals_file"
                },
                {
                    "id": "dont_require_soft_clips_both_ends"
                },
                {
                    "id": "disable_tool_default_read_filters"
                },
                {
                    "id": "disable_sequence_dictionary_validation"
                },
                {
                    "id": "disable_read_filter"
                },
                {
                    "id": "disable_bam_index_caching"
                },
                {
                    "id": "create_output_variant_md5"
                },
                {
                    "id": "create_output_variant_index"
                },
                {
                    "id": "create_output_bam_md5"
                },
                {
                    "id": "create_output_bam_index"
                },
                {
                    "id": "cluster_window_size"
                },
                {
                    "id": "cluster_size"
                },
                {
                    "id": "cloud_prefetch_buffer"
                },
                {
                    "id": "cloud_index_prefetch_buffer"
                },
                {
                    "id": "black_listed_lanes"
                },
                {
                    "id": "black_list"
                },
                {
                    "id": "ambig_filter_frac"
                },
                {
                    "id": "ambig_filter_bases"
                },
                {
                    "id": "add_output_sam_program_record"
                }
            ],
            "out": [
                {
                    "id": "filtered_vcf"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "VariantFiltration"
                    },
                    {
                        "position": 5,
                        "prefix": "--output",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    read_name = [].concat(inputs.variant)[0].path.replace(/^.*[\\\\\\/]/, '').split('.')\n    read_namebase = read_name.slice(0, read_name.length - 1).join('.')\n    return read_namebase + '.vcf'\n}"
                    },
                    {
                        "position": 4,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    /** Extracts filter name from expression */\n    function getVariableName(filterExpression) {\n        var expressions = ['!=', '==', '>=', '<=', '>', '<']\n\n        for (var i = 0; i < expressions.length; i++) {\n            var indexOf = filterExpression.indexOf(expressions[i])\n\n            if (indexOf >= 0)\n                return filterExpression.slice(0, indexOf).trim()\n        }\n\n        return ''\n    }\n\n    /** Combines multiple filters into a new filter name */\n    function getFilterName(filterExpressions) {\n        var newFilterName = ''\n\n        for (var i = 0; i < filterExpressions.length; i++) {\n            var variableName = getVariableName(filterExpressions[i])\n\n            newFilterName = newFilterName ? (newFilterName + '-' + variableName) : variableName\n        }\n\n        return newFilterName\n    }\n\n    filterName = inputs.filter_name\n    filterExpressions = inputs.filter_expression\n    splitFilterExpressions = inputs.split_filter_expressions\n\n    // Adds filter expressions to the command line\n    if (filterExpressions && filterExpressions.length > 0) {\n        if (splitFilterExpressions) // Adds each expression as a separate filter\n        {\n            cmd = []\n\n            for (i = 0; i < filterExpressions.length; i++) {\n                var variableName = getVariableName(filterExpressions[i])\n\n                cmd.push('--filter-name')\n                cmd.push('\"' + variableName + '\"')\n                cmd.push('--filter-expression')\n                cmd.push('\"' + filterExpressions[i] + '\"')\n            }\n\n            return cmd.join(' ')\n        } else // Adds all expressions as a single filter\n        {\n            filterName = filterName ? filterName : getFilterName(filterExpressions)\n\n            var expressions = []\n\n            for (var i = 0; i < filterExpressions.length; i++) {\n                expressions.push(filterExpressions[i])\n\n                if (i < filterExpressions.length - 1)\n                    expressions.push('||')\n            }\n\n            expressions = expressions.join(' ').trim()\n            expressions = '\"' + expressions + '\"'\n\n            return (['--filter-name',\n                '\"' + filterName + '\"',\n                '--filter-expression',\n                expressions\n            ].join(' ').trim())\n        }\n    } else\n        return ''\n}"
                    },
                    {
                        "position": 4,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    /** Extracts filter name from expression */\n    function getVariableName(filterExpression) {\n        var expressions = ['!=', '==', '>=', '<=', '>', '<']\n\n        for (var i = 0; i < expressions.length; i++) {\n            var indexOf = filterExpression.indexOf(expressions[i])\n\n            if (indexOf >= 0)\n                return filterExpression.slice(0, indexOf).trim()\n        }\n\n        return ''\n    }\n\n    /** Combines multiple filters into a new filter name */\n    function getFilterName(filterExpressions) {\n        var newFilterName = ''\n\n        for (var i = 0; i < filterExpressions.length; i++) {\n            var variableName = getVariableName(filterExpressions[i])\n\n            newFilterName = newFilterName ? (newFilterName + '-' + variableName) : variableName\n        }\n\n        return newFilterName\n    }\n\n    filterName = inputs.genotype_filter_name\n    filterExpressions = inputs.genotype_filter_expression\n    splitFilterExpressions = inputs.split_filter_expressions\n\n    // Adds filter expressions to the command line\n    if (filterExpressions && filterExpressions.length > 0) {\n        if (splitFilterExpressions) // Adds each expression as a separate filter\n        {\n            cmd = []\n\n            for (i = 0; i < filterExpressions.length; i++) {\n                var variableName = getVariableName(filterExpressions[i])\n\n                cmd.push('--genotype-filter-name')\n                cmd.push('\"' + variableName + '\"')\n                cmd.push('--genotype-filter-expression')\n                cmd.push('\"' + filterExpressions[i] + '\"')\n            }\n\n            return cmd.join(' ')\n        } else // Adds all expressions as a single filter\n        {\n            filterName = filterName ? filterName : getFilterName(filterExpressions)\n\n            var expressions = []\n\n            for (var i = 0; i < filterExpressions.length; i++) {\n                expressions.push(filterExpressions[i])\n\n                if (i < filterExpressions.length - 1)\n                    expressions.push('||')\n            }\n\n            expressions = expressions.join(' ').trim()\n            expressions = '\"' + expressions + '\"'\n\n            return (['--genotype-filter-name',\n                '\"' + filterName + '\"',\n                '--genotype-filter-expression',\n                expressions\n            ].join(' ').trim())\n        }\n    } else\n        return ''\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Filter variant calls based on INFO and FORMAT annotations.\n\n###**Overview**  \n\nThis tool is designed for hard-filtering variant calls based on certain criteria. Records are hard-filtered by changing the value in the FILTER field to something other than PASS. Filtered records will be preserved in the output unless their removal is requested in the command line.\n\n###**Input**  \n\n- A VCF of variant calls to filter.\n- One or more filtering expressions and corresponding filter names.\n\n###**Output**  \n\nA filtered VCF in which passing variants are annotated as PASS and failing variants are annotated with the name(s) of the filter(s) they failed. \n\n###**Usage example**  \n\n    ./gatk-launch VariantFiltration \\\n   \t\t-R reference.fasta \\\n   \t\t-V input.vcf \\\n   \t\t-O output.vcf \\\n   \t\t--filterExpression \"AB < 0.2 || MQ0 > 50\" \\\n   \t\t--filterName \"my_filters\"\n\n###**Note** \n\nComposing filtering expressions can range from very simple to extremely complicated depending on what you're trying to do. Please see [this document](https://software.broadinstitute.org/gatk/documentation/article.php?id=1255) for more details on how to compose and use filtering expressions effectively.\n\n###**IMPORTANT NOTICE**  \n\nTools in GATK that require a fasta reference file also look for the reference file's corresponding *.fai* (fasta index) and *.dict* (fasta dictionary) files. The fasta index file allows random access to reference bases and the dictionary file is a dictionary of the contig names and sizes contained within the fasta reference. These two secondary files are essential for GATK to work properly. To append these two files to your fasta reference please use the '***SBG FASTA Indices***' tool within your GATK based workflow before using any of the GATK tools.",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-4-0-variantfiltration/21",
                "inputs": {
                    "add_output_sam_program_record": {
                        "doc": "If true, adds a PG tag to created SAM/BAM/CRAM files. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--add-output-sam-program-record",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Add Output Sam Program Record",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "ambig_filter_bases": {
                        "doc": "Threshold number of ambiguous bases. If null, uses threshold fraction; otherwise, overrides threshold fraction. Cannot be used in conjunction with argument(s) maxAmbiguousBaseFraction.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-bases",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Bases",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "ambig_filter_frac": {
                        "doc": "Threshold fraction of non-regular bases (e.g. N) above which to filter Default value: 0.05.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-frac",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Frac",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "float?"
                    },
                    "black_list": {
                        "doc": "This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--black-list",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Black List",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "black_listed_lanes": {
                        "doc": "Keep reads with platform units not on the list This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--black-listed-lanes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Black Listed Lanes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "cloud_index_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Defaults to cloudPrefetchBuffer if unset. Default value: -1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-index-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Index Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "cloud_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Default value: 40.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "cluster_size": {
                        "doc": "The number of SNPs which make up a cluster. Must be at least 2 Default value: 3.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cluster-size",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cluster Size",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "cluster_window_size": {
                        "doc": "The window size (in bases) in which to evaluate clustered SNPs Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cluster-window-size",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cluster Window Size",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "create_output_bam_index": {
                        "doc": "If true, create a BAM/CRAM index when writing a coordinate-sorted BAM/CRAM file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-bam-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Bam Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_bam_md5": {
                        "doc": "If true, create a MD5 digest for any BAM/SAM/CRAM file created Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-bam-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Bam Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_variant_index": {
                        "doc": "If true, create a VCF index when writing a coordinate-sorted VCF file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_variant_md5": {
                        "doc": "If true, create a a MD5 digest any VCF file created. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_bam_index_caching": {
                        "doc": "If true, don't cache bam indexes, this will reduce memory requirements but may harm performance if many intervals are specified. Caching is automatically disabled if there are no intervals specified. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-bam-index-caching",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Bam Index Caching",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_read_filter": {
                        "doc": "Read filters to be disabled before analysis This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Read Filter",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "disable_read_filter",
                                "symbols": [
                                    "GoodCigarReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "disable_sequence_dictionary_validation": {
                        "doc": "If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk! Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-sequence-dictionary-validation",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Sequence Dictionary Validation",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_tool_default_read_filters": {
                        "doc": "Disable all tool default read filters Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-tool-default-read-filters",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Tool Default Read Filters",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "dont_require_soft_clips_both_ends": {
                        "doc": "Allow a read to be filtered out based on having only 1 soft-clipped block. By default, both ends must have a soft-clipped block, setting this flag requires only 1 soft-clipped block. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--dont-require-soft-clips-both-ends",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Dont Require Soft Clips Both Ends",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "boolean?"
                    },
                    "exclude_intervals_file": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervals File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File?"
                    },
                    "exclude_intervals_string": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervals String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "filter_expression": {
                        "doc": "One or more expression used with INFO fields to filter This argument may be specified 0 or more times. Default value: null.",
                        "label": "Filter Expression",
                        "sbg:category": "Optional Arguments",
                        "type": "string[]?"
                    },
                    "filter_name": {
                        "doc": "This argument may be specified 0 or more times. Default value: null.",
                        "label": "Filter Name",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "filter_not_in_mask": {
                        "doc": "Filter records NOT in given input mask. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--filter-not-in-mask",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Filter Not In Mask",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "filter_too_short": {
                        "doc": "Value for which reads with less than this number of aligned bases is considered too short Default value: 30.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--filter-too-short",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Filter Too Short",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "gcs_max_retries": {
                        "doc": "If the GCS bucket channel errors out, how many times it will attempt to re-initiate the connection.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--gcs-max-retries",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Gcs Max Retries",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "20",
                        "type": "int?"
                    },
                    "genotype_filter_expression": {
                        "doc": "One or more expression used with FORMAT (sample/genotype-level) fields to filter (see documentation guide for more info) This argument may be specified 0 or more times.",
                        "label": "Genotype Filter Expression",
                        "sbg:category": "Optional Arguments",
                        "type": "string[]?"
                    },
                    "genotype_filter_name": {
                        "doc": "Names to use for the list of sample/genotype filters (must be a 1-to-1 mapping); this name is put in the FILTER field for variants that get filtered This argument may be specified 0 or more times.",
                        "label": "Genotype Filter Name",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "input": {
                        "doc": "BAM/SAM/CRAM file containing reads This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--input",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Input",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "BAM,SAM,CRAM",
                        "secondaryFiles": [
                            ".bai"
                        ],
                        "type": "File?"
                    },
                    "interval_exclusion_padding": {
                        "doc": "Amount of padding (in bp) to add to each interval you are excluding. Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-exclusion-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Exclusion Padding",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "interval_merging_rule": {
                        "doc": "Interval merging rule for abutting intervals.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-merging-rule",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Merging Rule",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "ALL",
                        "type": [
                            "null",
                            {
                                "name": "interval_merging_rule",
                                "symbols": [
                                    "ALL",
                                    "OVERLAPPING_ONLY"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "interval_padding": {
                        "doc": "Amount of padding (in bp) to add to each interval you are including. Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Padding",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "interval_set_rule": {
                        "doc": "Set merging approach to use for combining interval inputs Default value: UNION. Possible values: {UNION, INTERSECTION}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-set-rule",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Set Rule",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "interval_set_rule",
                                "symbols": [
                                    "UNION",
                                    "INTERSECTION"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "intervals_file": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Intervals File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File?"
                    },
                    "intervals_string": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Intervals String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "invalidate_previous_filters": {
                        "doc": "Remove previous filters applied to the VCF Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--invalidate-previous-filters",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Invalidate Previous Filters",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "invert_filter_expression": {
                        "doc": "Invert the selection criteria for --filterExpression Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--invert-filter-expression",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Invert Filter Expression",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "invert_genotype_filter_expression": {
                        "doc": "Invert the selection criteria for --genotypeFilterExpression Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--invert-genotype-filter-expression",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Invert Genotype Filter Expression",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "keep_read_group": {
                        "doc": "The name of the read group to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-read-group",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Read Group",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "keep_reverse": {
                        "doc": "Keep only reads on the reverse strand Required. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-reverse",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Reverse",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "boolean?"
                    },
                    "lenient": {
                        "doc": "Lenient processing of VCF files Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--lenient",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Lenient",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "library": {
                        "doc": "The name of the library to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--library",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Library",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "mask": {
                        "doc": "Input mask Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--mask",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mask",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "mask_extension": {
                        "doc": "How many bases beyond records from a provided 'mask' should variants be filtered Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--mask-extension",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mask Extension",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "mask_name": {
                        "doc": "The text to put in the FILTER field if a 'mask' is provided and overlaps with a variant call Default value: Mask.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--mask-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mask Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "max_fragment_length": {
                        "doc": "Keep only read pairs with fragment length at most equal to the given value Default value: 1000000.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-fragment-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Fragment Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "max_read_length": {
                        "doc": "Keep only reads with length at most equal to the specified value Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "maximum_mapping_quality": {
                        "doc": "Maximum mapping quality to keep (inclusive) Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--maximum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Maximum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "memory_overhead_per_job": {
                        "doc": "Memory overhead per job",
                        "label": "Memory Overhead Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "doc": "Memory per job",
                        "label": "Memory Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "min_read_length": {
                        "doc": "Keep only reads with length at least equal to the specified value Default value: 1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "minimum_mapping_quality": {
                        "doc": "Minimum mapping quality to keep (inclusive) Default value: 10.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--minimum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Minimum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "missing_values_in_expressions_should_evaluate_as_failing": {
                        "doc": "When evaluating the JEXL expressions, missing values should be considered failing the expression Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--missing-values-in-expressions-should-evaluate-as-failing",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Missing Values In Expressions Should Evaluate As Failing",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "pl_filter_name": {
                        "doc": "Keep reads with RG:PL attribute containing this string This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--pl-filter-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Pl Filter Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--quiet",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "read_filter": {
                        "doc": "Read filters to be applied before analysis This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Filter",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "read_filter",
                                "symbols": [
                                    "AlignmentAgreesWithHeaderReadFilter",
                                    "AllowAllReadsReadFilter",
                                    "AmbiguousBaseReadFilter",
                                    "CigarContainsNoNOperator",
                                    "FirstOfPairReadFilter",
                                    "FragmentLengthReadFilter",
                                    "GoodCigarReadFilter",
                                    "HasReadGroupReadFilter",
                                    "LibraryReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityNotZeroReadFilter",
                                    "MappingQualityReadFilter",
                                    "MatchingBasesAndQualsReadFilter",
                                    "MateDifferentStrandReadFilter",
                                    "MateOnSameContigOrNoMappedMateReadFilter",
                                    "MetricsReadFilter",
                                    "NonZeroFragmentLengthReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotOpticalDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "NotSupplementaryAlignmentReadFilter",
                                    "OverclippedReadFilter",
                                    "PairedReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "PlatformReadFilter",
                                    "PlatformUnitReadFilter",
                                    "PrimaryLineReadFilter",
                                    "ProperlyPairedReadFilter",
                                    "ReadGroupBlackListReadFilter",
                                    "ReadGroupReadFilter",
                                    "ReadLengthEqualsCigarLengthReadFilter",
                                    "ReadLengthReadFilter",
                                    "ReadNameReadFilter",
                                    "ReadStrandFilter",
                                    "SampleReadFilter",
                                    "SecondOfPairReadFilter",
                                    "SeqIsStoredReadFilter",
                                    "ValidAlignmentEndReadFilter",
                                    "ValidAlignmentStartReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "read_index": {
                        "doc": "Indices to use for the read inputs. If specified, an index must be provided for every read input and in the same order as the read inputs. If this argument is not specified, the path to the index for each input will be inferred automatically. This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "read_name": {
                        "doc": "Keep only reads with this read name Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "read_validation_stringency": {
                        "doc": "Validation stringency for all SAM/BAM/CRAM/SRA files read by this program. The default stringency value SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: SILENT. Possible values: {STRICT, LENIENT, SILENT}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-validation-stringency",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Validation Stringency",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "read_validation_stringency",
                                "symbols": [
                                    "STRICT",
                                    "LENIENT",
                                    "SILENT"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "reference": {
                        "doc": "Reference sequence Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--reference",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reference",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "FASTA,FA",
                        "sbg:toolDefaultValue": "FASTA,FA",
                        "secondaryFiles": [
                            ".fai",
                            "^.dict"
                        ],
                        "type": "File"
                    },
                    "sample": {
                        "doc": "The name of the sample(s) to keep, filtering out all others This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "seconds_between_progress_updates": {
                        "doc": "Output traversal statistics every time this many seconds elapse Default value: 10.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--seconds-between-progress-updates",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Seconds Between Progress Updates",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "set_filtered_gt_to_nocall": {
                        "doc": "Set filtered genotypes to no-call Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--set-filtered-gt-to-nocall",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Set Filtered Gt To Nocall",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "split_filter_expressions": {
                        "doc": "Split filter expressions into separate tool arguments",
                        "label": "Split Filter Expressions",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_deflater": {
                        "doc": "Whether to use the JdkDeflater (as opposed to IntelDeflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-deflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Whether to use the JdkInflater (as opposed to IntelInflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-inflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "variant": {
                        "doc": "A VCF file containing variants Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--variant",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Variant",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "sbg:fileTypes": "VCF,VCF.GZ",
                        "type": "File"
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--verbosity",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "SNP GATK VariantFiltration",
                "outputs": {
                    "filtered_vcf": {
                        "doc": "File to which variants should be written.",
                        "label": "Filtered VCF",
                        "outputBinding": {
                            "glob": "*.vcf",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.variant)\n\n}"
                        },
                        "sbg:fileTypes": "VCF",
                        "secondaryFiles": [
                            ".idx"
                        ],
                        "type": "File"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "3c3b8e0ed4e5",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        if (inputs.memory_overhead_per_job) {\n            return inputs.memory_per_job + inputs.memory_overhead_per_job\n        } else\n            return inputs.memory_per_job\n    } else if (!inputs.memory_per_job && inputs.memory_overhead_per_job) {\n        return 2048 + inputs.memory_overhead_per_job\n    } else\n        return 2048\n}"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": []
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk --java-options \"-Xmx2048M\" VariantFiltration --variant /path/to/variant.ext --reference /path/to/reference.ext  --filter-name \"qd,rank\" --filter-expression \"qd<2 || rank>10\"   --output variant.vcf",
                "sbg:contributors": [
                    "teodora.aleksic"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/GATK_VariantFiltration/56",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-4-0-variantfiltration/21",
                "sbg:image_url": null,
                "sbg:latestRevision": 21,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/GATK_VariantFiltration/56",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 2422.262809827153,
            "sbg:y": 156.54773437692265
        },
        {
            "id": "INDEL_GATK_VariantFiltration",
            "in": [
                {
                    "id": "verbosity"
                },
                {
                    "id": "variant",
                    "source": [
                        "INDEL_GATK_SelectVariants/select_variants_vcf"
                    ]
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "split_filter_expressions"
                },
                {
                    "id": "set_filtered_gt_to_nocall"
                },
                {
                    "id": "seconds_between_progress_updates"
                },
                {
                    "id": "sample"
                },
                {
                    "id": "reference",
                    "source": [
                        "SBG_FASTA_Indices/fasta_reference"
                    ]
                },
                {
                    "id": "read_validation_stringency"
                },
                {
                    "id": "read_name"
                },
                {
                    "id": "read_index"
                },
                {
                    "id": "read_filter"
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "pl_filter_name"
                },
                {
                    "id": "missing_values_in_expressions_should_evaluate_as_failing"
                },
                {
                    "id": "minimum_mapping_quality"
                },
                {
                    "id": "min_read_length"
                },
                {
                    "default": 2048,
                    "id": "memory_per_job"
                },
                {
                    "id": "memory_overhead_per_job"
                },
                {
                    "id": "maximum_mapping_quality"
                },
                {
                    "id": "max_read_length"
                },
                {
                    "id": "max_fragment_length"
                },
                {
                    "id": "mask_name"
                },
                {
                    "id": "mask_extension"
                },
                {
                    "id": "mask"
                },
                {
                    "id": "library"
                },
                {
                    "id": "lenient"
                },
                {
                    "id": "keep_reverse"
                },
                {
                    "id": "keep_read_group"
                },
                {
                    "id": "invert_genotype_filter_expression"
                },
                {
                    "id": "invert_filter_expression"
                },
                {
                    "id": "invalidate_previous_filters"
                },
                {
                    "id": "intervals_string"
                },
                {
                    "id": "intervals_file"
                },
                {
                    "id": "interval_set_rule"
                },
                {
                    "id": "interval_padding"
                },
                {
                    "id": "interval_merging_rule"
                },
                {
                    "id": "interval_exclusion_padding"
                },
                {
                    "id": "input"
                },
                {
                    "id": "genotype_filter_name"
                },
                {
                    "id": "genotype_filter_expression"
                },
                {
                    "id": "gcs_max_retries"
                },
                {
                    "id": "filter_too_short"
                },
                {
                    "id": "filter_not_in_mask"
                },
                {
                    "default": "GATKBestPracticeINDELFilter",
                    "id": "filter_name"
                },
                {
                    "default": [
                        "QD < 2.0",
                        "FS > 200.0",
                        "ReadPosRankSum < -20.0",
                        "SOR > 10.0"
                    ],
                    "id": "filter_expression"
                },
                {
                    "id": "exclude_intervals_string"
                },
                {
                    "id": "exclude_intervals_file"
                },
                {
                    "id": "dont_require_soft_clips_both_ends"
                },
                {
                    "id": "disable_tool_default_read_filters"
                },
                {
                    "id": "disable_sequence_dictionary_validation"
                },
                {
                    "id": "disable_read_filter"
                },
                {
                    "id": "disable_bam_index_caching"
                },
                {
                    "id": "create_output_variant_md5"
                },
                {
                    "id": "create_output_variant_index"
                },
                {
                    "id": "create_output_bam_md5"
                },
                {
                    "id": "create_output_bam_index"
                },
                {
                    "id": "cluster_window_size"
                },
                {
                    "id": "cluster_size"
                },
                {
                    "id": "cloud_prefetch_buffer"
                },
                {
                    "id": "cloud_index_prefetch_buffer"
                },
                {
                    "id": "black_listed_lanes"
                },
                {
                    "id": "black_list"
                },
                {
                    "id": "ambig_filter_frac"
                },
                {
                    "id": "ambig_filter_bases"
                },
                {
                    "id": "add_output_sam_program_record"
                }
            ],
            "out": [
                {
                    "id": "filtered_vcf"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "VariantFiltration"
                    },
                    {
                        "position": 5,
                        "prefix": "--output",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    read_name = [].concat(inputs.variant)[0].path.replace(/^.*[\\\\\\/]/, '').split('.')\n    read_namebase = read_name.slice(0, read_name.length - 1).join('.')\n    return read_namebase + '.vcf'\n}"
                    },
                    {
                        "position": 4,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    /** Extracts filter name from expression */\n    function getVariableName(filterExpression) {\n        var expressions = ['!=', '==', '>=', '<=', '>', '<']\n\n        for (var i = 0; i < expressions.length; i++) {\n            var indexOf = filterExpression.indexOf(expressions[i])\n\n            if (indexOf >= 0)\n                return filterExpression.slice(0, indexOf).trim()\n        }\n\n        return ''\n    }\n\n    /** Combines multiple filters into a new filter name */\n    function getFilterName(filterExpressions) {\n        var newFilterName = ''\n\n        for (var i = 0; i < filterExpressions.length; i++) {\n            var variableName = getVariableName(filterExpressions[i])\n\n            newFilterName = newFilterName ? (newFilterName + '-' + variableName) : variableName\n        }\n\n        return newFilterName\n    }\n\n    filterName = inputs.filter_name\n    filterExpressions = inputs.filter_expression\n    splitFilterExpressions = inputs.split_filter_expressions\n\n    // Adds filter expressions to the command line\n    if (filterExpressions && filterExpressions.length > 0) {\n        if (splitFilterExpressions) // Adds each expression as a separate filter\n        {\n            cmd = []\n\n            for (i = 0; i < filterExpressions.length; i++) {\n                var variableName = getVariableName(filterExpressions[i])\n\n                cmd.push('--filter-name')\n                cmd.push('\"' + variableName + '\"')\n                cmd.push('--filter-expression')\n                cmd.push('\"' + filterExpressions[i] + '\"')\n            }\n\n            return cmd.join(' ')\n        } else // Adds all expressions as a single filter\n        {\n            filterName = filterName ? filterName : getFilterName(filterExpressions)\n\n            var expressions = []\n\n            for (var i = 0; i < filterExpressions.length; i++) {\n                expressions.push(filterExpressions[i])\n\n                if (i < filterExpressions.length - 1)\n                    expressions.push('||')\n            }\n\n            expressions = expressions.join(' ').trim()\n            expressions = '\"' + expressions + '\"'\n\n            return (['--filter-name',\n                '\"' + filterName + '\"',\n                '--filter-expression',\n                expressions\n            ].join(' ').trim())\n        }\n    } else\n        return ''\n}"
                    },
                    {
                        "position": 4,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    /** Extracts filter name from expression */\n    function getVariableName(filterExpression) {\n        var expressions = ['!=', '==', '>=', '<=', '>', '<']\n\n        for (var i = 0; i < expressions.length; i++) {\n            var indexOf = filterExpression.indexOf(expressions[i])\n\n            if (indexOf >= 0)\n                return filterExpression.slice(0, indexOf).trim()\n        }\n\n        return ''\n    }\n\n    /** Combines multiple filters into a new filter name */\n    function getFilterName(filterExpressions) {\n        var newFilterName = ''\n\n        for (var i = 0; i < filterExpressions.length; i++) {\n            var variableName = getVariableName(filterExpressions[i])\n\n            newFilterName = newFilterName ? (newFilterName + '-' + variableName) : variableName\n        }\n\n        return newFilterName\n    }\n\n    filterName = inputs.genotype_filter_name\n    filterExpressions = inputs.genotype_filter_expression\n    splitFilterExpressions = inputs.split_filter_expressions\n\n    // Adds filter expressions to the command line\n    if (filterExpressions && filterExpressions.length > 0) {\n        if (splitFilterExpressions) // Adds each expression as a separate filter\n        {\n            cmd = []\n\n            for (i = 0; i < filterExpressions.length; i++) {\n                var variableName = getVariableName(filterExpressions[i])\n\n                cmd.push('--genotype-filter-name')\n                cmd.push('\"' + variableName + '\"')\n                cmd.push('--genotype-filter-expression')\n                cmd.push('\"' + filterExpressions[i] + '\"')\n            }\n\n            return cmd.join(' ')\n        } else // Adds all expressions as a single filter\n        {\n            filterName = filterName ? filterName : getFilterName(filterExpressions)\n\n            var expressions = []\n\n            for (var i = 0; i < filterExpressions.length; i++) {\n                expressions.push(filterExpressions[i])\n\n                if (i < filterExpressions.length - 1)\n                    expressions.push('||')\n            }\n\n            expressions = expressions.join(' ').trim()\n            expressions = '\"' + expressions + '\"'\n\n            return (['--genotype-filter-name',\n                '\"' + filterName + '\"',\n                '--genotype-filter-expression',\n                expressions\n            ].join(' ').trim())\n        }\n    } else\n        return ''\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Filter variant calls based on INFO and FORMAT annotations.\n\n###**Overview**  \n\nThis tool is designed for hard-filtering variant calls based on certain criteria. Records are hard-filtered by changing the value in the FILTER field to something other than PASS. Filtered records will be preserved in the output unless their removal is requested in the command line.\n\n###**Input**  \n\n- A VCF of variant calls to filter.\n- One or more filtering expressions and corresponding filter names.\n\n###**Output**  \n\nA filtered VCF in which passing variants are annotated as PASS and failing variants are annotated with the name(s) of the filter(s) they failed. \n\n###**Usage example**  \n\n    ./gatk-launch VariantFiltration \\\n   \t\t-R reference.fasta \\\n   \t\t-V input.vcf \\\n   \t\t-O output.vcf \\\n   \t\t--filterExpression \"AB < 0.2 || MQ0 > 50\" \\\n   \t\t--filterName \"my_filters\"\n\n###**Note** \n\nComposing filtering expressions can range from very simple to extremely complicated depending on what you're trying to do. Please see [this document](https://software.broadinstitute.org/gatk/documentation/article.php?id=1255) for more details on how to compose and use filtering expressions effectively.\n\n###**IMPORTANT NOTICE**  \n\nTools in GATK that require a fasta reference file also look for the reference file's corresponding *.fai* (fasta index) and *.dict* (fasta dictionary) files. The fasta index file allows random access to reference bases and the dictionary file is a dictionary of the contig names and sizes contained within the fasta reference. These two secondary files are essential for GATK to work properly. To append these two files to your fasta reference please use the '***SBG FASTA Indices***' tool within your GATK based workflow before using any of the GATK tools.",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-4-0-variantfiltration/21",
                "inputs": {
                    "add_output_sam_program_record": {
                        "doc": "If true, adds a PG tag to created SAM/BAM/CRAM files. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--add-output-sam-program-record",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Add Output Sam Program Record",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "ambig_filter_bases": {
                        "doc": "Threshold number of ambiguous bases. If null, uses threshold fraction; otherwise, overrides threshold fraction. Cannot be used in conjunction with argument(s) maxAmbiguousBaseFraction.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-bases",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Bases",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "ambig_filter_frac": {
                        "doc": "Threshold fraction of non-regular bases (e.g. N) above which to filter Default value: 0.05.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-frac",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Frac",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "float?"
                    },
                    "black_list": {
                        "doc": "This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--black-list",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Black List",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "black_listed_lanes": {
                        "doc": "Keep reads with platform units not on the list This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--black-listed-lanes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Black Listed Lanes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "cloud_index_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Defaults to cloudPrefetchBuffer if unset. Default value: -1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-index-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Index Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "cloud_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Default value: 40.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "cluster_size": {
                        "doc": "The number of SNPs which make up a cluster. Must be at least 2 Default value: 3.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cluster-size",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cluster Size",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "cluster_window_size": {
                        "doc": "The window size (in bases) in which to evaluate clustered SNPs Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cluster-window-size",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cluster Window Size",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "create_output_bam_index": {
                        "doc": "If true, create a BAM/CRAM index when writing a coordinate-sorted BAM/CRAM file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-bam-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Bam Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_bam_md5": {
                        "doc": "If true, create a MD5 digest for any BAM/SAM/CRAM file created Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-bam-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Bam Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_variant_index": {
                        "doc": "If true, create a VCF index when writing a coordinate-sorted VCF file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_variant_md5": {
                        "doc": "If true, create a a MD5 digest any VCF file created. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_bam_index_caching": {
                        "doc": "If true, don't cache bam indexes, this will reduce memory requirements but may harm performance if many intervals are specified. Caching is automatically disabled if there are no intervals specified. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-bam-index-caching",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Bam Index Caching",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_read_filter": {
                        "doc": "Read filters to be disabled before analysis This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Read Filter",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "disable_read_filter",
                                "symbols": [
                                    "GoodCigarReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "disable_sequence_dictionary_validation": {
                        "doc": "If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk! Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-sequence-dictionary-validation",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Sequence Dictionary Validation",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_tool_default_read_filters": {
                        "doc": "Disable all tool default read filters Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-tool-default-read-filters",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Tool Default Read Filters",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "dont_require_soft_clips_both_ends": {
                        "doc": "Allow a read to be filtered out based on having only 1 soft-clipped block. By default, both ends must have a soft-clipped block, setting this flag requires only 1 soft-clipped block. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--dont-require-soft-clips-both-ends",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Dont Require Soft Clips Both Ends",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "boolean?"
                    },
                    "exclude_intervals_file": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervals File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File?"
                    },
                    "exclude_intervals_string": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervals String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "filter_expression": {
                        "doc": "One or more expression used with INFO fields to filter This argument may be specified 0 or more times. Default value: null.",
                        "label": "Filter Expression",
                        "sbg:category": "Optional Arguments",
                        "type": "string[]?"
                    },
                    "filter_name": {
                        "doc": "This argument may be specified 0 or more times. Default value: null.",
                        "label": "Filter Name",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "filter_not_in_mask": {
                        "doc": "Filter records NOT in given input mask. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--filter-not-in-mask",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Filter Not In Mask",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "filter_too_short": {
                        "doc": "Value for which reads with less than this number of aligned bases is considered too short Default value: 30.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--filter-too-short",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Filter Too Short",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "gcs_max_retries": {
                        "doc": "If the GCS bucket channel errors out, how many times it will attempt to re-initiate the connection.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--gcs-max-retries",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Gcs Max Retries",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "20",
                        "type": "int?"
                    },
                    "genotype_filter_expression": {
                        "doc": "One or more expression used with FORMAT (sample/genotype-level) fields to filter (see documentation guide for more info) This argument may be specified 0 or more times.",
                        "label": "Genotype Filter Expression",
                        "sbg:category": "Optional Arguments",
                        "type": "string[]?"
                    },
                    "genotype_filter_name": {
                        "doc": "Names to use for the list of sample/genotype filters (must be a 1-to-1 mapping); this name is put in the FILTER field for variants that get filtered This argument may be specified 0 or more times.",
                        "label": "Genotype Filter Name",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "input": {
                        "doc": "BAM/SAM/CRAM file containing reads This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--input",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Input",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "BAM,SAM,CRAM",
                        "secondaryFiles": [
                            ".bai"
                        ],
                        "type": "File?"
                    },
                    "interval_exclusion_padding": {
                        "doc": "Amount of padding (in bp) to add to each interval you are excluding. Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-exclusion-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Exclusion Padding",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "interval_merging_rule": {
                        "doc": "Interval merging rule for abutting intervals.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-merging-rule",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Merging Rule",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "ALL",
                        "type": [
                            "null",
                            {
                                "name": "interval_merging_rule",
                                "symbols": [
                                    "ALL",
                                    "OVERLAPPING_ONLY"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "interval_padding": {
                        "doc": "Amount of padding (in bp) to add to each interval you are including. Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Padding",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "interval_set_rule": {
                        "doc": "Set merging approach to use for combining interval inputs Default value: UNION. Possible values: {UNION, INTERSECTION}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-set-rule",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Set Rule",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "interval_set_rule",
                                "symbols": [
                                    "UNION",
                                    "INTERSECTION"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "intervals_file": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Intervals File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File?"
                    },
                    "intervals_string": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Intervals String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "invalidate_previous_filters": {
                        "doc": "Remove previous filters applied to the VCF Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--invalidate-previous-filters",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Invalidate Previous Filters",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "invert_filter_expression": {
                        "doc": "Invert the selection criteria for --filterExpression Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--invert-filter-expression",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Invert Filter Expression",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "invert_genotype_filter_expression": {
                        "doc": "Invert the selection criteria for --genotypeFilterExpression Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--invert-genotype-filter-expression",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Invert Genotype Filter Expression",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "keep_read_group": {
                        "doc": "The name of the read group to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-read-group",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Read Group",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "keep_reverse": {
                        "doc": "Keep only reads on the reverse strand Required. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-reverse",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Reverse",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "boolean?"
                    },
                    "lenient": {
                        "doc": "Lenient processing of VCF files Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--lenient",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Lenient",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "library": {
                        "doc": "The name of the library to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--library",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Library",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "mask": {
                        "doc": "Input mask Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--mask",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mask",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "mask_extension": {
                        "doc": "How many bases beyond records from a provided 'mask' should variants be filtered Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--mask-extension",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mask Extension",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "mask_name": {
                        "doc": "The text to put in the FILTER field if a 'mask' is provided and overlaps with a variant call Default value: Mask.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--mask-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mask Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "max_fragment_length": {
                        "doc": "Keep only read pairs with fragment length at most equal to the given value Default value: 1000000.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-fragment-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Fragment Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "max_read_length": {
                        "doc": "Keep only reads with length at most equal to the specified value Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "maximum_mapping_quality": {
                        "doc": "Maximum mapping quality to keep (inclusive) Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--maximum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Maximum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "memory_overhead_per_job": {
                        "doc": "Memory overhead per job",
                        "label": "Memory Overhead Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "doc": "Memory per job",
                        "label": "Memory Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "min_read_length": {
                        "doc": "Keep only reads with length at least equal to the specified value Default value: 1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "minimum_mapping_quality": {
                        "doc": "Minimum mapping quality to keep (inclusive) Default value: 10.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--minimum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Minimum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "missing_values_in_expressions_should_evaluate_as_failing": {
                        "doc": "When evaluating the JEXL expressions, missing values should be considered failing the expression Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--missing-values-in-expressions-should-evaluate-as-failing",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Missing Values In Expressions Should Evaluate As Failing",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "pl_filter_name": {
                        "doc": "Keep reads with RG:PL attribute containing this string This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--pl-filter-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Pl Filter Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--quiet",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "read_filter": {
                        "doc": "Read filters to be applied before analysis This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Filter",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "read_filter",
                                "symbols": [
                                    "AlignmentAgreesWithHeaderReadFilter",
                                    "AllowAllReadsReadFilter",
                                    "AmbiguousBaseReadFilter",
                                    "CigarContainsNoNOperator",
                                    "FirstOfPairReadFilter",
                                    "FragmentLengthReadFilter",
                                    "GoodCigarReadFilter",
                                    "HasReadGroupReadFilter",
                                    "LibraryReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityNotZeroReadFilter",
                                    "MappingQualityReadFilter",
                                    "MatchingBasesAndQualsReadFilter",
                                    "MateDifferentStrandReadFilter",
                                    "MateOnSameContigOrNoMappedMateReadFilter",
                                    "MetricsReadFilter",
                                    "NonZeroFragmentLengthReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotOpticalDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "NotSupplementaryAlignmentReadFilter",
                                    "OverclippedReadFilter",
                                    "PairedReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "PlatformReadFilter",
                                    "PlatformUnitReadFilter",
                                    "PrimaryLineReadFilter",
                                    "ProperlyPairedReadFilter",
                                    "ReadGroupBlackListReadFilter",
                                    "ReadGroupReadFilter",
                                    "ReadLengthEqualsCigarLengthReadFilter",
                                    "ReadLengthReadFilter",
                                    "ReadNameReadFilter",
                                    "ReadStrandFilter",
                                    "SampleReadFilter",
                                    "SecondOfPairReadFilter",
                                    "SeqIsStoredReadFilter",
                                    "ValidAlignmentEndReadFilter",
                                    "ValidAlignmentStartReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "read_index": {
                        "doc": "Indices to use for the read inputs. If specified, an index must be provided for every read input and in the same order as the read inputs. If this argument is not specified, the path to the index for each input will be inferred automatically. This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "read_name": {
                        "doc": "Keep only reads with this read name Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "read_validation_stringency": {
                        "doc": "Validation stringency for all SAM/BAM/CRAM/SRA files read by this program. The default stringency value SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: SILENT. Possible values: {STRICT, LENIENT, SILENT}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-validation-stringency",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Validation Stringency",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "read_validation_stringency",
                                "symbols": [
                                    "STRICT",
                                    "LENIENT",
                                    "SILENT"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "reference": {
                        "doc": "Reference sequence Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--reference",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reference",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "FASTA,FA",
                        "sbg:toolDefaultValue": "FASTA,FA",
                        "secondaryFiles": [
                            ".fai",
                            "^.dict"
                        ],
                        "type": "File"
                    },
                    "sample": {
                        "doc": "The name of the sample(s) to keep, filtering out all others This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "seconds_between_progress_updates": {
                        "doc": "Output traversal statistics every time this many seconds elapse Default value: 10.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--seconds-between-progress-updates",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Seconds Between Progress Updates",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "set_filtered_gt_to_nocall": {
                        "doc": "Set filtered genotypes to no-call Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--set-filtered-gt-to-nocall",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Set Filtered Gt To Nocall",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "split_filter_expressions": {
                        "doc": "Split filter expressions into separate tool arguments",
                        "label": "Split Filter Expressions",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_deflater": {
                        "doc": "Whether to use the JdkDeflater (as opposed to IntelDeflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-deflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Whether to use the JdkInflater (as opposed to IntelInflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-inflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "variant": {
                        "doc": "A VCF file containing variants Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--variant",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Variant",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "sbg:fileTypes": "VCF,VCF.GZ",
                        "type": "File"
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--verbosity",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "INDEL GATK VariantFiltration",
                "outputs": {
                    "filtered_vcf": {
                        "doc": "File to which variants should be written.",
                        "label": "Filtered VCF",
                        "outputBinding": {
                            "glob": "*.vcf",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.variant)\n\n}"
                        },
                        "sbg:fileTypes": "VCF",
                        "secondaryFiles": [
                            ".idx"
                        ],
                        "type": "File"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "3c3b8e0ed4e5",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        if (inputs.memory_overhead_per_job) {\n            return inputs.memory_per_job + inputs.memory_overhead_per_job\n        } else\n            return inputs.memory_per_job\n    } else if (!inputs.memory_per_job && inputs.memory_overhead_per_job) {\n        return 2048 + inputs.memory_overhead_per_job\n    } else\n        return 2048\n}"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": []
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk --java-options \"-Xmx2048M\" VariantFiltration --variant /path/to/variant.ext --reference /path/to/reference.ext  --filter-name \"qd,rank\" --filter-expression \"qd<2 || rank>10\"   --output variant.vcf",
                "sbg:contributors": [
                    "teodora.aleksic"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/GATK_VariantFiltration/56",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-4-0-variantfiltration/21",
                "sbg:image_url": null,
                "sbg:latestRevision": 21,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/GATK_VariantFiltration/56",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 2429.1668445732903,
            "sbg:y": 334.58347887132453
        },
        {
            "id": "INDEL_GATK_SelectVariants",
            "in": [
                {
                    "id": "verbosity"
                },
                {
                    "id": "variant",
                    "source": [
                        "GATK_MergeVcfs/output"
                    ]
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "set_filtered_gt_to_nocall"
                },
                {
                    "default": "INDEL",
                    "id": "select_type_to_include"
                },
                {
                    "id": "select_type_to_exclude"
                },
                {
                    "id": "select_random_fraction"
                },
                {
                    "id": "select_expressions"
                },
                {
                    "id": "seconds_between_progress_updates"
                },
                {
                    "id": "sample_name"
                },
                {
                    "id": "sample_file"
                },
                {
                    "id": "sample_expressions"
                },
                {
                    "id": "sample"
                },
                {
                    "id": "restrict_alleles_to"
                },
                {
                    "id": "remove_unused_alternates"
                },
                {
                    "id": "remove_fraction_genotypes"
                },
                {
                    "id": "reference",
                    "source": [
                        "SBG_FASTA_Indices/fasta_reference"
                    ]
                },
                {
                    "id": "read_validation_stringency"
                },
                {
                    "id": "read_name"
                },
                {
                    "id": "read_index"
                },
                {
                    "id": "read_filter"
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "preserve_alleles"
                },
                {
                    "id": "pl_filter_name"
                },
                {
                    "id": "pedigree"
                },
                {
                    "id": "minimum_mapping_quality"
                },
                {
                    "id": "min_read_length"
                },
                {
                    "id": "min_indel_size"
                },
                {
                    "id": "min_fraction_filtered_genotypes"
                },
                {
                    "id": "min_filtered_genotypes"
                },
                {
                    "id": "mendelian_violation_qual_threshold"
                },
                {
                    "id": "mendelian_violation"
                },
                {
                    "default": 2048,
                    "id": "memory_per_job"
                },
                {
                    "id": "memory_overhead_per_job"
                },
                {
                    "id": "maximum_mapping_quality"
                },
                {
                    "id": "max_read_length"
                },
                {
                    "id": "max_nocal_lnumber"
                },
                {
                    "id": "max_nocal_lfraction"
                },
                {
                    "id": "max_indel_size"
                },
                {
                    "id": "max_fragment_length"
                },
                {
                    "id": "max_fraction_filtered_genotypes"
                },
                {
                    "id": "max_filtered_genotypes"
                },
                {
                    "id": "library"
                },
                {
                    "id": "lenient"
                },
                {
                    "id": "keep_reverse"
                },
                {
                    "id": "keep_read_group"
                },
                {
                    "id": "keep_original_dp"
                },
                {
                    "id": "keep_original_ac"
                },
                {
                    "id": "keep_ids"
                },
                {
                    "id": "invert_select"
                },
                {
                    "id": "invert_mendelian_violation"
                },
                {
                    "id": "intervals_string"
                },
                {
                    "id": "intervals_file"
                },
                {
                    "id": "interval_set_rule"
                },
                {
                    "id": "interval_padding"
                },
                {
                    "id": "interval_merging_rule"
                },
                {
                    "id": "interval_exclusion_padding"
                },
                {
                    "id": "input"
                },
                {
                    "id": "gcs_max_retries"
                },
                {
                    "id": "filter_too_short"
                },
                {
                    "id": "exclude_sample_name"
                },
                {
                    "id": "exclude_sample_file"
                },
                {
                    "id": "exclude_sample_expressions"
                },
                {
                    "id": "exclude_non_variants"
                },
                {
                    "id": "exclude_intervals_string"
                },
                {
                    "id": "exclude_intervals_file"
                },
                {
                    "id": "exclude_ids"
                },
                {
                    "id": "exclude_filtered"
                },
                {
                    "id": "dont_require_soft_clips_both_ends"
                },
                {
                    "id": "discordance"
                },
                {
                    "id": "disable_tool_default_read_filters"
                },
                {
                    "id": "disable_sequence_dictionary_validation"
                },
                {
                    "id": "disable_read_filter"
                },
                {
                    "id": "disable_bam_index_caching"
                },
                {
                    "id": "create_output_variant_md5"
                },
                {
                    "id": "create_output_variant_index"
                },
                {
                    "id": "create_output_bam_md5"
                },
                {
                    "id": "create_output_bam_index"
                },
                {
                    "id": "concordance"
                },
                {
                    "id": "cloud_prefetch_buffer"
                },
                {
                    "id": "cloud_index_prefetch_buffer"
                },
                {
                    "id": "black_listed_lanes"
                },
                {
                    "id": "black_list"
                },
                {
                    "id": "ambig_filter_frac"
                },
                {
                    "id": "ambig_filter_bases"
                },
                {
                    "id": "add_output_sam_program_record"
                }
            ],
            "out": [
                {
                    "id": "select_variants_vcf"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "SelectVariants"
                    },
                    {
                        "position": 4,
                        "prefix": "--output",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    read_name = [].concat(inputs.variant)[0].path.replace(/^.*[\\\\\\/]/, '').split('.')\n    read_namebase = read_name.slice(0, read_name.length - 1).join('.')\n    return read_namebase + '.vcf'\n}"
                    },
                    {
                        "position": 4,
                        "prefix": "",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.select_expressions) {\n        sexpression = inputs.select_expressions\n        filter = []\n        for (i = 0; i < sexpression.length; i++) {\n            filter.push(\" --selectExpressions '\", sexpression[i], \"'\")\n        }\n        return filter.join(\"\").trim()\n    }\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Select a subset of variants from a VCF file.\n\n###**Overview**  \n\nThis tool allows you to select a subset of variants based on various criteria in order to facilitate certain analyses such as comparing and contrasting cases vs. controls, extracting variant or non-variant loci that meet certain requirements, or troubleshooting some unexpected results, to name but a few.\n\nThere are many different options for selecting subsets of variants from a larger callset:\n\nExtract one or more samples from a callset based on either a complete sample name or a pattern match.\nSpecify criteria for inclusion that place thresholds on annotation values, e.g. \"DP > 1000\" (depth of coverage greater than 1000x), \"AF < 0.25\" (sites with allele frequency less than 0.25). These criteria are written as \"JEXL expressions\", which are documented in the article about using JEXL expressions.\nProvide concordance or discordance tracks in order to include or exclude variants that are also present in other given callsets.\nSelect variants based on criteria like their type (e.g. INDELs only), evidence of mendelian violation, filtering status, allelicity, and so on.\nThere are also several options for recording the original values of certain annotations that are recalculated when a subsetting the new callset, trimming alleles, and so on.\n\n###**Input**  \n\nA variant call set in VCF format from which to select a subset.  \n\n###**Output**  \n\nA new VCF file containing the selected subset of variants.  \n\n###**Usage examples**   \n\n    ./gatk-launch SelectVariants \\\n     \t-R reference.fasta \\\n     \t-V input.vcf \\\n     \t-selectType SNP \\\n     \t-O output.vcf\n\n###**IMPORTANT NOTICE**  \n\nTools in GATK that require a fasta reference file also look for the reference file's corresponding *.fai* (fasta index) and *.dict* (fasta dictionary) files. The fasta index file allows random access to reference bases and the dictionary file is a dictionary of the contig names and sizes contained within the fasta reference. These two secondary files are essential for GATK to work properly. To append these two files to your fasta reference please use the '***SBG FASTA Indices***' tool within your GATK based workflow before using any of the GATK tools.",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-4-0-selectvariants/16",
                "inputs": {
                    "add_output_sam_program_record": {
                        "doc": "If true, adds a PG tag to created SAM/BAM/CRAM files. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--add-output-sam-program-record",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Add Output Sam Program Record",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "ambig_filter_bases": {
                        "doc": "Threshold number of ambiguous bases. If null, uses threshold fraction; otherwise, overrides threshold fraction. Cannot be used in conjunction with argument(s) maxAmbiguousBaseFraction.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-bases",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Bases",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "ambig_filter_frac": {
                        "doc": "Threshold fraction of non-regular bases (e.g. N) above which to filter Default value: 0.05.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-frac",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Frac",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "float?"
                    },
                    "black_list": {
                        "doc": "This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--black-list",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Black List",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "black_listed_lanes": {
                        "doc": "Keep reads with platform units not on the list This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--black-listed-lanes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Black Listed Lanes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "cloud_index_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Defaults to cloudPrefetchBuffer if unset. Default value: -1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-index-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Index Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "cloud_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Default value: 40.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "concordance": {
                        "doc": "Output variants also called in this comparison track Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--concordance",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Concordance",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "create_output_bam_index": {
                        "doc": "If true, create a BAM/CRAM index when writing a coordinate-sorted BAM/CRAM file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-bam-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Bam Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_bam_md5": {
                        "doc": "If true, create a MD5 digest for any BAM/SAM/CRAM file created Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-bam-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Bam Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "create_output_bam_md5",
                                "symbols": [
                                    "true",
                                    "false"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "create_output_variant_index": {
                        "doc": "If true, create a VCF index when writing a coordinate-sorted VCF file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_variant_md5": {
                        "doc": "If true, create a a MD5 digest any VCF file created. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_bam_index_caching": {
                        "doc": "If true, don't cache bam indexes, this will reduce memory requirements but may harm performance if many intervals are specified. Caching is automatically disabled if there are no intervals specified. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-bam-index-caching",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Bam Index Caching",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_read_filter": {
                        "doc": "Read filters to be disabled before analysis This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Read Filter",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "disable_read_filter",
                                "symbols": [
                                    "GoodCigarReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "disable_sequence_dictionary_validation": {
                        "doc": "If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk! Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-sequence-dictionary-validation",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Sequence Dictionary Validation",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_tool_default_read_filters": {
                        "doc": "Disable all tool default read filters Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-tool-default-read-filters",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Tool Default Read Filters",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "discordance": {
                        "doc": "Output variants not called in this comparison track Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--discordance",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Discordance",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "File?"
                    },
                    "dont_require_soft_clips_both_ends": {
                        "doc": "Allow a read to be filtered out based on having only 1 soft-clipped block. By default, both ends must have a soft-clipped block, setting this flag requires only 1 soft-clipped block. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--dont-require-soft-clips-both-ends",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Dont Require Soft Clips Both Ends",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "boolean?"
                    },
                    "exclude_filtered": {
                        "doc": "Don't include filtered sites Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-filtered",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Filtered",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "exclude_ids": {
                        "doc": "List of variant IDs to select Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-ids",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude I Ds",
                        "sbg:category": "Optional Arguments",
                        "type": "File?"
                    },
                    "exclude_intervals_file": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervals File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File?"
                    },
                    "exclude_intervals_string": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervals String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "exclude_non_variants": {
                        "doc": "Don't include non-variant sites Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-non-variants",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Non Variants",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "exclude_sample_expressions": {
                        "doc": "List of sample expressions to exclude This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-sample-expressions",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Sample Expressions",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "exclude_sample_file": {
                        "doc": "List of samples to exclude This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "itemSeparator": " --exclude-sample-file ",
                            "position": 4,
                            "prefix": "--exclude-sample-file",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Sample File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "File[]?"
                    },
                    "exclude_sample_name": {
                        "doc": "Exclude genotypes from this sample This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-sample-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Sample Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "filter_too_short": {
                        "doc": "Value for which reads with less than this number of aligned bases is considered too short Default value: 30.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--filter-too-short",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Filter Too Short",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "gcs_max_retries": {
                        "doc": "If the GCS bucket channel errors out, how many times it will attempt to re-initiate the connection.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--gcs-max-retries",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Gcs Max Retries",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "20",
                        "type": "int?"
                    },
                    "input": {
                        "doc": "BAM/SAM/CRAM file containing reads This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--input",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Input",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "BAM,SAM,CRAM",
                        "secondaryFiles": [
                            ".bai"
                        ],
                        "type": "File?"
                    },
                    "interval_exclusion_padding": {
                        "doc": "Amount of padding (in bp) to add to each interval you are excluding. Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-exclusion-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Exclusion Padding",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "interval_merging_rule": {
                        "doc": "Interval merging rule for abutting intervals.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-merging-rule",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Merging Rule",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "ALL",
                        "type": [
                            "null",
                            {
                                "name": "interval_merging_rule",
                                "symbols": [
                                    "ALL",
                                    "OVERLAPPING_ONLY"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "interval_padding": {
                        "doc": "Amount of padding (in bp) to add to each interval you are including. Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Padding",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "interval_set_rule": {
                        "doc": "Set merging approach to use for combining interval inputs Default value: UNION. Possible values: {UNION, INTERSECTION}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-set-rule",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Set Rule",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "interval_set_rule",
                                "symbols": [
                                    "UNION",
                                    "INTERSECTION"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "intervals_file": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Intervals File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File?"
                    },
                    "intervals_string": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Intervals String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "invert_mendelian_violation": {
                        "doc": "Output non-mendelian violation sites only Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--invert-mendelian-violation",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Invert Mendelian Violation",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "invert_select": {
                        "doc": "Invert the selection criteria for -select Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--invert-select",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Invert Select",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "keep_ids": {
                        "doc": "List of variant IDs to select Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-ids",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep I Ds",
                        "sbg:category": "Optional Arguments",
                        "type": "File?"
                    },
                    "keep_original_ac": {
                        "doc": "Store the original AC, AF, and AN values after subsetting Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-original-ac",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Original Ac",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "keep_original_dp": {
                        "doc": "Store the original DP value after subsetting Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-original-dp",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Original Dp",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "keep_read_group": {
                        "doc": "The name of the read group to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-read-group",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Read Group",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "keep_reverse": {
                        "doc": "Keep only reads on the reverse strand Required. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-reverse",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Reverse",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "boolean?"
                    },
                    "lenient": {
                        "doc": "Lenient processing of VCF files Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--lenient",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Lenient",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "library": {
                        "doc": "The name of the library to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--library",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Library",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "max_filtered_genotypes": {
                        "doc": "Maximum number of samples filtered at the genotype level Default value: 2147483647.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-filtered-genotypes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Filtered Genotypes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "max_fraction_filtered_genotypes": {
                        "doc": "Maximum fraction of samples filtered at the genotype level Default value: 1.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-fraction-filtered-genotypes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Fraction Filtered Genotypes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "max_fragment_length": {
                        "doc": "Keep only read pairs with fragment length at most equal to the given value Default value: 1000000.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-fragment-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Fragment Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "max_indel_size": {
                        "doc": "Maximum size of indels to include Default value: 2147483647.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-indel-size",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Indel Size",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "max_nocal_lfraction": {
                        "doc": "Maximum fraction of samples with no-call genotypes Default value: 1.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-nocal-lfraction",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Nocal Lfraction",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "max_nocal_lnumber": {
                        "doc": "Maximum number of samples with no-call genotypes Default value: 2147483647.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-nocal-lnumber",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Nocal Lnumber",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "max_read_length": {
                        "doc": "Keep only reads with length at most equal to the specified value Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "maximum_mapping_quality": {
                        "doc": "Maximum mapping quality to keep (inclusive) Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--maximum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Maximum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "memory_overhead_per_job": {
                        "doc": "Memory overhead per job",
                        "label": "Memory Overhead Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "doc": "Memory per job",
                        "label": "Memory Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "mendelian_violation": {
                        "doc": "Output mendelian violation sites only Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--mendelian-violation",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mendelian Violation",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "mendelian_violation_qual_threshold": {
                        "doc": "Minimum GQ score for each trio member to accept a site as a violation Default value: 0.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--mendelian-violation-qual-threshold",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mendelian Violation Qual Threshold",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "min_filtered_genotypes": {
                        "doc": "Minimum number of samples filtered at the genotype level Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-filtered-genotypes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Filtered Genotypes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "min_fraction_filtered_genotypes": {
                        "doc": "Maximum fraction of samples filtered at the genotype level Default value: 0.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-fraction-filtered-genotypes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Fraction Filtered Genotypes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "min_indel_size": {
                        "doc": "Minimum size of indels to include Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-indel-size",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Indel Size",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "min_read_length": {
                        "doc": "Keep only reads with length at least equal to the specified value Default value: 1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "minimum_mapping_quality": {
                        "doc": "Minimum mapping quality to keep (inclusive) Default value: 10.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--minimum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Minimum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "pedigree": {
                        "doc": "Pedigree file Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--pedigree",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Pedigree",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "File?"
                    },
                    "pl_filter_name": {
                        "doc": "Keep reads with RG:PL attribute containing this string This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--pl-filter-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Pl Filter Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "preserve_alleles": {
                        "doc": "Preserve original alleles, do not trim Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--preserve-alleles",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Preserve Alleles",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "preserve_alleles",
                                "symbols": [
                                    "true",
                                    "false"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--quiet",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "quiet",
                                "symbols": [
                                    "true",
                                    "false"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "read_filter": {
                        "doc": "Read filters to be applied before analysis This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Filter",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "read_filter",
                                "symbols": [
                                    "AlignmentAgreesWithHeaderReadFilter",
                                    "AllowAllReadsReadFilter",
                                    "AmbiguousBaseReadFilter",
                                    "CigarContainsNoNOperator",
                                    "FirstOfPairReadFilter",
                                    "FragmentLengthReadFilter",
                                    "GoodCigarReadFilter",
                                    "HasReadGroupReadFilter",
                                    "LibraryReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityNotZeroReadFilter",
                                    "MappingQualityReadFilter",
                                    "MatchingBasesAndQualsReadFilter",
                                    "MateDifferentStrandReadFilter",
                                    "MateOnSameContigOrNoMappedMateReadFilter",
                                    "MetricsReadFilter",
                                    "NonZeroFragmentLengthReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotOpticalDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "NotSupplementaryAlignmentReadFilter",
                                    "OverclippedReadFilter",
                                    "PairedReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "PlatformReadFilter",
                                    "PlatformUnitReadFilter",
                                    "PrimaryLineReadFilter",
                                    "ProperlyPairedReadFilter",
                                    "ReadGroupBlackListReadFilter",
                                    "ReadGroupReadFilter",
                                    "ReadLengthEqualsCigarLengthReadFilter",
                                    "ReadLengthReadFilter",
                                    "ReadNameReadFilter",
                                    "ReadStrandFilter",
                                    "SampleReadFilter",
                                    "SecondOfPairReadFilter",
                                    "SeqIsStoredReadFilter",
                                    "ValidAlignmentEndReadFilter",
                                    "ValidAlignmentStartReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "read_index": {
                        "doc": "Indices to use for the read inputs. If specified, an index must be provided for every read input and in the same order as the read inputs. If this argument is not specified, the path to the index for each input will be inferred automatically. This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "read_name": {
                        "doc": "Keep only reads with this read name Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "read_validation_stringency": {
                        "doc": "Validation stringency for all SAM/BAM/CRAM/SRA files read by this program. The default stringency value SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: SILENT. Possible values: {STRICT, LENIENT, SILENT}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-validation-stringency",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Validation Stringency",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "read_validation_stringency",
                                "symbols": [
                                    "STRICT",
                                    "LENIENT",
                                    "SILENT"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "reference": {
                        "doc": "Reference sequence Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--reference",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reference",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "FASTA, FA",
                        "secondaryFiles": [
                            ".fai",
                            "^.dict"
                        ],
                        "type": "File?"
                    },
                    "remove_fraction_genotypes": {
                        "doc": "Select a fraction of genotypes at random from the input and sets them to no-call Default value: 0.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--remove-fraction-genotypes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Remove Fraction Genotypes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "remove_unused_alternates": {
                        "doc": "Remove alternate alleles not present in any genotypes Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--remove-unused-alternates",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Remove Unused Alternates",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "restrict_alleles_to": {
                        "doc": "Select only variants of a particular allelicity Default value: ALL. Possible values: {ALL, BIALLELIC, MULTIALLELIC}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--restrict-alleles-to",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Restrict Alleles To",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "restrict_alleles_to",
                                "symbols": [
                                    "ALL",
                                    "BIALLELIC",
                                    "MULTIALLELIC"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "sample": {
                        "doc": "The name of the sample(s) to keep, filtering out all others This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "sample_expressions": {
                        "doc": "Regular expression to select multiple samples This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample-expressions",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample Expressions",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "sample_file": {
                        "doc": "File containing a list of samples to include This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample-file",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "File?"
                    },
                    "sample_name": {
                        "doc": "Include genotypes from this sample This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "seconds_between_progress_updates": {
                        "doc": "Output traversal statistics every time this many seconds elapse Default value: 10.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--seconds-between-progress-updates",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Seconds Between Progress Updates",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "select_expressions": {
                        "doc": "One or more criteria to use when selecting the data This argument may be specified 0 or more times. Default value: null.",
                        "label": "Select Expressions",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "[]",
                        "type": "string[]?"
                    },
                    "select_random_fraction": {
                        "doc": "Select a fraction of variants at random from the input Default value: 0.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--select-random-fraction",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Select Random Fraction",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "select_type_to_exclude": {
                        "doc": "Do not select certain type of variants from the input file This argument may be specified 0 or more times. Default value: null. Possible values: {NO_VARIATION, SNP, MNP, INDEL, SYMBOLIC, MIXED}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--select-type-to-exclude",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Select Type To Exclude",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "select_type_to_exclude",
                                "symbols": [
                                    "NO_VARIATION",
                                    "SNP",
                                    "MNP",
                                    "INDEL",
                                    "SYMBOLIC",
                                    "MIXED"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "select_type_to_include": {
                        "doc": "Select only a certain type of variants from the input file This argument may be specified 0 or more times. Default value: null. Possible values: {NO_VARIATION, SNP, MNP, INDEL, SYMBOLIC, MIXED}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--select-type-to-include",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Select Type To Include",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "select_type_to_include",
                                "symbols": [
                                    "NO_VARIATION",
                                    "SNP",
                                    "MNP",
                                    "INDEL",
                                    "SYMBOLIC",
                                    "MIXED"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "set_filtered_gt_to_nocall": {
                        "doc": "Set filtered genotypes to no-call Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--set-filtered-gt-to-nocall",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Set Filtered Gt To Nocall",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_deflater": {
                        "doc": "Whether to use the JdkDeflater (as opposed to IntelDeflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-deflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Whether to use the JdkInflater (as opposed to IntelInflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-inflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "variant": {
                        "doc": "A VCF file containing variants Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--variant",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Variant",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "sbg:fileTypes": "VCF,VCF.GZ",
                        "type": "File"
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--verbosity",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "INDEL GATK SelectVariants",
                "outputs": {
                    "select_variants_vcf": {
                        "doc": "File to which variants should be written.",
                        "label": "Select Variants VCF",
                        "outputBinding": {
                            "glob": "*.vcf",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.variant)\n\n}"
                        },
                        "sbg:fileTypes": "VCF",
                        "secondaryFiles": [
                            ".idx"
                        ],
                        "type": "File"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "3c3b8e0ed4e5",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        if (inputs.memory_overhead_per_job) {\n            return inputs.memory_per_job + inputs.memory_overhead_per_job\n        } else\n            return inputs.memory_per_job\n    } else if (!inputs.memory_per_job && inputs.memory_overhead_per_job) {\n        return 2048 + inputs.memory_overhead_per_job\n    } else\n        return 2048\n}"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": []
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk --java-options \"-Xmx2048M\" SelectVariants --variant /path/to/variant.ext --output variant.vcf",
                "sbg:contributors": [
                    "teodora.aleksic"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/GATK_SelectVariants/47",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-4-0-selectvariants/16",
                "sbg:image_url": null,
                "sbg:latestRevision": 16,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/GATK_SelectVariants/47",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 2229.884854232661,
            "sbg:y": 384.5641937480047
        },
        {
            "id": "SNP_GATK_SelectVariants",
            "in": [
                {
                    "id": "verbosity"
                },
                {
                    "id": "variant",
                    "source": [
                        "GATK_MergeVcfs/output"
                    ]
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "set_filtered_gt_to_nocall"
                },
                {
                    "default": "SNP",
                    "id": "select_type_to_include"
                },
                {
                    "id": "select_type_to_exclude"
                },
                {
                    "id": "select_random_fraction"
                },
                {
                    "id": "select_expressions"
                },
                {
                    "id": "seconds_between_progress_updates"
                },
                {
                    "id": "sample_name"
                },
                {
                    "id": "sample_file"
                },
                {
                    "id": "sample_expressions"
                },
                {
                    "id": "sample"
                },
                {
                    "id": "restrict_alleles_to"
                },
                {
                    "id": "remove_unused_alternates"
                },
                {
                    "id": "remove_fraction_genotypes"
                },
                {
                    "id": "reference",
                    "source": [
                        "SBG_FASTA_Indices/fasta_reference"
                    ]
                },
                {
                    "id": "read_validation_stringency"
                },
                {
                    "id": "read_name"
                },
                {
                    "id": "read_index"
                },
                {
                    "id": "read_filter"
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "preserve_alleles"
                },
                {
                    "id": "pl_filter_name"
                },
                {
                    "id": "pedigree"
                },
                {
                    "id": "minimum_mapping_quality"
                },
                {
                    "id": "min_read_length"
                },
                {
                    "id": "min_indel_size"
                },
                {
                    "id": "min_fraction_filtered_genotypes"
                },
                {
                    "id": "min_filtered_genotypes"
                },
                {
                    "id": "mendelian_violation_qual_threshold"
                },
                {
                    "id": "mendelian_violation"
                },
                {
                    "default": 2048,
                    "id": "memory_per_job"
                },
                {
                    "id": "memory_overhead_per_job"
                },
                {
                    "id": "maximum_mapping_quality"
                },
                {
                    "id": "max_read_length"
                },
                {
                    "id": "max_nocal_lnumber"
                },
                {
                    "id": "max_nocal_lfraction"
                },
                {
                    "id": "max_indel_size"
                },
                {
                    "id": "max_fragment_length"
                },
                {
                    "id": "max_fraction_filtered_genotypes"
                },
                {
                    "id": "max_filtered_genotypes"
                },
                {
                    "id": "library"
                },
                {
                    "id": "lenient"
                },
                {
                    "id": "keep_reverse"
                },
                {
                    "id": "keep_read_group"
                },
                {
                    "id": "keep_original_dp"
                },
                {
                    "id": "keep_original_ac"
                },
                {
                    "id": "keep_ids"
                },
                {
                    "id": "invert_select"
                },
                {
                    "id": "invert_mendelian_violation"
                },
                {
                    "id": "intervals_string"
                },
                {
                    "id": "intervals_file"
                },
                {
                    "id": "interval_set_rule"
                },
                {
                    "id": "interval_padding"
                },
                {
                    "id": "interval_merging_rule"
                },
                {
                    "id": "interval_exclusion_padding"
                },
                {
                    "id": "input"
                },
                {
                    "id": "gcs_max_retries"
                },
                {
                    "id": "filter_too_short"
                },
                {
                    "id": "exclude_sample_name"
                },
                {
                    "id": "exclude_sample_file"
                },
                {
                    "id": "exclude_sample_expressions"
                },
                {
                    "id": "exclude_non_variants"
                },
                {
                    "id": "exclude_intervals_string"
                },
                {
                    "id": "exclude_intervals_file"
                },
                {
                    "id": "exclude_ids"
                },
                {
                    "id": "exclude_filtered"
                },
                {
                    "id": "dont_require_soft_clips_both_ends"
                },
                {
                    "id": "discordance"
                },
                {
                    "id": "disable_tool_default_read_filters"
                },
                {
                    "id": "disable_sequence_dictionary_validation"
                },
                {
                    "id": "disable_read_filter"
                },
                {
                    "id": "disable_bam_index_caching"
                },
                {
                    "id": "create_output_variant_md5"
                },
                {
                    "id": "create_output_variant_index"
                },
                {
                    "id": "create_output_bam_md5"
                },
                {
                    "id": "create_output_bam_index"
                },
                {
                    "id": "concordance"
                },
                {
                    "id": "cloud_prefetch_buffer"
                },
                {
                    "id": "cloud_index_prefetch_buffer"
                },
                {
                    "id": "black_listed_lanes"
                },
                {
                    "id": "black_list"
                },
                {
                    "id": "ambig_filter_frac"
                },
                {
                    "id": "ambig_filter_bases"
                },
                {
                    "id": "add_output_sam_program_record"
                }
            ],
            "out": [
                {
                    "id": "select_variants_vcf"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "SelectVariants"
                    },
                    {
                        "position": 4,
                        "prefix": "--output",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    read_name = [].concat(inputs.variant)[0].path.replace(/^.*[\\\\\\/]/, '').split('.')\n    read_namebase = read_name.slice(0, read_name.length - 1).join('.')\n    return read_namebase + '.vcf'\n}"
                    },
                    {
                        "position": 4,
                        "prefix": "",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.select_expressions) {\n        sexpression = inputs.select_expressions\n        filter = []\n        for (i = 0; i < sexpression.length; i++) {\n            filter.push(\" --selectExpressions '\", sexpression[i], \"'\")\n        }\n        return filter.join(\"\").trim()\n    }\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Select a subset of variants from a VCF file.\n\n###**Overview**  \n\nThis tool allows you to select a subset of variants based on various criteria in order to facilitate certain analyses such as comparing and contrasting cases vs. controls, extracting variant or non-variant loci that meet certain requirements, or troubleshooting some unexpected results, to name but a few.\n\nThere are many different options for selecting subsets of variants from a larger callset:\n\nExtract one or more samples from a callset based on either a complete sample name or a pattern match.\nSpecify criteria for inclusion that place thresholds on annotation values, e.g. \"DP > 1000\" (depth of coverage greater than 1000x), \"AF < 0.25\" (sites with allele frequency less than 0.25). These criteria are written as \"JEXL expressions\", which are documented in the article about using JEXL expressions.\nProvide concordance or discordance tracks in order to include or exclude variants that are also present in other given callsets.\nSelect variants based on criteria like their type (e.g. INDELs only), evidence of mendelian violation, filtering status, allelicity, and so on.\nThere are also several options for recording the original values of certain annotations that are recalculated when a subsetting the new callset, trimming alleles, and so on.\n\n###**Input**  \n\nA variant call set in VCF format from which to select a subset.  \n\n###**Output**  \n\nA new VCF file containing the selected subset of variants.  \n\n###**Usage examples**   \n\n    ./gatk-launch SelectVariants \\\n     \t-R reference.fasta \\\n     \t-V input.vcf \\\n     \t-selectType SNP \\\n     \t-O output.vcf\n\n###**IMPORTANT NOTICE**  \n\nTools in GATK that require a fasta reference file also look for the reference file's corresponding *.fai* (fasta index) and *.dict* (fasta dictionary) files. The fasta index file allows random access to reference bases and the dictionary file is a dictionary of the contig names and sizes contained within the fasta reference. These two secondary files are essential for GATK to work properly. To append these two files to your fasta reference please use the '***SBG FASTA Indices***' tool within your GATK based workflow before using any of the GATK tools.",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-4-0-selectvariants/16",
                "inputs": {
                    "add_output_sam_program_record": {
                        "doc": "If true, adds a PG tag to created SAM/BAM/CRAM files. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--add-output-sam-program-record",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Add Output Sam Program Record",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "ambig_filter_bases": {
                        "doc": "Threshold number of ambiguous bases. If null, uses threshold fraction; otherwise, overrides threshold fraction. Cannot be used in conjunction with argument(s) maxAmbiguousBaseFraction.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-bases",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Bases",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "ambig_filter_frac": {
                        "doc": "Threshold fraction of non-regular bases (e.g. N) above which to filter Default value: 0.05.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-frac",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Frac",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "float?"
                    },
                    "black_list": {
                        "doc": "This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--black-list",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Black List",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "black_listed_lanes": {
                        "doc": "Keep reads with platform units not on the list This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--black-listed-lanes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Black Listed Lanes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "cloud_index_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Defaults to cloudPrefetchBuffer if unset. Default value: -1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-index-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Index Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "cloud_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Default value: 40.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "concordance": {
                        "doc": "Output variants also called in this comparison track Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--concordance",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Concordance",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "create_output_bam_index": {
                        "doc": "If true, create a BAM/CRAM index when writing a coordinate-sorted BAM/CRAM file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-bam-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Bam Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_bam_md5": {
                        "doc": "If true, create a MD5 digest for any BAM/SAM/CRAM file created Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-bam-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Bam Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "create_output_bam_md5",
                                "symbols": [
                                    "true",
                                    "false"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "create_output_variant_index": {
                        "doc": "If true, create a VCF index when writing a coordinate-sorted VCF file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_variant_md5": {
                        "doc": "If true, create a a MD5 digest any VCF file created. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_bam_index_caching": {
                        "doc": "If true, don't cache bam indexes, this will reduce memory requirements but may harm performance if many intervals are specified. Caching is automatically disabled if there are no intervals specified. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-bam-index-caching",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Bam Index Caching",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_read_filter": {
                        "doc": "Read filters to be disabled before analysis This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Read Filter",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "disable_read_filter",
                                "symbols": [
                                    "GoodCigarReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "disable_sequence_dictionary_validation": {
                        "doc": "If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk! Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-sequence-dictionary-validation",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Sequence Dictionary Validation",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_tool_default_read_filters": {
                        "doc": "Disable all tool default read filters Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-tool-default-read-filters",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Tool Default Read Filters",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "discordance": {
                        "doc": "Output variants not called in this comparison track Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--discordance",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Discordance",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "File?"
                    },
                    "dont_require_soft_clips_both_ends": {
                        "doc": "Allow a read to be filtered out based on having only 1 soft-clipped block. By default, both ends must have a soft-clipped block, setting this flag requires only 1 soft-clipped block. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--dont-require-soft-clips-both-ends",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Dont Require Soft Clips Both Ends",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "boolean?"
                    },
                    "exclude_filtered": {
                        "doc": "Don't include filtered sites Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-filtered",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Filtered",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "exclude_ids": {
                        "doc": "List of variant IDs to select Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-ids",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude I Ds",
                        "sbg:category": "Optional Arguments",
                        "type": "File?"
                    },
                    "exclude_intervals_file": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervals File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File?"
                    },
                    "exclude_intervals_string": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervals String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "exclude_non_variants": {
                        "doc": "Don't include non-variant sites Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-non-variants",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Non Variants",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "exclude_sample_expressions": {
                        "doc": "List of sample expressions to exclude This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-sample-expressions",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Sample Expressions",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "exclude_sample_file": {
                        "doc": "List of samples to exclude This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "itemSeparator": " --exclude-sample-file ",
                            "position": 4,
                            "prefix": "--exclude-sample-file",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Sample File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "File[]?"
                    },
                    "exclude_sample_name": {
                        "doc": "Exclude genotypes from this sample This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-sample-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Sample Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "filter_too_short": {
                        "doc": "Value for which reads with less than this number of aligned bases is considered too short Default value: 30.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--filter-too-short",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Filter Too Short",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "gcs_max_retries": {
                        "doc": "If the GCS bucket channel errors out, how many times it will attempt to re-initiate the connection.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--gcs-max-retries",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Gcs Max Retries",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "20",
                        "type": "int?"
                    },
                    "input": {
                        "doc": "BAM/SAM/CRAM file containing reads This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--input",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Input",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "BAM,SAM,CRAM",
                        "secondaryFiles": [
                            ".bai"
                        ],
                        "type": "File?"
                    },
                    "interval_exclusion_padding": {
                        "doc": "Amount of padding (in bp) to add to each interval you are excluding. Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-exclusion-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Exclusion Padding",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "interval_merging_rule": {
                        "doc": "Interval merging rule for abutting intervals.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-merging-rule",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Merging Rule",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "ALL",
                        "type": [
                            "null",
                            {
                                "name": "interval_merging_rule",
                                "symbols": [
                                    "ALL",
                                    "OVERLAPPING_ONLY"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "interval_padding": {
                        "doc": "Amount of padding (in bp) to add to each interval you are including. Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Padding",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "interval_set_rule": {
                        "doc": "Set merging approach to use for combining interval inputs Default value: UNION. Possible values: {UNION, INTERSECTION}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-set-rule",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Set Rule",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "interval_set_rule",
                                "symbols": [
                                    "UNION",
                                    "INTERSECTION"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "intervals_file": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Intervals File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File?"
                    },
                    "intervals_string": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Intervals String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "invert_mendelian_violation": {
                        "doc": "Output non-mendelian violation sites only Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--invert-mendelian-violation",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Invert Mendelian Violation",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "invert_select": {
                        "doc": "Invert the selection criteria for -select Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--invert-select",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Invert Select",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "keep_ids": {
                        "doc": "List of variant IDs to select Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-ids",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep I Ds",
                        "sbg:category": "Optional Arguments",
                        "type": "File?"
                    },
                    "keep_original_ac": {
                        "doc": "Store the original AC, AF, and AN values after subsetting Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-original-ac",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Original Ac",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "keep_original_dp": {
                        "doc": "Store the original DP value after subsetting Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-original-dp",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Original Dp",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "keep_read_group": {
                        "doc": "The name of the read group to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-read-group",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Read Group",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "keep_reverse": {
                        "doc": "Keep only reads on the reverse strand Required. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-reverse",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Reverse",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "boolean?"
                    },
                    "lenient": {
                        "doc": "Lenient processing of VCF files Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--lenient",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Lenient",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "library": {
                        "doc": "The name of the library to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--library",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Library",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "max_filtered_genotypes": {
                        "doc": "Maximum number of samples filtered at the genotype level Default value: 2147483647.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-filtered-genotypes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Filtered Genotypes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "max_fraction_filtered_genotypes": {
                        "doc": "Maximum fraction of samples filtered at the genotype level Default value: 1.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-fraction-filtered-genotypes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Fraction Filtered Genotypes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "max_fragment_length": {
                        "doc": "Keep only read pairs with fragment length at most equal to the given value Default value: 1000000.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-fragment-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Fragment Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "max_indel_size": {
                        "doc": "Maximum size of indels to include Default value: 2147483647.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-indel-size",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Indel Size",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "max_nocal_lfraction": {
                        "doc": "Maximum fraction of samples with no-call genotypes Default value: 1.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-nocal-lfraction",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Nocal Lfraction",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "max_nocal_lnumber": {
                        "doc": "Maximum number of samples with no-call genotypes Default value: 2147483647.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-nocal-lnumber",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Nocal Lnumber",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "max_read_length": {
                        "doc": "Keep only reads with length at most equal to the specified value Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "maximum_mapping_quality": {
                        "doc": "Maximum mapping quality to keep (inclusive) Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--maximum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Maximum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "memory_overhead_per_job": {
                        "doc": "Memory overhead per job",
                        "label": "Memory Overhead Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "doc": "Memory per job",
                        "label": "Memory Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "mendelian_violation": {
                        "doc": "Output mendelian violation sites only Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--mendelian-violation",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mendelian Violation",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "mendelian_violation_qual_threshold": {
                        "doc": "Minimum GQ score for each trio member to accept a site as a violation Default value: 0.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--mendelian-violation-qual-threshold",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mendelian Violation Qual Threshold",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "min_filtered_genotypes": {
                        "doc": "Minimum number of samples filtered at the genotype level Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-filtered-genotypes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Filtered Genotypes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "min_fraction_filtered_genotypes": {
                        "doc": "Maximum fraction of samples filtered at the genotype level Default value: 0.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-fraction-filtered-genotypes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Fraction Filtered Genotypes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "min_indel_size": {
                        "doc": "Minimum size of indels to include Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-indel-size",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Indel Size",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "min_read_length": {
                        "doc": "Keep only reads with length at least equal to the specified value Default value: 1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "minimum_mapping_quality": {
                        "doc": "Minimum mapping quality to keep (inclusive) Default value: 10.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--minimum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Minimum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "pedigree": {
                        "doc": "Pedigree file Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--pedigree",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Pedigree",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "File?"
                    },
                    "pl_filter_name": {
                        "doc": "Keep reads with RG:PL attribute containing this string This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--pl-filter-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Pl Filter Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "preserve_alleles": {
                        "doc": "Preserve original alleles, do not trim Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--preserve-alleles",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Preserve Alleles",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "preserve_alleles",
                                "symbols": [
                                    "true",
                                    "false"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--quiet",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "quiet",
                                "symbols": [
                                    "true",
                                    "false"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "read_filter": {
                        "doc": "Read filters to be applied before analysis This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Filter",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "read_filter",
                                "symbols": [
                                    "AlignmentAgreesWithHeaderReadFilter",
                                    "AllowAllReadsReadFilter",
                                    "AmbiguousBaseReadFilter",
                                    "CigarContainsNoNOperator",
                                    "FirstOfPairReadFilter",
                                    "FragmentLengthReadFilter",
                                    "GoodCigarReadFilter",
                                    "HasReadGroupReadFilter",
                                    "LibraryReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityNotZeroReadFilter",
                                    "MappingQualityReadFilter",
                                    "MatchingBasesAndQualsReadFilter",
                                    "MateDifferentStrandReadFilter",
                                    "MateOnSameContigOrNoMappedMateReadFilter",
                                    "MetricsReadFilter",
                                    "NonZeroFragmentLengthReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotOpticalDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "NotSupplementaryAlignmentReadFilter",
                                    "OverclippedReadFilter",
                                    "PairedReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "PlatformReadFilter",
                                    "PlatformUnitReadFilter",
                                    "PrimaryLineReadFilter",
                                    "ProperlyPairedReadFilter",
                                    "ReadGroupBlackListReadFilter",
                                    "ReadGroupReadFilter",
                                    "ReadLengthEqualsCigarLengthReadFilter",
                                    "ReadLengthReadFilter",
                                    "ReadNameReadFilter",
                                    "ReadStrandFilter",
                                    "SampleReadFilter",
                                    "SecondOfPairReadFilter",
                                    "SeqIsStoredReadFilter",
                                    "ValidAlignmentEndReadFilter",
                                    "ValidAlignmentStartReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "read_index": {
                        "doc": "Indices to use for the read inputs. If specified, an index must be provided for every read input and in the same order as the read inputs. If this argument is not specified, the path to the index for each input will be inferred automatically. This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "read_name": {
                        "doc": "Keep only reads with this read name Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "read_validation_stringency": {
                        "doc": "Validation stringency for all SAM/BAM/CRAM/SRA files read by this program. The default stringency value SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: SILENT. Possible values: {STRICT, LENIENT, SILENT}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-validation-stringency",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Validation Stringency",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "read_validation_stringency",
                                "symbols": [
                                    "STRICT",
                                    "LENIENT",
                                    "SILENT"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "reference": {
                        "doc": "Reference sequence Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--reference",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reference",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "FASTA, FA",
                        "secondaryFiles": [
                            ".fai",
                            "^.dict"
                        ],
                        "type": "File?"
                    },
                    "remove_fraction_genotypes": {
                        "doc": "Select a fraction of genotypes at random from the input and sets them to no-call Default value: 0.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--remove-fraction-genotypes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Remove Fraction Genotypes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "remove_unused_alternates": {
                        "doc": "Remove alternate alleles not present in any genotypes Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--remove-unused-alternates",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Remove Unused Alternates",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "restrict_alleles_to": {
                        "doc": "Select only variants of a particular allelicity Default value: ALL. Possible values: {ALL, BIALLELIC, MULTIALLELIC}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--restrict-alleles-to",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Restrict Alleles To",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "restrict_alleles_to",
                                "symbols": [
                                    "ALL",
                                    "BIALLELIC",
                                    "MULTIALLELIC"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "sample": {
                        "doc": "The name of the sample(s) to keep, filtering out all others This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "sample_expressions": {
                        "doc": "Regular expression to select multiple samples This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample-expressions",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample Expressions",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "sample_file": {
                        "doc": "File containing a list of samples to include This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample-file",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "File?"
                    },
                    "sample_name": {
                        "doc": "Include genotypes from this sample This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "seconds_between_progress_updates": {
                        "doc": "Output traversal statistics every time this many seconds elapse Default value: 10.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--seconds-between-progress-updates",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Seconds Between Progress Updates",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "select_expressions": {
                        "doc": "One or more criteria to use when selecting the data This argument may be specified 0 or more times. Default value: null.",
                        "label": "Select Expressions",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "[]",
                        "type": "string[]?"
                    },
                    "select_random_fraction": {
                        "doc": "Select a fraction of variants at random from the input Default value: 0.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--select-random-fraction",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Select Random Fraction",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "select_type_to_exclude": {
                        "doc": "Do not select certain type of variants from the input file This argument may be specified 0 or more times. Default value: null. Possible values: {NO_VARIATION, SNP, MNP, INDEL, SYMBOLIC, MIXED}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--select-type-to-exclude",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Select Type To Exclude",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "select_type_to_exclude",
                                "symbols": [
                                    "NO_VARIATION",
                                    "SNP",
                                    "MNP",
                                    "INDEL",
                                    "SYMBOLIC",
                                    "MIXED"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "select_type_to_include": {
                        "doc": "Select only a certain type of variants from the input file This argument may be specified 0 or more times. Default value: null. Possible values: {NO_VARIATION, SNP, MNP, INDEL, SYMBOLIC, MIXED}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--select-type-to-include",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Select Type To Include",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "select_type_to_include",
                                "symbols": [
                                    "NO_VARIATION",
                                    "SNP",
                                    "MNP",
                                    "INDEL",
                                    "SYMBOLIC",
                                    "MIXED"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "set_filtered_gt_to_nocall": {
                        "doc": "Set filtered genotypes to no-call Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--set-filtered-gt-to-nocall",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Set Filtered Gt To Nocall",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_deflater": {
                        "doc": "Whether to use the JdkDeflater (as opposed to IntelDeflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-deflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Whether to use the JdkInflater (as opposed to IntelInflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-inflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "variant": {
                        "doc": "A VCF file containing variants Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--variant",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Variant",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "sbg:fileTypes": "VCF,VCF.GZ",
                        "type": "File"
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--verbosity",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "SNP GATK SelectVariants",
                "outputs": {
                    "select_variants_vcf": {
                        "doc": "File to which variants should be written.",
                        "label": "Select Variants VCF",
                        "outputBinding": {
                            "glob": "*.vcf",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.variant)\n\n}"
                        },
                        "sbg:fileTypes": "VCF",
                        "secondaryFiles": [
                            ".idx"
                        ],
                        "type": "File"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "3c3b8e0ed4e5",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        if (inputs.memory_overhead_per_job) {\n            return inputs.memory_per_job + inputs.memory_overhead_per_job\n        } else\n            return inputs.memory_per_job\n    } else if (!inputs.memory_per_job && inputs.memory_overhead_per_job) {\n        return 2048 + inputs.memory_overhead_per_job\n    } else\n        return 2048\n}"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": []
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk --java-options \"-Xmx2048M\" SelectVariants --variant /path/to/variant.ext --output variant.vcf",
                "sbg:contributors": [
                    "teodora.aleksic"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/GATK_SelectVariants/47",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-4-0-selectvariants/16",
                "sbg:image_url": null,
                "sbg:latestRevision": 16,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/GATK_SelectVariants/47",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 2189.9896155601896,
            "sbg:y": 117.42866564222146
        },
        {
            "id": "GATK_GenotypeGVCFs",
            "in": [
                {
                    "id": "variants",
                    "source": [
                        "GATK_HaplotypeCaller/output_vcf"
                    ]
                },
                {
                    "id": "use_new_af_calculator"
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "standard_min_confidence_threshold_for_calling"
                },
                {
                    "id": "seconds_between_progress_updates"
                },
                {
                    "id": "sample_ploidy"
                },
                {
                    "id": "sample"
                },
                {
                    "id": "reference",
                    "source": [
                        "SBG_FASTA_Indices/fasta_reference"
                    ]
                },
                {
                    "id": "read_validation_stringency"
                },
                {
                    "id": "read_name"
                },
                {
                    "id": "read_index"
                },
                {
                    "id": "read_filter"
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "pl_filter_name"
                },
                {
                    "id": "minimum_mapping_quality"
                },
                {
                    "id": "min_read_length"
                },
                {
                    "id": "memory_per_job"
                },
                {
                    "id": "memory_overhead_per_job"
                },
                {
                    "id": "maximum_mapping_quality"
                },
                {
                    "id": "max_read_length"
                },
                {
                    "id": "max_genotype_count"
                },
                {
                    "id": "max_fragment_length"
                },
                {
                    "id": "max_alternate_alleles"
                },
                {
                    "id": "library"
                },
                {
                    "id": "lenient"
                },
                {
                    "id": "keep_reverse"
                },
                {
                    "id": "keep_read_group"
                },
                {
                    "id": "intervals_string"
                },
                {
                    "id": "intervals_file"
                },
                {
                    "id": "interval_padding"
                },
                {
                    "id": "interval_merging_rule"
                },
                {
                    "id": "interval_exclusion_padding"
                },
                {
                    "id": "input_prior"
                },
                {
                    "id": "indel_heterozygosity"
                },
                {
                    "id": "heterozygosity_stdev"
                },
                {
                    "id": "heterozygosity"
                },
                {
                    "id": "group"
                },
                {
                    "id": "filter_too_short"
                },
                {
                    "id": "exclude_intervals_string"
                },
                {
                    "id": "exclude_intervals_file"
                },
                {
                    "id": "dont_require_soft_clips_both_ends"
                },
                {
                    "id": "disable_tool_default_read_filters"
                },
                {
                    "id": "disable_sequence_dictionary_validation"
                },
                {
                    "id": "disable_read_filter"
                },
                {
                    "id": "disable_bam_index_caching"
                },
                {
                    "id": "dbsnp"
                },
                {
                    "id": "create_output_variant_md5"
                },
                {
                    "id": "create_output_variant_index"
                },
                {
                    "id": "create_output_bam_md5"
                },
                {
                    "id": "create_output_bam_index"
                },
                {
                    "id": "cloud_prefetch_buffer"
                },
                {
                    "id": "cloud_index_prefetch_buffer"
                },
                {
                    "id": "black_listed_lanes"
                },
                {
                    "id": "black_list"
                },
                {
                    "id": "annotations_to_exclude"
                },
                {
                    "id": "annotation"
                },
                {
                    "id": "annotate_nda"
                },
                {
                    "id": "ambig_filter_frac"
                },
                {
                    "id": "ambig_filter_bases"
                },
                {
                    "id": "add_output_sam_program_record"
                }
            ],
            "out": [
                {
                    "id": "vcf"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "GenotypeGVCFs"
                    },
                    {
                        "position": 4,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    variant_name = [].concat(inputs.variants)[0].path.replace(/^.*[\\\\\\/]/, '').split('.')\n    variant_namebase = variant_name.slice(0, variant_name.length).join('.')\n    variant_namebase = variant_namebase.replace('.g.vcf', '.vcf')\n    return '--output ' + variant_namebase\n}"
                    },
                    {
                        "position": 4,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    variants = [].concat(inputs.variants)\n\n    cmd = []\n\n    for (i = 0; i < variants.length; i++) {\n        cmd.push('--variant', variants[i].path)\n    }\n\n    return cmd.join(' ')\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Perform joint genotyping on one or more samples pre-called with HaplotypeCaller.\n\n###**Overview**  \nThis tool is designed to perform joint genotyping on multiple samples pre-called with HaplotypeCaller to produce a multi-sample callset in a highly scalable manner. However it can also be run on a single sample at a time to produce a single-sample callset. In any case, the input samples must possess genotype likelihoods produced by HaplotypeCaller with `-ERC GVCF` or `-ERC BP_RESOLUTION`.re-genotype the newly merged record, and then re-annotate it.\n\n###**Input**  \nOne or more GVCFs produced by in HaplotypeCaller with the `-ERC GVCF` or `-ERC BP_RESOLUTION` settings, containing the samples to joint-genotype. \n\n###**Output**  \nA final VCF in which all samples have been jointly genotyped. \n\n###**Usage example**   \n\n####**Perform joint genotyping on a set of GVCFs enumerated in the command line**\n\n     gatk-launch --javaOptions \"-Xmx4g\" GenotypeGVCFs \\\n       -R reference.fasta \\\n       -V input1.g.vcf \\\n       -V input2.g.vcf \\\n       -V input3.g.vcf \\\n       -O output.vcf\n\n####**Perform joint genotyping on a set of GVCFs listed in a text file, one per line**\n\n     gatk-launch --javaOptions \"-Xmx4g\" GenotypeGVCFs \\\n       -R reference.fasta \\\n       -V input_gvcfs.list \\\n       -O output.vcf\n \n###**Caveat**  \nOnly GVCF files produced by HaplotypeCaller (or CombineGVCFs) can be used as input for this tool. Some other programs produce files that they call GVCFs but those lack some important information (accurate genotype likelihoods for every position) that GenotypeGVCFs requires for its operation. \n\n###**Special note on ploidy**  \nThis tool is able to handle any ploidy (or mix of ploidies) intelligently; there is no need to specify ploidy for non-diploid organisms.  \n\n###**Additional Notes**\n- By default, the tool works only with VCF resource files. To use VCF.GZ resource files, the tool wrapper needs to be modified.\n\n###**IMPORTANT NOTICE**  \n\nTools in GATK that require a fasta reference file also look for the reference file's corresponding *.fai* (fasta index) and *.dict* (fasta dictionary) files. The fasta index file allows random access to reference bases and the dictionary file is a dictionary of the contig names and sizes contained within the fasta reference. These two secondary files are essential for GATK to work properly. To append these two files to your fasta reference please use the '***SBG FASTA Indices***' tool within your GATK based workflow before using any of the GATK tools.",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-4-0-genotypegvcfs/20",
                "inputs": {
                    "add_output_sam_program_record": {
                        "doc": "If true, adds a PG tag to created SAM/BAM/CRAM files. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--add-output-sam-program-record",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Add Output Sam Program Record",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "ambig_filter_bases": {
                        "doc": "Threshold number of ambiguous bases. If null, uses threshold fraction; otherwise, overrides threshold fraction. Cannot be used in conjunction with argument(s) maxAmbiguousBaseFraction.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-bases",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Bases",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "ambig_filter_frac": {
                        "doc": "Threshold fraction of non-regular bases (e.g. N) above which to filter Default value: 0.05.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-frac",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Frac",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "float?"
                    },
                    "annotate_nda": {
                        "doc": "If provided, we will annotate records with the number of alternate alleles that were discovered (but not necessarily genotyped) at a given site Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--annotate-with-num-discovered-alleles",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Annotate Nda",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "annotation": {
                        "doc": "One or more specific annotations to recompute. This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--annotation",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Annotation",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "string?"
                    },
                    "annotations_to_exclude": {
                        "doc": "One or more specific annotations to exclude from recomputation. This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--annotations-to-exclude",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Annotations To Exclude",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "string?"
                    },
                    "black_list": {
                        "doc": "This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--black-list",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Black List",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "black_listed_lanes": {
                        "doc": "Keep reads with platform units not on the list This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--black-listed-lanes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Black Listed Lanes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "cloud_index_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Defaults to cloudPrefetchBuffer if unset. Default value: -1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-index-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Index Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "cloud_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Default value: 40.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "create_output_bam_index": {
                        "doc": "If true, create a BAM/CRAM index when writing a coordinate-sorted BAM/CRAM file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-bam-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Bam Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_bam_md5": {
                        "doc": "If true, create a MD5 digest for any BAM/SAM/CRAM file created Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-bam-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Bam Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_variant_index": {
                        "doc": "If true, create a VCF index when writing a coordinate-sorted VCF file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_variant_md5": {
                        "doc": "If true, create a a MD5 digest any VCF file created. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "dbsnp": {
                        "doc": "DbSNP file Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--dbsnp",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Dbsnp",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "VCF,VCF.GZ",
                        "secondaryFiles": [
                            ".idx"
                        ],
                        "type": "File?"
                    },
                    "disable_bam_index_caching": {
                        "doc": "If true, don't cache bam indexes, this will reduce memory requirements but may harm performance if many intervals are specified. Caching is automatically disabled if there are no intervals specified. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-bam-index-caching",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Bam Index Caching",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_read_filter": {
                        "doc": "Read filters to be disabled before analysis This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Read Filter",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "disable_read_filter",
                                "symbols": [
                                    "GoodCigarReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "disable_sequence_dictionary_validation": {
                        "doc": "If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk! Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-sequence-dictionary-validation",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Sequence Dictionary Validation",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_tool_default_read_filters": {
                        "doc": "Disable all tool default read filters Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-tool-default-read-filters",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Tool Default Read Filters",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "dont_require_soft_clips_both_ends": {
                        "doc": "Allow a read to be filtered out based on having only 1 soft-clipped block. By default, both ends must have a soft-clipped block, setting this flag requires only 1 soft-clipped block. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--dont-require-soft-clips-both-ends",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Dont Require Soft Clips Both Ends",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "boolean?"
                    },
                    "exclude_intervals_file": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervals File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File?"
                    },
                    "exclude_intervals_string": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervals String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "filter_too_short": {
                        "doc": "Value for which reads with less than this number of aligned bases is considered too short Default value: 30.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--filter-too-short",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Filter Too Short",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "group": {
                        "doc": "One or more classes/groups of annotations to apply to variant calls This argument may be specified 0 or more times. Default value: [StandardAnnotation].",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--group",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Group",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "string?"
                    },
                    "heterozygosity": {
                        "doc": "Heterozygosity value used to compute prior likelihoods for any locus. See the GATKDocs for full details on the meaning of this population genetics concept Default value: 0.001.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--heterozygosity",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Heterozygosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "heterozygosity_stdev": {
                        "doc": "Standard deviation of eterozygosity for SNP and indel calling. Default value: 0.01.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--heterozygosity-stdev",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Heterozygosity Stdev",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "indel_heterozygosity": {
                        "doc": "Heterozygosity for indel calling. See the GATKDocs for heterozygosity for full details on the meaning of this population genetics concept Default value: 1.25E-4.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--indel-heterozygosity",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Indel Heterozygosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "input_prior": {
                        "doc": "Input prior for calls This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--input-prior",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Input Prior",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "float?"
                    },
                    "interval_exclusion_padding": {
                        "doc": "Amount of padding (in bp) to add to each interval you are excluding. Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-exclusion-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Exclusion Padding",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "interval_merging_rule": {
                        "doc": "Interval merging rule for abutting intervals  Default value: ALL. Possible values: {ALL, OVERLAPPING_ONLY}",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-merging-rule",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Set Rule",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "interval_padding": {
                        "doc": "Amount of padding (in bp) to add to each interval you are including. Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Padding",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "intervals_file": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Intervals File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File?"
                    },
                    "intervals_string": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "itemSeparator": " --intervals ",
                            "position": 4,
                            "prefix": "--intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Intervals String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "keep_read_group": {
                        "doc": "The name of the read group to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-read-group",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Read Group",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "keep_reverse": {
                        "doc": "Keep only reads on the reverse strand Required. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-reverse",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Reverse",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "boolean?"
                    },
                    "lenient": {
                        "doc": "Lenient processing of VCF files Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--lenient",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Lenient",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "library": {
                        "doc": "The name of the library to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--library",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Library",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "max_alternate_alleles": {
                        "doc": "Maximum number of alternate alleles to genotype Default value: 6.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-alternate-alleles",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Alternate Alleles",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "int?"
                    },
                    "max_fragment_length": {
                        "doc": "Keep only read pairs with fragment length at most equal to the given value Default value: 1000000.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-fragment-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Fragment Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "max_genotype_count": {
                        "doc": "Maximum number of genotypes to consider at any site Default value: 1024.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-genotype-count",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Genotype Count",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "int?"
                    },
                    "max_read_length": {
                        "doc": "Keep only reads with length at most equal to the specified value Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "maximum_mapping_quality": {
                        "doc": "Maximum mapping quality to keep (inclusive) Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--maximum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Maximum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "memory_overhead_per_job": {
                        "doc": "Memory overhead per job.",
                        "label": "Memory Overhead Per Job",
                        "sbg:category": "Execution",
                        "sbg:toolDefaultValue": "64",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "doc": "Memory per job in MB.",
                        "label": "Memory Per Job",
                        "sbg:category": "Execution",
                        "sbg:toolDefaultValue": "2048",
                        "type": "int?"
                    },
                    "min_read_length": {
                        "doc": "Keep only reads with length at least equal to the specified value Default value: 1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "minimum_mapping_quality": {
                        "doc": "Minimum mapping quality to keep (inclusive) Default value: 10.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--minimum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Minimum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "pl_filter_name": {
                        "doc": "Keep reads with RG:PL attribute containing this string This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--pl-filter-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Pl Filter Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--quiet",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "read_filter": {
                        "doc": "Read filters to be applied before analysis This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Filter",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "read_filter",
                                "symbols": [
                                    "AlignmentAgreesWithHeaderReadFilter",
                                    "AllowAllReadsReadFilter",
                                    "AmbiguousBaseReadFilter",
                                    "CigarContainsNoNOperator",
                                    "FirstOfPairReadFilter",
                                    "FragmentLengthReadFilter",
                                    "GoodCigarReadFilter",
                                    "HasReadGroupReadFilter",
                                    "LibraryReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityNotZeroReadFilter",
                                    "MappingQualityReadFilter",
                                    "MatchingBasesAndQualsReadFilter",
                                    "MateDifferentStrandReadFilter",
                                    "MateOnSameContigOrNoMappedMateReadFilter",
                                    "MetricsReadFilter",
                                    "NonZeroFragmentLengthReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotOpticalDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "NotSupplementaryAlignmentReadFilter",
                                    "OverclippedReadFilter",
                                    "PairedReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "PlatformReadFilter",
                                    "PlatformUnitReadFilter",
                                    "PrimaryLineReadFilter",
                                    "ProperlyPairedReadFilter",
                                    "ReadGroupBlackListReadFilter",
                                    "ReadGroupReadFilter",
                                    "ReadLengthEqualsCigarLengthReadFilter",
                                    "ReadLengthReadFilter",
                                    "ReadNameReadFilter",
                                    "ReadStrandFilter",
                                    "SampleReadFilter",
                                    "SecondOfPairReadFilter",
                                    "SeqIsStoredReadFilter",
                                    "ValidAlignmentEndReadFilter",
                                    "ValidAlignmentStartReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "read_index": {
                        "doc": "Indices to use for the read inputs. If specified, an index must be provided for every read input and in the same order as the read inputs. If this argument is not specified, the path to the index for each input will be inferred automatically. This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "read_name": {
                        "doc": "Keep only reads with this read name Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "read_validation_stringency": {
                        "doc": "Validation stringency for all SAM/BAM/CRAM/SRA files read by this program. The default stringency value SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: SILENT. Possible values: {STRICT, LENIENT, SILENT}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-validation-stringency",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Validation Stringency",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "read_validation_stringency",
                                "symbols": [
                                    "STRICT",
                                    "LENIENT",
                                    "SILENT"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "reference": {
                        "doc": "Reference sequence file Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--reference",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reference",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "secondaryFiles": [
                            ".fai",
                            "^.dict"
                        ],
                        "type": "File"
                    },
                    "sample": {
                        "doc": "The name of the sample(s) to keep, filtering out all others This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "sample_ploidy": {
                        "doc": "Ploidy (number of chromosomes) per sample. For pooled data, set to (Number of samples in each pool * Sample Ploidy). Default value: 2.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample-ploidy",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample Ploidy",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "seconds_between_progress_updates": {
                        "doc": "Output traversal statistics every time this many seconds elapse Default value: 10.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--seconds-between-progress-updates",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Seconds Between Progress Updates",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "standard_min_confidence_threshold_for_calling": {
                        "doc": "The minimum phred-scaled confidence threshold at which variants should be called Default value: 10.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--standard-min-confidence-threshold-for-calling",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Standard Min Confidence Threshold For Calling",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "use_jdk_deflater": {
                        "doc": "Whether to use the JdkDeflater (as opposed to IntelDeflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-deflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Whether to use the JdkInflater (as opposed to IntelInflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-inflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_new_af_calculator": {
                        "doc": "If provided, we will use the new AF model instead of the so-called exact model Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-new-af-calculator",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use New Af Calculator",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "variants": {
                        "doc": "A VCF file containing variants Required.",
                        "label": "Variants",
                        "sbg:altPrefix": "-V",
                        "sbg:category": "Required Arguments",
                        "sbg:fileTypes": "G.VCF",
                        "type": "File"
                    }
                },
                "label": "GATK GenotypeGVCFs",
                "outputs": {
                    "vcf": {
                        "doc": "Output VCF.",
                        "label": "Output VCF",
                        "outputBinding": {
                            "glob": "*.vcf",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.variants)\n\n}"
                        },
                        "sbg:fileTypes": "VCF",
                        "type": "File?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        if (inputs.memory_overhead_per_job) {\n            return inputs.memory_per_job + inputs.memory_overhead_per_job\n        } else\n            return inputs.memory_per_job\n    } else if (!inputs.memory_per_job && inputs.memory_overhead_per_job) {\n        return 2048 + inputs.memory_overhead_per_job\n    } else\n        return 2048\n}"
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": []
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk --java-options \"-Xmx2048M\" GenotypeGVCFs --reference /path/to/reference.ext  --output variants.ext  --variant /path/to/variants.ext",
                "sbg:contributors": [
                    "teodora.aleksic"
                ],
                "sbg:copyOf": "vladimirk/whole-genome-sequencing-gatk-4-0/gatk-4-0-genotypegvcfs/46",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-4-0-genotypegvcfs/20",
                "sbg:image_url": null,
                "sbg:latestRevision": 20,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-genome-sequencing-gatk-4-0/gatk-4-0-genotypegvcfs/46",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "sbg:wrapperAuthor": "filip_tubic",
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 1687.0880797341679,
            "sbg:y": 207.62366547678548,
            "scatter": "variants"
        },
        {
            "id": "GATK_HaplotypeCaller",
            "in": [
                {
                    "id": "wgs_hg38_mode_memory"
                },
                {
                    "id": "verbosity"
                },
                {
                    "id": "use_new_qual_calculator"
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "use_filtered_reads_for_annotations"
                },
                {
                    "id": "use_alleles_trigger"
                },
                {
                    "id": "standard_min_confidence_threshold_for_calling"
                },
                {
                    "id": "smith_waterman"
                },
                {
                    "id": "seconds_between_progress_updates"
                },
                {
                    "id": "sample_ploidy"
                },
                {
                    "id": "sample_name"
                },
                {
                    "id": "sample"
                },
                {
                    "id": "reference",
                    "source": [
                        "SBG_FASTA_Indices/fasta_reference"
                    ]
                },
                {
                    "id": "recover_dangling_heads"
                },
                {
                    "id": "reads",
                    "source": [
                        "GATK_ApplyBQSR/output"
                    ]
                },
                {
                    "id": "read_validation_stringency"
                },
                {
                    "id": "read_name"
                },
                {
                    "id": "read_index"
                },
                {
                    "id": "read_group_black_list"
                },
                {
                    "id": "read_filter"
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "platform_filter_name"
                },
                {
                    "id": "phred_scaled_global_read_mismapping_rate"
                },
                {
                    "id": "pcr_indel_model"
                },
                {
                    "id": "pair_hmm_gap_continuation_penalty"
                },
                {
                    "id": "output_mode"
                },
                {
                    "id": "num_pruning_samples"
                },
                {
                    "id": "native_pair_hmm_use_double_precision"
                },
                {
                    "id": "native_pair_hmm_threads"
                },
                {
                    "id": "minimum_mapping_quality"
                },
                {
                    "id": "min_read_length"
                },
                {
                    "id": "min_pruning"
                },
                {
                    "id": "min_dangling_branch_length"
                },
                {
                    "id": "min_base_quality_score"
                },
                {
                    "id": "min_assembly_region_size"
                },
                {
                    "default": 2048,
                    "id": "memory_per_job"
                },
                {
                    "default": 64,
                    "id": "memory_overhead_per_job"
                },
                {
                    "id": "maximum_mapping_quality"
                },
                {
                    "id": "max_reads_per_alignment_start"
                },
                {
                    "id": "max_read_length"
                },
                {
                    "id": "max_prob_propagation_distance"
                },
                {
                    "id": "max_num_haplotypes_in_population"
                },
                {
                    "id": "max_genotype_count"
                },
                {
                    "id": "max_fragment_length"
                },
                {
                    "id": "max_assembly_region_size"
                },
                {
                    "id": "max_alternate_alleles"
                },
                {
                    "id": "library"
                },
                {
                    "id": "lenient"
                },
                {
                    "id": "kmer_size"
                },
                {
                    "id": "keep_reverse"
                },
                {
                    "id": "keep_read_group"
                },
                {
                    "id": "intervals_string"
                },
                {
                    "id": "intervals_file",
                    "source": [
                        "SBG_Prepare_Intervals/intervals"
                    ]
                },
                {
                    "default": "UNION",
                    "id": "interval_set_rule"
                },
                {
                    "id": "interval_padding"
                },
                {
                    "id": "interval_merging_rule"
                },
                {
                    "id": "interval_exclusion_padding"
                },
                {
                    "id": "input_prior"
                },
                {
                    "id": "indel_size_to_eliminate_in_ref_model"
                },
                {
                    "id": "indel_heterozygosity"
                },
                {
                    "id": "include_interval_name_in_output_name"
                },
                {
                    "id": "heterozygosity_stdev"
                },
                {
                    "id": "heterozygosity"
                },
                {
                    "id": "gvcf_gq_bands"
                },
                {
                    "id": "graph_output"
                },
                {
                    "default": "DISCOVERY",
                    "id": "genotyping_mode"
                },
                {
                    "id": "filter_too_short"
                },
                {
                    "id": "exclude_intervals_string"
                },
                {
                    "id": "exclude_intervals_file"
                },
                {
                    "default": "GVCF",
                    "id": "emit_ref_confidence"
                },
                {
                    "id": "dont_use_soft_clipped_bases"
                },
                {
                    "id": "dont_trim_active_regions"
                },
                {
                    "id": "dont_require_soft_clips_both_ends"
                },
                {
                    "id": "dont_increase_kmer_sizes_for_cycles"
                },
                {
                    "id": "do_not_run_physical_phasing"
                },
                {
                    "id": "disable_tool_default_read_filters"
                },
                {
                    "id": "disable_tool_default_annotations"
                },
                {
                    "id": "disable_sequence_dictionary_validation"
                },
                {
                    "id": "disable_read_filter"
                },
                {
                    "id": "disable_optimizations"
                },
                {
                    "id": "disable_bam_index_caching"
                },
                {
                    "id": "debug"
                },
                {
                    "id": "db_snp",
                    "source": [
                        "GATK_IndexFeatureFile/output_with_index"
                    ]
                },
                {
                    "id": "create_output_variant_md5"
                },
                {
                    "id": "create_output_variant_index"
                },
                {
                    "id": "create_output_bam_md5"
                },
                {
                    "id": "create_output_bam_index"
                },
                {
                    "id": "cpus_per_job"
                },
                {
                    "id": "contamination_fraction_to_filter"
                },
                {
                    "id": "contamination_fraction_per_sample_file"
                },
                {
                    "id": "consensus"
                },
                {
                    "id": "comp"
                },
                {
                    "id": "cloud_prefetch_buffer"
                },
                {
                    "id": "cloud_index_prefetch_buffer"
                },
                {
                    "id": "black_listed_lanes"
                },
                {
                    "id": "base_quality_score_threshold"
                },
                {
                    "id": "bam_writer_type"
                },
                {
                    "id": "bam_output"
                },
                {
                    "id": "assembly_region_padding"
                },
                {
                    "id": "annotations_to_exclude"
                },
                {
                    "id": "annotation_group"
                },
                {
                    "id": "annotation"
                },
                {
                    "id": "annotate_nda"
                },
                {
                    "id": "ambig_filter_frac"
                },
                {
                    "id": "ambig_filter_bases"
                },
                {
                    "id": "allow_non_unique_kmers_in_ref"
                },
                {
                    "id": "alleles"
                },
                {
                    "id": "all_site_p_ls"
                },
                {
                    "id": "add_output_sam_program_record"
                },
                {
                    "id": "activity_profile_out"
                },
                {
                    "id": "active_probability_threshold"
                }
            ],
            "out": [
                {
                    "id": "output_vcf"
                },
                {
                    "id": "output_bam"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    memory = 0\n\n    if (inputs.memory_per_job) {\n        memory = inputs.memory_per_job\n    } else {\n        if (inputs.wgs_hg38_mode_memory) {\n            reference_name = inputs.reference.path.replace(/^.*[\\\\\\/]/, '')\n\n            if (reference_name.indexOf('38') > -1) {\n                memory = inputs.wgs_hg38_mode_memory\n            } else {\n                memory = 2048\n            }\n        } else {\n            memory = 2048\n        }\n    }\n\n    return '\\\"-Xmx'.concat(memory, 'M') + '\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "HaplotypeCaller"
                    },
                    {
                        "position": 4,
                        "prefix": "--output",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    interval_name = ''\n\n    if (inputs.include_interval_name_in_output_name) {\n        if (inputs.intervals_file) {\n            interval_path = [].concat(inputs.intervals_file)[0].path\n            interval_name = interval_path.split('/')[interval_path.split('/').length - 1].split('.')\n            interval_name.pop()\n            interval_name = '_' + interval_name.join('')\n        }\n    }\n\n    read_name = [].concat(inputs.reads)[0].path.replace(/^.*[\\\\\\/]/, '').split('.')\n\n    if (read_name[read_name.length - 2] == 'recalibrated')\n        read_namebase = read_name.slice(0, read_name.length - 2).join('.')\n    else\n        read_namebase = read_name.slice(0, read_name.length - 1).join('.')\n\n    if (inputs.emit_ref_confidence == 'GVCF')\n        return read_namebase + interval_name + '.g.vcf'\n    else\n        return read_namebase + interval_name + '.vcf'\n}"
                    },
                    {
                        "position": 104,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    reads = [].concat(inputs.reads)\n\n    if (inputs.bam_output) {\n\n        return '--bam-output ' + reads[0].path.split('/').pop().split('.').slice(0, -1).join('.') + '.reassembled.bam'\n\n    } else {\n\n        return ''\n\n    }\n\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Call germline SNPs and indels via local re-assembly of haplotypes.\n\n###**Overview**  \n\nThe HaplotypeCaller is capable of calling SNPs and indels simultaneously via local de-novo assembly of haplotypes in an active region. In other words, whenever the program encounters a region showing signs of variation, it discards the existing mapping information and completely reassembles the reads in that region. This allows the HaplotypeCaller to be more accurate when calling regions that are traditionally difficult to call, for example when they contain different types of variants close to each other. It also makes the HaplotypeCaller much better at calling indels than position-based callers like UnifiedGenotyper.\n\nIn the GVCF workflow used for scalable variant calling in DNA sequence data, HaplotypeCaller runs per-sample to generate an intermediate GVCF (not to be used in final analysis), which can then be used in GenotypeGVCFs for joint genotyping of multiple samples in a very efficient way. The GVCF workflow enables rapid incremental processing of samples as they roll off the sequencer, as well as scaling to very large cohort sizes (e.g. the 92K exomes of ExAC).\n\nIn addition, HaplotypeCaller is able to handle non-diploid organisms as well as pooled experiment data. Note however that the algorithms used to calculate variant likelihoods is not well suited to extreme allele frequencies (relative to ploidy) so its use is not recommended for somatic (cancer) variant discovery. For that purpose, use Mutect2 instead.\n\nFinally, HaplotypeCaller is also able to correctly handle the splice junctions that make RNAseq a challenge for most variant callers, on the condition that the input read data has previously been processed according to our recommendations as documented here. \n\n###**Input**  \nInput bam file(s) from which to make variant calls\n\n###**Output**  \nEither a VCF or GVCF file with raw, unfiltered SNP and indel calls. Regular VCFs must be filtered either by variant recalibration (Best Practice) or hard-filtering before use in downstream analyses. If using the GVCF workflow, the output is a GVCF file that must first be run through GenotypeGVCFs and then filtering before further analysis.\n\n###**Usage examples**  \nThese are example commands that show how to run HaplotypeCaller for typical use cases. Have a look at the method documentation for the basic GVCF workflow.\n\n####**Single-sample GVCF calling (outputs intermediate GVCF)**\n\n     gatk-launch --javaOptions \"-Xmx4g\" HaplotypeCaller  \\\n       -R reference.fasta \\\n       -I input.bam \\\n       -O output.g.vcf \\\n       -ERC GVCF\n\n####**Single-sample GVCF calling with allele-specific annotations**\n\n     gatk-launch --javaOptions \"-Xmx4g\" HaplotypeCaller  \\\n       -R reference.fasta \\\n       -I input.bam \\\n       -O output.g.vcf \\\n       -ERC GVCF \\\n       -G Standard \\\n       -G AS_Standard\n\n####**Variant calling with bamout to show realigned reads**\n\n     gatk-launch --javaOptions \"-Xmx4g\" HaplotypeCaller  \\\n       -R reference.fasta \\\n       -I input.bam \\\n       -O output.vcf \\\n       -bamout bamout.bam\n\n###**Caveats**\n\n- We have not yet fully tested the interaction between the GVCF-based calling or the multisample calling and the RNAseq-specific functionalities. Use those in combination at your own risk.\n\n###**Special note on ploidy**\n\nThis tool is able to handle many non-diploid use cases; the desired ploidy can be specified using the -ploidy argument. Note however that very high ploidies (such as are encountered in large pooled experiments) may cause performance challenges including excessive slowness. We are working on resolving these limitations.\n\n###**Additional Notes**\n- When working with PCR-free data, be sure to set `-pcr_indel_model NONE` (see argument below).\n- When running in `-ERC GVCF` or `-ERC BP_RESOLUTION` modes, the confidence threshold is automatically set to 0. This cannot be overridden by the command line. The threshold can be set manually to the desired level in the next step of the workflow (GenotypeGVCFs)\n- We recommend using a list of intervals to speed up analysis. See this document for details.\n- When using genotype given alleles mode, GATK HaplotypeCaller will try to confirm mutations in a given BAM file. If there are no reads for a position given in the alleles file, the output VCF will not contain that position.\n- By default, the tool works only with VCF resource files. To use VCF.GZ resource files, the tool wrapper needs to be modified.\n\n###**IMPORTANT NOTICE**  \n\nTools in GATK that require a fasta reference file also look for the reference file's corresponding *.fai* (fasta index) and *.dict* (fasta dictionary) files. The fasta index file allows random access to reference bases and the dictionary file is a dictionary of the contig names and sizes contained within the fasta reference. These two secondary files are essential for GATK to work properly. To append these two files to your fasta reference please use the '***SBG FASTA Indices***' tool within your GATK based workflow before using any of the GATK tools.",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-4-0-haplotypecaller/30",
                "inputs": {
                    "active_probability_threshold": {
                        "doc": "Minimum probability for a locus to be considered active. Default value: 0.002.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--active-probability-threshold",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Active Probability Threshold",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "float?"
                    },
                    "activity_profile_out": {
                        "doc": "Output the raw activity profile results in IGV format. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--activity-profile-out",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Activity Profile Out",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "add_output_sam_program_record": {
                        "doc": "If true, adds a PG tag to created SAM/BAM/CRAM files. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--add-output-sam-program-record",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Add Output Sam Program Record",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "all_site_p_ls": {
                        "doc": "Annotate all sites with PLs Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--all-site-p-ls",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "All Site P Ls",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "boolean?"
                    },
                    "alleles": {
                        "doc": "The set of alleles at which to genotype when --genotyping_mode is GENOTYPE_GIVEN_ALLELES Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--alleles",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Alleles",
                        "sbg:category": "Optional Arguments",
                        "secondaryFiles": [
                            ".idx"
                        ],
                        "type": "File?"
                    },
                    "allow_non_unique_kmers_in_ref": {
                        "doc": "Allow graphs that have non-unique kmers in the reference Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--allow-non-unique-kmers-in-ref",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Allow Non Unique Kmers In Ref",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "boolean?"
                    },
                    "ambig_filter_bases": {
                        "doc": "Threshold number of ambiguous bases. If null, uses threshold fraction; otherwise, overrides threshold fraction. Cannot be used in conjunction with argument(s) maxAmbiguousBaseFraction.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-bases",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Bases",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "ambig_filter_frac": {
                        "doc": "Threshold fraction of non-regular bases (e.g. N) above which to filter Default value: 0.05.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-frac",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Frac",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "float?"
                    },
                    "annotate_nda": {
                        "doc": "If provided, we will annotate records with the number of alternate alleles that were discovered (but not necessarily genotyped) at a given site Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--annotate-with-num-discovered-alleles",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Annotate Nda",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "annotation": {
                        "doc": "One or more specific annotations to apply to variant calls This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--annotation",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Annotation",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "string?"
                    },
                    "annotation_group": {
                        "doc": "One or more groups of annotations to apply to variant calls  This argument may be specified 0 or more times. Default value: [StandardAnnotation, StandardHCAnnotation].",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--annotation-group",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Annotation Group",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "annotations_to_exclude": {
                        "doc": "One or more specific annotations to exclude from variant calls  This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--annotations-to-exclude",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Annotations To Exclude",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "assembly_region_padding": {
                        "doc": "Number of additional bases of context to include around each assembly region Default value: 100.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--assembly-region-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Assembly Region Padding",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "bam_output": {
                        "doc": "File to which assembled haplotypes should be written Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--bam-output",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Bam Output",
                        "sbg:category": "Advanced Arguments",
                        "type": "boolean?"
                    },
                    "bam_writer_type": {
                        "doc": "Which haplotypes should be written to the BAM Default value: CALLED_HAPLOTYPES. Possible values: {ALL_POSSIBLE_HAPLOTYPES, CALLED_HAPLOTYPES}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--bam-writer-type",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Bam Writer Type",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": [
                            "null",
                            {
                                "name": "bam_writer_type",
                                "symbols": [
                                    "ALL_POSSIBLE_HAPLOTYPES",
                                    "CALLED_HAPLOTYPES"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "base_quality_score_threshold": {
                        "doc": "Base qualities below this threshold will be reduced to the minimum (6) Default value: 18.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--base-quality-score-threshold",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Base Quality Score Threshold",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "black_listed_lanes": {
                        "doc": "Keep reads with platform units not on the list This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--black-listed-lanes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Black Listed Lanes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "cloud_index_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Defaults to cloudPrefetchBuffer if unset. Default value: -1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-index-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Index Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "cloud_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Default value: 40.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "comp": {
                        "doc": "Comparison VCF file(s) This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--comp",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Comp",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "string?"
                    },
                    "consensus": {
                        "doc": "Consensus mode Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--consensus",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Consensus",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "boolean?"
                    },
                    "contamination_fraction_per_sample_file": {
                        "doc": "Tab-separated File containing fraction of contamination in sequencing data (per sample) to aggressively remove. Format should be \"<SampleID><TAB><Contamination>\" (Contamination is double) per line; No header. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--contamination-fraction-per-sample-file",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Contamination Fraction Per Sample File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "File?"
                    },
                    "contamination_fraction_to_filter": {
                        "doc": "Fraction of contamination in sequencing data (for all samples) to aggressively remove Default value: 0.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--contamination-fraction-to-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Contamination Fraction To Filter",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "cpus_per_job": {
                        "doc": "For tools which support multiprocessing, this value can be used to set the number of threads to be used. Set to 0 for auto-detect (use with caution,as auto-detect will find the optimal value in most cases).",
                        "label": "Cpus Per Job",
                        "type": "int?"
                    },
                    "create_output_bam_index": {
                        "doc": "If true, create a BAM/CRAM index when writing a coordinate-sorted BAM/CRAM file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-bam-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Bam Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_bam_md5": {
                        "doc": "If true, create a MD5 digest for any BAM/SAM/CRAM file created Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-bam-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Bam Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_variant_index": {
                        "doc": "If true, create a VCF index when writing a coordinate-sorted VCF file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "create_output_variant_md5": {
                        "doc": "If true, create a a MD5 digest any VCF file created. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "db_snp": {
                        "doc": "DbSNP file Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "separate": true,
                            "shellQuote": false,
                            "valueFrom": "${\n    if (inputs.db_snp)\n        return '--dbsnp ' + [].concat(inputs.db_snp)[0].path\n    else return ''\n}"
                        },
                        "label": "Db Snp",
                        "sbg:altPrefix": "-D",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "VCF",
                        "secondaryFiles": [
                            ".idx"
                        ],
                        "type": "File?"
                    },
                    "debug": {
                        "doc": "Print out very verbose debug information about each triggering active region Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--debug",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Debug",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "boolean?"
                    },
                    "disable_bam_index_caching": {
                        "doc": "If true, don't cache bam indexes, this will reduce memory requirements but may harm performance if many intervals are specified. Caching is automatically disabled if there are no intervals specified. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-bam-index-caching",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Bam Index Caching",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_optimizations": {
                        "doc": "Don't skip calculations in ActiveRegions with no variants Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-optimizations",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Optimizations",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "boolean?"
                    },
                    "disable_read_filter": {
                        "doc": "Read filters to be disabled before analysis This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Read Filter",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "disable_read_filter",
                                "symbols": [
                                    "GoodCigarReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "disable_sequence_dictionary_validation": {
                        "doc": "If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk! Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-sequence-dictionary-validation",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Sequence Dictionary Validation",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_tool_default_annotations": {
                        "doc": "Disable all tool default annotations.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-tool-default-annotations",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Tool Default Annotations",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_tool_default_read_filters": {
                        "doc": "Disable all tool default read filters Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-tool-default-read-filters",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Tool Default Read Filters",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "do_not_run_physical_phasing": {
                        "doc": "Disable physical phasing Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--do-not-run-physical-phasing",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Do Not Run Physical Phasing",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "boolean?"
                    },
                    "dont_increase_kmer_sizes_for_cycles": {
                        "doc": "Disable iterating over kmer sizes when graph cycles are detected Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--dont-increase-kmer-sizes-for-cycles",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Dont Increase Kmer Sizes For Cycles",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "boolean?"
                    },
                    "dont_require_soft_clips_both_ends": {
                        "doc": "Allow a read to be filtered out based on having only 1 soft-clipped block. By default, both ends must have a soft-clipped block, setting this flag requires only 1 soft-clipped block. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--dont-require-soft-clips-both-ends",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Dont Require Soft Clips Both Ends",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "boolean?"
                    },
                    "dont_trim_active_regions": {
                        "doc": "If specified, we will not trim down the active region from the full region (active + extension) to just the active interval for genotyping Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--dont-trim-active-regions",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Dont Trim Active Regions",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "boolean?"
                    },
                    "dont_use_soft_clipped_bases": {
                        "doc": "Do not analyze soft clipped bases in the reads Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--dont-use-soft-clipped-bases",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Dont Use Soft Clipped Bases",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "boolean?"
                    },
                    "emit_ref_confidence": {
                        "doc": "Mode for emitting reference confidence scores Default value: NONE. Possible values: {NONE, BP_RESOLUTION, GVCF}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--emit-ref-confidence",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Emit Ref Confidence",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": [
                            "null",
                            {
                                "name": "emit_ref_confidence",
                                "symbols": [
                                    "NONE",
                                    "BP_RESOLUTION",
                                    "GVCF"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "exclude_intervals_file": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervals File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File?"
                    },
                    "exclude_intervals_string": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervals String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "filter_too_short": {
                        "doc": "Value for which reads with less than this number of aligned bases is considered too short Default value: 30.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--filter-too-short",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Filter Too Short",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "genotyping_mode": {
                        "doc": "Specifies how to determine the alternate alleles to use for genotyping Default value: DISCOVERY. Possible values: {DISCOVERY, GENOTYPE_GIVEN_ALLELES}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--genotyping-mode",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Genotyping Mode",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "genotyping_mode",
                                "symbols": [
                                    "DISCOVERY",
                                    "GENOTYPE_GIVEN_ALLELES"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "graph_output": {
                        "doc": "Write debug assembly graph information to this file Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--graph-output",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Graph Output",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "gvcf_gq_bands": {
                        "doc": "GQ thresholds for reference confidence bands This argument may be specified 0 or more times. Default value: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 70, 80, 90, 99].",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--gvcf-gq-bands",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Gvcf GQ Bands",
                        "sbg:category": "Advanced Arguments",
                        "type": "int?"
                    },
                    "heterozygosity": {
                        "doc": "Heterozygosity value used to compute prior likelihoods for any locus. See the GATKDocs for full details on the meaning of this population genetics concept Default value: 0.001.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--heterozygosity",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Heterozygosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "heterozygosity_stdev": {
                        "doc": "Standard deviation of eterozygosity for SNP and indel calling. Default value: 0.01.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--heterozygosity-stdev",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Heterozygosity Stdev",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "include_interval_name_in_output_name": {
                        "doc": "Include interval name in output name.",
                        "label": "Include Interval Name In Output Name",
                        "sbg:toolDefaultValue": "FALSE",
                        "type": "boolean?"
                    },
                    "indel_heterozygosity": {
                        "doc": "Heterozygosity for indel calling. See the GATKDocs for heterozygosity for full details on the meaning of this population genetics concept Default value: 1.25E-4.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--indel-heterozygosity",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Indel Heterozygosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "indel_size_to_eliminate_in_ref_model": {
                        "doc": "The size of an indel to check for in the reference model Default value: 10.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--indel-size-to-eliminate-in-ref-model",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Indel Size To Eliminate In Ref Model",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "int?"
                    },
                    "input_prior": {
                        "doc": "Input prior for calls This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--input-prior",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Input Prior",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "float?"
                    },
                    "interval_exclusion_padding": {
                        "doc": "Amount of padding (in bp) to add to each interval you are excluding. Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-exclusion-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Exclusion Padding",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "interval_merging_rule": {
                        "doc": "Interval merging rule for abutting intervals. Default value: ALL.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-merging-rule",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Merging Rule",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "interval_merging_rule",
                                "symbols": [
                                    "ALL",
                                    "OVERLAPPING_ONLY"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "interval_padding": {
                        "doc": "Amount of padding (in bp) to add to each interval you are including. Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Padding",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "interval_set_rule": {
                        "doc": "Set merging approach to use for combining interval inputs Default value: UNION. Possible values: {UNION, INTERSECTION}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-set-rule",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Set Rule",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "interval_set_rule",
                                "symbols": [
                                    "UNION",
                                    "INTERSECTION"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "intervals_file": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "itemSeparator": " ",
                            "position": 4,
                            "separate": false,
                            "shellQuote": false,
                            "valueFrom": "${\n    if (inputs.intervals_file) {\n        if (inputs.intervals_file instanceof Array) {\n            if (inputs.intervals_file.length > 1) {\n                if ([].concat(inputs.reads)[0].metadata)\n                    if ([].concat(inputs.reads)[0].metadata.intervals_file)\n                        return '--intervals ' + [].concat(inputs.reads)[0].metadata.intervals_file\n            } else return '--intervals ' + [].concat(inputs.intervals_file)[0].path\n        } else return '--intervals ' + [].concat(inputs.intervals_file)[0].path\n    } else\n        return ''\n}"
                        },
                        "label": "Intervals File",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File[]?"
                    },
                    "intervals_string": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Intervals String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "keep_read_group": {
                        "doc": "The name of the read group to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-read-group",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Read Group",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "keep_reverse": {
                        "doc": "Keep only reads on the reverse strand Required. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-reverse",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Reverse",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "boolean?"
                    },
                    "kmer_size": {
                        "doc": "Kmer size to use in the read threading assembler This argument may be specified 0 or more times. Default value: [10, 25].",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--kmer-size",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Kmer Size",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "int?"
                    },
                    "lenient": {
                        "doc": "Lenient processing of VCF files Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--lenient",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Lenient",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "library": {
                        "doc": "The name of the library to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--library",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Library",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "max_alternate_alleles": {
                        "doc": "Maximum number of alternate alleles to genotype Default value: 6.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-alternate-alleles",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Alternate Alleles",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "int?"
                    },
                    "max_assembly_region_size": {
                        "doc": "Maximum size of an assembly region Default value: 300.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-assembly-region-size",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Assembly Region Size",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "max_fragment_length": {
                        "doc": "Keep only read pairs with fragment length at most equal to the given value Default value: 1000000.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-fragment-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Fragment Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "max_genotype_count": {
                        "doc": "Maximum number of genotypes to consider at any site Default value: 1024.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-genotype-count",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Genotype Count",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "int?"
                    },
                    "max_num_haplotypes_in_population": {
                        "doc": "Maximum number of haplotypes to consider for your population Default value: 128.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-num-haplotypes-in-population",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Num Haplotypes In Population",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "int?"
                    },
                    "max_prob_propagation_distance": {
                        "doc": "Upper limit on how many bases away probability mass can be moved around when calculating the boundaries between active and inactive assembly regions Default value: 50.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-prob-propagation-distance",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Prob Propagation Distance",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "int?"
                    },
                    "max_read_length": {
                        "doc": "Keep only reads with length at most equal to the specified value Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "max_reads_per_alignment_start": {
                        "doc": "Maximum number of reads to retain per alignment start position. Reads above this threshold will be downsampled. Set to 0 to disable. Default value: 50.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-reads-per-alignment-start",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Reads Per Alignment Start",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "maximum_mapping_quality": {
                        "doc": "Maximum mapping quality to keep (inclusive) Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--maximum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Maximum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "memory_overhead_per_job": {
                        "doc": "Memory overhead per job. By default this parameter value is set to '0' (zero megabytes). This parameter value is added to the Memory per job parameter value. This results in the allocation of the sum total (Memory per job and Memory overhead per job) amount of memory per job. By default the memory per job parameter value is set to 2048 megabytes, unless specified otherwise.",
                        "label": "Memory Overhead Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "doc": "Amount of RAM memory to be used per job. Defaults to 2048MB for Single threaded jobs,and all of the available memory on the instance for multi-threaded jobs.",
                        "label": "Memory Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "min_assembly_region_size": {
                        "doc": "Minimum size of an assembly region Default value: 50.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-assembly-region-size",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Assembly Region Size",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "min_base_quality_score": {
                        "doc": "Minimum base quality required to consider a base for calling Default value: 10.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-base-quality-score",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Base Quality Score",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "min_dangling_branch_length": {
                        "doc": "Minimum length of a dangling branch to attempt recovery Default value: 4.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-dangling-branch-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Dangling Branch Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "int?"
                    },
                    "min_pruning": {
                        "doc": "Minimum support to not prune paths in the graph Default value: 2.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-pruning",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Pruning",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "int?"
                    },
                    "min_read_length": {
                        "doc": "Keep only reads with length at least equal to the specified value Default value: 1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "minimum_mapping_quality": {
                        "doc": "Minimum mapping quality to keep (inclusive) Default value: 20.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--minimum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Minimum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "native_pair_hmm_threads": {
                        "doc": "How many threads should a native pairHMM implementation use Default value: 1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--native-pair-hmm-threads",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Native Pair Hmm Threads",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "native_pair_hmm_use_double_precision": {
                        "doc": "Use double precision in the native pairHmm. This is slower but matches the java implementation better. Default value: false.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--native-pair-hmm-use-double-precision",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Native Pair Hmm Use Double Precision",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "num_pruning_samples": {
                        "doc": "Number of samples that must pass the minPruning threshold Default value: 1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--num-pruning-samples",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Num Pruning Samples",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "int?"
                    },
                    "output_mode": {
                        "doc": "Specifies which type of calls we should output Default value: EMIT_VARIANTS_ONLY. Possible values: {EMIT_VARIANTS_ONLY, EMIT_ALL_CONFIDENT_SITES, EMIT_ALL_SITES}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--output-mode",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Output Mode",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "output_mode",
                                "symbols": [
                                    "EMIT_VARIANTS_ONLY",
                                    "EMIT_ALL_CONFIDENT_SITES",
                                    "EMIT_ALL_SITES"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "pair_hmm_gap_continuation_penalty": {
                        "doc": "Flat gap continuation penalty for use in the Pair HMM Default value: 10.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--pair-hmm-gap-continuation-penalty",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Pair HMM Gap Continuation Penalty",
                        "sbg:category": "Advanced Arguments",
                        "type": "int?"
                    },
                    "pcr_indel_model": {
                        "doc": "The PCR indel model to use Default value: CONSERVATIVE. Possible values: {NONE, HOSTILE, AGGRESSIVE, CONSERVATIVE}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--pcr-indel-model",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Pcr Indel Model",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": [
                            "null",
                            {
                                "name": "pcr_indel_model",
                                "symbols": [
                                    "NONE",
                                    "HOSTILE",
                                    "AGGRESSIVE",
                                    "CONSERVATIVE"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "phred_scaled_global_read_mismapping_rate": {
                        "doc": "The global assumed mismapping rate for reads Default value: 45.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--phred-scaled-global-read-mismapping-rate",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Phred Scaled Global Read Mismapping Rate",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "int?"
                    },
                    "platform_filter_name": {
                        "doc": "Platform attribute (PL) to match. This argument must be specified at least once.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--platform-filter-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Platform Filter Name",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--quiet",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "read_filter": {
                        "doc": "Read filters to be applied before analysis This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Filter",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "read_filter",
                                "symbols": [
                                    "AlignmentAgreesWithHeaderReadFilter",
                                    "AllowAllReadsReadFilter",
                                    "AmbiguousBaseReadFilter",
                                    "CigarContainsNoNOperator",
                                    "FirstOfPairReadFilter",
                                    "FragmentLengthReadFilter",
                                    "GoodCigarReadFilter",
                                    "HasReadGroupReadFilter",
                                    "LibraryReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityNotZeroReadFilter",
                                    "MappingQualityReadFilter",
                                    "MatchingBasesAndQualsReadFilter",
                                    "MateDifferentStrandReadFilter",
                                    "MateOnSameContigOrNoMappedMateReadFilter",
                                    "MetricsReadFilter",
                                    "NonZeroFragmentLengthReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotOpticalDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "NotSupplementaryAlignmentReadFilter",
                                    "OverclippedReadFilter",
                                    "PairedReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "PlatformReadFilter",
                                    "PlatformUnitReadFilter",
                                    "PrimaryLineReadFilter",
                                    "ProperlyPairedReadFilter",
                                    "ReadGroupBlackListReadFilter",
                                    "ReadGroupReadFilter",
                                    "ReadLengthEqualsCigarLengthReadFilter",
                                    "ReadLengthReadFilter",
                                    "ReadNameReadFilter",
                                    "ReadStrandFilter",
                                    "SampleReadFilter",
                                    "SecondOfPairReadFilter",
                                    "SeqIsStoredReadFilter",
                                    "ValidAlignmentEndReadFilter",
                                    "ValidAlignmentStartReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "read_group_black_list": {
                        "doc": "This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-group-black-list",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Group Black List",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "read_index": {
                        "doc": "Indices to use for the read inputs. If specified, an index must be provided for every read input and in the same order as the read inputs. If this argument is not specified, the path to the index for each input will be inferred automatically. This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "read_name": {
                        "doc": "Keep only reads with this read name Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "read_validation_stringency": {
                        "doc": "Validation stringency for all SAM/BAM/CRAM/SRA files read by this program. The default stringency value SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: SILENT. Possible values: {STRICT, LENIENT, SILENT}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-validation-stringency",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Validation Stringency",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "read_validation_stringency",
                                "symbols": [
                                    "STRICT",
                                    "LENIENT",
                                    "SILENT"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "reads": {
                        "doc": "BAM/SAM/CRAM file containing reads This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "itemSeparator": " --input ",
                            "position": 4,
                            "prefix": "--input",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reads",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "sbg:fileTypes": "BAM",
                        "secondaryFiles": [
                            ".bai"
                        ],
                        "type": "File[]"
                    },
                    "recover_dangling_heads": {
                        "doc": "This argument is deprecated since version 3.3 Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--recover-dangling-heads",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Recover Dangling Heads",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "reference": {
                        "doc": "Reference sequence file Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--reference",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reference",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "secondaryFiles": [
                            ".fai",
                            "^.dict"
                        ],
                        "type": "File"
                    },
                    "sample": {
                        "doc": "The name of the sample(s) to keep, filtering out all others This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "sample_name": {
                        "doc": "Name of single sample to use from a multi-sample bam Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "sample_ploidy": {
                        "doc": "Ploidy (number of chromosomes) per sample. For pooled data, set to (Number of samples in each pool * Sample Ploidy). Default value: 2.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample-ploidy",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample Ploidy",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "seconds_between_progress_updates": {
                        "doc": "Output traversal statistics every time this many seconds elapse Default value: 10.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--seconds-between-progress-updates",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Seconds Between Progress Updates",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "smith_waterman": {
                        "doc": "Which Smith-Waterman implementation to use, generally FASTEST_AVAILABLE is the right choice  Default value: JAVA.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--smith-waterman",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Smith-Waterman",
                        "sbg:category": "Advanced Arguments",
                        "type": [
                            "null",
                            {
                                "name": "smith_waterman",
                                "symbols": [
                                    "FASTEST_AVAILABLE",
                                    "AVX_ENABLED",
                                    "JAVA"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "standard_min_confidence_threshold_for_calling": {
                        "doc": "The minimum phred-scaled confidence threshold at which variants should be called Default value: 10.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--standard-min-confidence-threshold-for-calling",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Standard Min Confidence Threshold For Calling",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "use_alleles_trigger": {
                        "doc": "Use additional trigger on variants found in an external alleles file Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-alleles-trigger",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Alleles Trigger",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "boolean?"
                    },
                    "use_filtered_reads_for_annotations": {
                        "doc": "Use the contamination-filtered read maps for the purposes of annotating variants Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-filtered-reads-for-annotations",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Filtered Reads For Annotations",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_deflater": {
                        "doc": "Whether to use the JdkDeflater (as opposed to IntelDeflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-deflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Whether to use the JdkInflater (as opposed to IntelInflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-inflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_new_qual_calculator": {
                        "doc": "If provided, we will use the new qual model. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-new-qual-calculator",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use New Qual Calculator",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--verbosity",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "wgs_hg38_mode_memory": {
                        "doc": "Set recommended value for memory if reference v38 is used",
                        "label": "Wgs Hg38 Mode Memory",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    }
                },
                "label": "GATK HaplotypeCaller",
                "outputs": {
                    "output_bam": {
                        "doc": "Reassembled BAM outputted if the appropriate flag is set.",
                        "label": "Output BAM",
                        "outputBinding": {
                            "glob": "*.bam",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.reads)\n\n}"
                        },
                        "sbg:fileTypes": "BAM",
                        "secondaryFiles": [
                            ".bai"
                        ],
                        "type": "File?"
                    },
                    "output_vcf": {
                        "doc": "A raw, unfiltered, highly specific callset in VCF format.",
                        "label": "VCF",
                        "outputBinding": {
                            "glob": "*.vcf",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.reads)\n\n}"
                        },
                        "sbg:fileTypes": "VCF",
                        "secondaryFiles": [
                            ".idx"
                        ],
                        "type": "File?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "3c3b8e0ed4e5",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    memory = 0\n\n    if (inputs.memory_per_job) {\n        memory = inputs.memory_per_job\n    } else {\n        if (inputs.wgs_hg38_mode_memory) {\n            reference_name = inputs.reference.path.replace(/^.*[\\\\\\/]/, '')\n\n            if (reference_name.indexOf('38') > -1) {\n                memory = inputs.wgs_hg38_mode_memory\n            } else {\n                memory = 2048\n            }\n        } else {\n            memory = 2048\n        }\n    }\n\n    if (inputs.memory_overhead_per_job) {\n        return memory + inputs.memory_overhead_per_job\n    } else {\n        return memory\n    }\n}"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": [
                            "$(inputs.intervals_file)"
                        ]
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk --java-options \"-Xmx2048M\" HaplotypeCaller --input /path/to/input.bam --reference /path/to/reference.fa --output input.g.vcf",
                "sbg:contributors": [
                    "teodora.aleksic"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/GATK_HaplotypeCaller/78",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-4-0-haplotypecaller/30",
                "sbg:image_url": null,
                "sbg:latestRevision": 30,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/GATK_HaplotypeCaller/78",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 1532.7304075849204,
            "sbg:y": 315.842745364086,
            "scatter": "reads"
        },
        {
            "id": "GATK_BaseRecalibrator",
            "in": [
                {
                    "id": "verbosity"
                },
                {
                    "id": "use_original_qualities"
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "seconds_between_progress_updates"
                },
                {
                    "id": "sample"
                },
                {
                    "id": "reference",
                    "source": [
                        "SBG_FASTA_Indices/fasta_reference"
                    ]
                },
                {
                    "id": "reads",
                    "source": [
                        "BWA_MEM_Bundle/aligned_reads"
                    ]
                },
                {
                    "id": "read_validation_stringency"
                },
                {
                    "id": "read_name"
                },
                {
                    "id": "read_index"
                },
                {
                    "id": "read_filter"
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "quantizing_levels"
                },
                {
                    "id": "preserve_qscores_less_than"
                },
                {
                    "id": "pl_filter_name"
                },
                {
                    "id": "mismatches_default_quality"
                },
                {
                    "id": "mismatches_context_size"
                },
                {
                    "id": "minimum_mapping_quality"
                },
                {
                    "id": "min_read_length"
                },
                {
                    "id": "memory_per_job"
                },
                {
                    "id": "memory_overhead_per_job"
                },
                {
                    "id": "maximum_mapping_quality"
                },
                {
                    "id": "maximum_cycle_value"
                },
                {
                    "id": "max_read_length"
                },
                {
                    "id": "max_fragment_length"
                },
                {
                    "id": "low_quality_tail"
                },
                {
                    "id": "library"
                },
                {
                    "id": "lenient"
                },
                {
                    "id": "known_sites",
                    "source": [
                        "GATK_IndexFeatureFile_2/output_with_index",
                        "GATK_IndexFeatureFile/output_with_index",
                        "GATK_IndexFeatureFile_1/output_with_index"
                    ]
                },
                {
                    "id": "keep_reverse"
                },
                {
                    "id": "keep_read_group"
                },
                {
                    "id": "intervals_string"
                },
                {
                    "id": "intervals_file",
                    "source": [
                        "intervals_file"
                    ]
                },
                {
                    "id": "interval_set_rule"
                },
                {
                    "id": "interval_merging_rule"
                },
                {
                    "id": "interval_exclusion_padding"
                },
                {
                    "id": "insertions_default_quality"
                },
                {
                    "id": "indels_context_size"
                },
                {
                    "id": "filter_too_short"
                },
                {
                    "id": "exclude_intervals_string"
                },
                {
                    "id": "exclude_intervals_file"
                },
                {
                    "id": "dont_require_soft_clips_both_ends"
                },
                {
                    "id": "disable_tool_default_read_filters"
                },
                {
                    "id": "disable_sequence_dictionary_validation"
                },
                {
                    "id": "disable_read_filter"
                },
                {
                    "id": "disable_bam_index_caching"
                },
                {
                    "id": "deletions_default_quality"
                },
                {
                    "id": "default_base_qualities"
                },
                {
                    "id": "create_output_variant_md5"
                },
                {
                    "id": "create_output_variant_index"
                },
                {
                    "id": "create_output_bam_md5"
                },
                {
                    "id": "create_output_bam_index"
                },
                {
                    "id": "cloud_prefetch_buffer"
                },
                {
                    "id": "cloud_index_prefetch_buffer"
                },
                {
                    "id": "bqsr_baq_gap_open_penalty"
                },
                {
                    "id": "black_listed_lanes"
                },
                {
                    "id": "black_list"
                },
                {
                    "id": "binary_tag_name"
                },
                {
                    "id": "ambig_filter_frac"
                },
                {
                    "id": "ambig_filter_bases"
                },
                {
                    "id": "add_output_vcf_command_line"
                },
                {
                    "id": "add_output_sam_program_record"
                }
            ],
            "out": [
                {
                    "id": "recalibration_file"
                },
                {
                    "id": "performance_summary"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "BaseRecalibrator"
                    },
                    {
                        "position": 4,
                        "prefix": "",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    read_name = [].concat(inputs.reads)[0].path.replace(/^.*[\\\\\\/]/, '').split('.')\n    read_namebase = read_name.slice(0, read_name.length - 1).join('.')\n    return '--output ' + read_namebase + '.recal_data.grp'\n}"
                    },
                    {
                        "position": 4,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "--create-output-bam-index"
                    },
                    {
                        "position": 4,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    known_sites = [].concat(inputs.known_sites)\n\n    cmd = []\n\n    for (i = 0; i < known_sites.length; i++) {\n        cmd.push('--known-sites', known_sites[i].path)\n    }\n\n    return cmd.join(' ')\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "First pass of the base quality score recalibration -- Generates recalibration table based on various covariates (such as read group, reported quality score, machine cycle, and nucleotide context).\n\n###**Overview**  \n\nThis walker is designed to work as the first pass in a two-pass processing step. It does a by-locus traversal operating only at sites that are not in dbSNP. We assume that all reference mismatches we see are therefore errors and indicative of poor base quality. This walker generates tables based on various user-specified covariates (such as read group, reported quality score, cycle, and context). Since there is a large amount of data one can then calculate an empirical probability of error given the particular covariates seen at this site, where p(error) = num mismatches / num observations. The output file is a table (of the several covariate values, num observations, num mismatches, empirical quality score).\n\nNote: ReadGroupCovariate and QualityScoreCovariate are required covariates and will be added for the user regardless of whether or not they were specified.\n\n###**Inputs**  \n\nThe input read data whose base quality scores need to be assessed.\nA database of known polymorphic sites to skip over.\n\n###**Output**  \n\nA GATK Report file with many tables:\n\n- The list of arguments\n- The quantized qualities table\n- The recalibration table by read group\n- The recalibration table by quality score\n- The recalibration table for all the optional covariates\n\nThe GATK Report is intended to be easy to read by humans or computers. Check out the documentation of the GATKReport to learn how to manipulate this table.\n\n###**Usage example**  \n\n     ./gatk-launch BaseRecalibrator \\ \n     \t -R reference.fasta \\ \n         -I input.bam \\   \n         --knownSites latest_dbsnp.vcf \\  \n         -O recalibration.table \n\n###**Additional Notes**\n\n- By default, the tool works only with VCF resource files. To use VCF.GZ resource files, the tool wrapper needs to be modified.\n\n###**IMPORTANT NOTICE**  \n\nTools in GATK that require a fasta reference file also look for the reference file's corresponding *.fai* (fasta index) and *.dict* (fasta dictionary) files. The fasta index file allows random access to reference bases and the dictionary file is a dictionary of the contig names and sizes contained within the fasta reference. These two secondary files are essential for GATK to work properly. To append these two files to your fasta reference please use the '***SBG FASTA Indices***' tool within your GATK based workflow before using any of the GATK tools.",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-4-0-baserecalibrator/22",
                "inputs": {
                    "add_output_sam_program_record": {
                        "doc": "If true, adds a PG tag to created SAM/BAM/CRAM files. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--add-output-sam-program-record",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Add Output Sam Program Record",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "add_output_vcf_command_line": {
                        "doc": "If true, adds a command line header line to created VCF file. Default value: true.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--add-output-vcf-command-line",
                            "separate": false,
                            "shellQuote": false,
                            "valueFrom": "${\n    return ''\n}"
                        },
                        "label": "Adds a command line header line to created VCF file",
                        "sbg:toolDefaultValue": "TRUE",
                        "type": "boolean?"
                    },
                    "ambig_filter_bases": {
                        "doc": "Threshold number of ambiguous bases. If null, uses threshold fraction; otherwise, overrides threshold fraction. Cannot be used in conjunction with argument(s) maxAmbiguousBaseFraction.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-bases",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Bases",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "ambig_filter_frac": {
                        "doc": "Threshold fraction of non-regular bases (e.g. N) above which to filter Default value: 0.05.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-frac",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Frac",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "float?"
                    },
                    "binary_tag_name": {
                        "doc": "The binary tag covariate name if using it Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--binary-tag-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Binary Tag Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "black_list": {
                        "doc": "This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--black-list",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Black List",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "black_listed_lanes": {
                        "doc": "Keep reads with platform units not on the list This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--black-listed-lanes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Black Listed Lanes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "bqsr_baq_gap_open_penalty": {
                        "doc": "BQSR BAQ gap open penalty (Phred Scaled). Default value is 40. 30 is perhaps better for whole genome call sets Default value: 40.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--bqsr-baq-gap-open-penalty",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Bqsr Baq Gap Open Penalty",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "cloud_index_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Defaults to cloudPrefetchBuffer if unset. Default value: -1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-index-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Index Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "cloud_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Default value: 40.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "create_output_bam_index": {
                        "doc": "If true, create a BAM/CRAM index when writing a coordinate-sorted BAM/CRAM file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-bam-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Bam Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "create_output_bam_md5": {
                        "doc": "If true, create a MD5 digest for any BAM/SAM/CRAM file created Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-bam-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Bam Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "create_output_variant_index": {
                        "doc": "If true, create a VCF index when writing a coordinate-sorted VCF file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "create_output_variant_md5": {
                        "doc": "If true, create a a MD5 digest any VCF file created. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "default_base_qualities": {
                        "doc": "Assign a default base quality Default value: -1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--default-base-qualities",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Default Base Qualities",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "deletions_default_quality": {
                        "doc": "Default quality for the base deletions covariate Default value: 45.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--deletions-default-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Deletions Default Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "disable_bam_index_caching": {
                        "doc": "If true, don't cache bam indexes, this will reduce memory requirements but may harm performance if many intervals are specified. Caching is automatically disabled if there are no intervals specified. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-bam-index-caching",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Bam Index Caching",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_read_filter": {
                        "doc": "Read filters to be disabled before analysis  This argument may be specified 0 or more                               times. Default value: null. Possible Values: {MappedReadFilter,                               MappingQualityAvailableReadFilter, MappingQualityNotZeroReadFilter,                               NotDuplicateReadFilter, NotSecondaryAlignmentReadFilter,                               PassesVendorQualityCheckReadFilter, WellformedReadFilter}",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Read Filter",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "disable_read_filter",
                                "symbols": [
                                    "GoodCigarReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "disable_sequence_dictionary_validation": {
                        "doc": "If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk! Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-sequence-dictionary-validation",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Sequence Dictionary Validation",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "disable_tool_default_read_filters": {
                        "doc": "Disable all tool default read filters Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-tool-default-read-filters",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Tool Default Read Filters",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "dont_require_soft_clips_both_ends": {
                        "doc": "Allow a read to be filtered out based on having only 1 soft-clipped block. By default, both ends must have a soft-clipped block, setting this flag requires only 1 soft-clipped block. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--dont-require-soft-clips-both-ends",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Dont Require Soft Clips Both Ends",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "boolean?"
                    },
                    "exclude_intervals_file": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervals File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File?"
                    },
                    "exclude_intervals_string": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervals String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "filter_too_short": {
                        "doc": "Value for which reads with less than this number of aligned bases is considered too short Default value: 30.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--filter-too-short",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Filter Too Short",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "indels_context_size": {
                        "doc": "Size of the k-mer context to be used for base insertions and deletions Default value: 3.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--indels-context-size",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Indels Context Size",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "insertions_default_quality": {
                        "doc": "Default quality for the base insertions covariate Default value: 45.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--insertions-default-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Insertions Default Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "interval_exclusion_padding": {
                        "doc": "Amount of padding (in bp) to add to each interval you are excluding. Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-exclusion-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Exclusion Padding",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "interval_merging_rule": {
                        "doc": "Interval merging rule for abutting intervals  Default value: ALL. Possible values: {ALL, OVERLAPPING_ONLY}",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval merging rule",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "interval_set_rule": {
                        "doc": "Set merging approach to use for combining interval inputs Default value: UNION. Possible values: {UNION, INTERSECTION}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-set-rule",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Set Rule",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "interval_set_rule",
                                "symbols": [
                                    "UNION",
                                    "INTERSECTION"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "intervals_file": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Intervals File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File?"
                    },
                    "intervals_string": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--intervals",
                            "separate": true,
                            "shellQuote": false,
                            "valueFrom": "${\n    if (inputs.reference && inputs.intervals_string) {\n        fasta = inputs.reference.contents\n        interval = inputs.intervals_string\n        // fasta - UCSC format\n        if (fasta.indexOf(\">chr\") != -1) {\n            // INTERVAL - UCSC format, all w/ chr\n            if (interval.indexOf(\"chr\") != -1) {\n                return interval\n            } // if (interval.indexOf(\"chr\") == -1)\n            // interval - 1000G format, convert to UCSC\n            else {\n                if (Number(interval) || interval == \"X\" || interval == \"Y\") {\n                    return \"chr\".concat(interval)\n                } // if (Number(interval)|| interval == \"X\" || interval == \"Y\")\n                else {\n                    if (interval == \"MT\") {\n                        return \"chrM\"\n                    } //if (interval == \"MT\")\n                    else {\n                        if (Number(interval.substr(2, 6)) < 211) {\n                            n = Number(interval.substr(2, 6)) - 190;\n                            s = \"chr\";\n                            s = s.concat(n.toString());\n                            s = s.concat(\"_gl\");\n                            s = s.concat(interval.substr(2, 6));\n                            s = s.concat(\"_random\");\n                            return s\n                        } // if(Number(interval.substr(2,interval.length-2))<211)\n                        else {\n                            if (Number(interval.substr(2, 6)) < 250) {\n                                s = \"chrUn_gl\";\n                                s = s.concat(interval.substr(2, 6));\n                                return s\n                            } //if(Number(interval.substr(2,interval.length-2))<250)\n                            else {\n                                return interval\n                            } //if(Number(interval.substr(2,interval.length-2))<250) - else\n                        } // if(Number(interval.substr(2,interval.length-2))<211) - else\n                    } //if (interval == \"MT\") - else\n                } //if (Number(interval)|| interval == \"X\" || interval == \"Y\") - else\n            } //if (interval.indexOf(\"chr\") == -1) - else\n        } //if (fasta.indexOf(\">chr\") == -1)\n        // fasta - 1000G format\n        else {\n            //interval - USCS format, all w/ chr, convert to 1000G\n            if (interval.indexOf(\"chr\") != -1) {\n                if (Number(interval.substr(3, 2)) && interval.length < 6 || interval == \"chrX\" || interval == \"chrY\") {\n                    return interval.substr(3, 2)\n                } //if(Number(interval.substr(3,interval.length)) != NaN || interval == \"chrX\" || bsqr == \"chrY\")\n                else {\n                    if (interval == \"chrM\") {\n                        return \"MT\"\n                    } //if (interval == \"chrM\")\n                    else {\n                        s = \"GL\";\n                        s = s.concat(interval.substr(8, 6));\n                        s = s.concat(\".1\");\n                        return s\n                    } //if (interval == \"chrM\") - else\n                } //if(Number(interval.substr(3,interval.length)) != NaN || interval == \"chrX\" || bsqr == \"chrY\") - else\n            } //if(inputs.interval.indexOf(\"chr\") == -1)\n            // interval - 1000G format\n            else {\n                return interval\n            } //(interval.indexOf(\"chr\") == -1) - else\n        } //if (fasta.indexOf(\">chr\") == -1) - else\n    } //if (inputs.fasta && inputs.interval)\n}"
                        },
                        "label": "Intervals String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "keep_read_group": {
                        "doc": "The name of the read group to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-read-group",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Read Group",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "keep_reverse": {
                        "doc": "Keep only reads on the reverse strand Required. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-reverse",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Reverse",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "boolean?"
                    },
                    "known_sites": {
                        "doc": "One or more databases of known polymorphic sites used to exclude regions around known polymorphisms from analysis. This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "shellQuote": false,
                            "valueFrom": "${\n    return ''\n}"
                        },
                        "label": "Known Sites",
                        "sbg:altPrefix": "-knownSites",
                        "sbg:category": "Required Arguments",
                        "sbg:fileTypes": "TXT, BED, VCF",
                        "secondaryFiles": [
                            ".idx"
                        ],
                        "type": "File[]"
                    },
                    "lenient": {
                        "doc": "Lenient processing of VCF files Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--lenient",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Lenient",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "library": {
                        "doc": "The name of the library to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--library",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Library",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "low_quality_tail": {
                        "doc": "Minimum quality for the bases in the tail of the reads to be considered Default value: 2.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--low-quality-tail",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Low Quality Tail",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "max_fragment_length": {
                        "doc": "Keep only read pairs with fragment length at most equal to the given value Default value: 1000000.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-fragment-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Fragment Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "max_read_length": {
                        "doc": "Keep only reads with length at most equal to the specified value Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "maximum_cycle_value": {
                        "doc": "The maximum cycle value permitted for the Cycle covariate Default value: 500.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--maximum-cycle-value",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Maximum Cycle Value",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "maximum_mapping_quality": {
                        "doc": "Maximum mapping quality to keep (inclusive) Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--maximum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Maximum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "memory_overhead_per_job": {
                        "doc": "Memory Overhead Per Job",
                        "label": "Memory Overhead Per Job",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "doc": "Memory per job",
                        "label": "Memory Per Job",
                        "type": "int?"
                    },
                    "min_read_length": {
                        "doc": "Keep only reads with length at least equal to the specified value Default value: 1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "minimum_mapping_quality": {
                        "doc": "Minimum mapping quality to keep (inclusive) Default value: 10.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--minimum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Minimum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "mismatches_context_size": {
                        "doc": "Size of the k-mer context to be used for base mismatches Default value: 2.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--mismatches-context-size",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mismatches Context Size",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "mismatches_default_quality": {
                        "doc": "Default quality for the base mismatches covariate Default value: -1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--mismatches-default-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mismatches Default Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "pl_filter_name": {
                        "doc": "Keep reads with RG:PL attribute containing this string This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--pl-filter-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Pl Filter Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "preserve_qscores_less_than": {
                        "doc": "Don't recalibrate bases with quality scores less than this threshold (with -bqsr) Default value: 6.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--preserve-qscores-less-than",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Preserve Qscores Less Than",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "int?"
                    },
                    "quantizing_levels": {
                        "doc": "number of distinct quality scores in the quantized output  Default value: 16.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--quantizing-levels",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quantizing Levels",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "16",
                        "type": "int?"
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--quiet",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "read_filter": {
                        "doc": "Read filters to be applied before analysis This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Filter",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "read_filter",
                                "symbols": [
                                    "AlignmentAgreesWithHeaderReadFilter",
                                    "AllowAllReadsReadFilter",
                                    "AmbiguousBaseReadFilter",
                                    "CigarContainsNoNOperator",
                                    "FirstOfPairReadFilter",
                                    "FragmentLengthReadFilter",
                                    "GoodCigarReadFilter",
                                    "HasReadGroupReadFilter",
                                    "LibraryReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityNotZeroReadFilter",
                                    "MappingQualityReadFilter",
                                    "MatchingBasesAndQualsReadFilter",
                                    "MateDifferentStrandReadFilter",
                                    "MateOnSameContigOrNoMappedMateReadFilter",
                                    "MetricsReadFilter",
                                    "NonZeroFragmentLengthReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotOpticalDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "NotSupplementaryAlignmentReadFilter",
                                    "OverclippedReadFilter",
                                    "PairedReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "PlatformReadFilter",
                                    "PlatformUnitReadFilter",
                                    "PrimaryLineReadFilter",
                                    "ProperlyPairedReadFilter",
                                    "ReadGroupBlackListReadFilter",
                                    "ReadGroupReadFilter",
                                    "ReadLengthEqualsCigarLengthReadFilter",
                                    "ReadLengthReadFilter",
                                    "ReadNameReadFilter",
                                    "ReadStrandFilter",
                                    "SampleReadFilter",
                                    "SecondOfPairReadFilter",
                                    "SeqIsStoredReadFilter",
                                    "ValidAlignmentEndReadFilter",
                                    "ValidAlignmentStartReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "read_index": {
                        "doc": "Indices to use for the read inputs. If specified, an index must be provided for every read input and in the same order as the read inputs. If this argument is not specified, the path to the index for each input will be inferred automatically.  This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Index",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "read_name": {
                        "doc": "Keep only reads with this read name Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "read_validation_stringency": {
                        "doc": "Validation stringency for all SAM/BAM/CRAM/SRA files read by this program. The default stringency value SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: SILENT. Possible values: {STRICT, LENIENT, SILENT}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-validation-stringency",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Validation Stringency",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "read_validation_stringency",
                                "symbols": [
                                    "STRICT",
                                    "LENIENT",
                                    "SILENT"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "reads": {
                        "doc": "BAM/SAM/CRAM file containing reads This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "itemSeparator": " --input ",
                            "position": 4,
                            "prefix": "--input",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reads",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "sbg:fileTypes": "CRAM, BAM",
                        "secondaryFiles": [
                            ".bai"
                        ],
                        "type": "File[]"
                    },
                    "reference": {
                        "doc": "Reference sequence file Required.",
                        "inputBinding": {
                            "loadContents": true,
                            "position": 4,
                            "prefix": "--reference",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reference",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "sbg:fileTypes": "FASTA, FA",
                        "secondaryFiles": [
                            ".fai",
                            "^.dict"
                        ],
                        "type": "File"
                    },
                    "sample": {
                        "doc": "The name of the sample(s) to keep, filtering out all others This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "string?"
                    },
                    "seconds_between_progress_updates": {
                        "doc": "Output traversal statistics every time this many seconds elapse Default value: 10.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--seconds-between-progress-updates",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Seconds Between Progress Updates",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "float?"
                    },
                    "use_jdk_deflater": {
                        "doc": "Whether to use the JdkDeflater (as opposed to IntelDeflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-deflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Whether to use the JdkInflater (as opposed to IntelInflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-inflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_original_qualities": {
                        "doc": "Use the base quality scores from the OQ tag Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-original-qualities",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Original Qualities",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--verbosity",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "GATK BaseRecalibrator",
                "outputs": {
                    "performance_summary": {
                        "doc": "Test",
                        "label": "Performance Summary",
                        "outputBinding": {
                            "glob": "*.txt"
                        },
                        "type": "File?"
                    },
                    "recalibration_file": {
                        "doc": "The output recalibration table file to create.",
                        "label": "BQSR Table",
                        "outputBinding": {
                            "glob": "*.recal_data.grp",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.reads)\n\n}"
                        },
                        "sbg:fileTypes": "GRP",
                        "type": "File"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "3c3b8e0ed4e5",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        if (inputs.memory_overhead_per_job) {\n            return inputs.memory_per_job + inputs.memory_overhead_per_job\n        } else\n            return inputs.memory_per_job\n    } else if (!inputs.memory_per_job && inputs.memory_overhead_per_job) {\n        return 2048 + inputs.memory_overhead_per_job\n    } else\n        return 2048\n}"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": []
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk --java-options \"-Xmx4M\" BaseRecalibrator --input /path/to/reads-1.ext --input /path/to/reads-2.ext --reference /path/to/reference.ext  --output reads-1.recal_data.grp  --create-output-bam-index  --known-sites /path/to/known_sites-1.ext",
                "sbg:contributors": [
                    "teodora.aleksic",
                    "vladimirk"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/GATK_BaseRecalibrator/72",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-4-0-baserecalibrator/22",
                "sbg:image_url": null,
                "sbg:latestRevision": 22,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/GATK_BaseRecalibrator/72",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 998.8099151774204,
            "sbg:y": 360.23835659974196
        },
        {
            "id": "GATK_IndexFeatureFile_2",
            "in": [
                {
                    "id": "verbosity"
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "memory_per_job"
                },
                {
                    "id": "memory_overhead_per_job"
                },
                {
                    "id": "feature_file",
                    "source": [
                        "indels_1000g_phase1"
                    ]
                }
            ],
            "out": [
                {
                    "id": "output_with_index"
                },
                {
                    "id": "index"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "IndexFeatureFile"
                    },
                    {
                        "position": 4,
                        "prefix": "--output",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    output_name = inputs.feature_file.path.split('/').slice(-1)[0]\n\n    if (output_name.endsWith('.gz')) {\n        return output_name + '.tbi'\n    } else {\n        return output_name + '.idx'\n    }\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Creates indices for Feature-containing files, such as VCF and BED files.\n\n###**Overview** \nCreates indices for Feature-containing files, such as VCF and BED files.\n\n###**Inputs**  \nA feature file to be indexed.  \n\n###**Outputs**  \nAn index file.\n\n###**Usage example**\n\n    java -Xmx4g -jar gatk.jar \\  \n         IndexFeatureFile \\  \n         --feature_file feature_file.vcf \\ \n         --output feature_file.vcf.idx",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-4-0-index-feature-file/14",
                "inputs": {
                    "feature_file": {
                        "doc": "Feature file (eg., VCF or BED file) to index. Must be in a tribble-supported format Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--feature-file",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Feature File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "type": "File"
                    },
                    "memory_overhead_per_job": {
                        "doc": "Memory overhead per job",
                        "label": "Memory Overhead Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "doc": "Memory per job",
                        "label": "Memory Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--quiet",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_deflater": {
                        "doc": "Whether to use the JdkDeflater (as opposed to IntelDeflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-deflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Whether to use the JdkInflater (as opposed to IntelInflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-inflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--verbosity",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "GATK IndexFeatureFile",
                "outputs": {
                    "index": {
                        "doc": "Index file",
                        "label": "Index file",
                        "outputBinding": {
                            "glob": "${\n    output_name = inputs.feature_file.path.split('/').slice(-1)[0]\n\n    if (output_name.endsWith('.gz')) {\n        return output_name + '.tbi'\n    } else {\n        return output_name + '.idx'\n    }\n}"
                        },
                        "sbg:fileTypes": "IDX",
                        "type": "File?"
                    },
                    "output_with_index": {
                        "doc": "Output file with index.",
                        "label": "Output file with index",
                        "outputBinding": {
                            "glob": "${\n    return inputs.feature_file.path.split('/').slice(-1)[0]\n}",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.feature_file)\n\n}"
                        },
                        "sbg:fileTypes": "VCF,BED,RECAL",
                        "secondaryFiles": [
                            ".idx"
                        ],
                        "type": "File"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "3c3b8e0ed4e5",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        if (inputs.memory_overhead_per_job) {\n            return inputs.memory_per_job + inputs.memory_overhead_per_job\n        } else\n            return inputs.memory_per_job\n    } else if (!inputs.memory_per_job && inputs.memory_overhead_per_job) {\n        return 2048 + inputs.memory_overhead_per_job\n    } else\n        return 2048\n}"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": [
                            "$(inputs.feature_file)"
                        ]
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk-launch --javaOptions \"-Xmx2048M\" IndexFeatureFile --feature_file /path/to/feature_file.vcf.gz --output feature_file.vcf.gz.tbi",
                "sbg:contributors": [
                    "teodora.aleksic"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-index-feature-file/43",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-4-0-index-feature-file/14",
                "sbg:image_url": null,
                "sbg:latestRevision": 14,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-index-feature-file/43",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 731.0259079546089,
            "sbg:y": 787.5645454551587
        },
        {
            "id": "GATK_IndexFeatureFile_1",
            "in": [
                {
                    "id": "verbosity"
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "memory_per_job"
                },
                {
                    "id": "memory_overhead_per_job"
                },
                {
                    "id": "feature_file",
                    "source": [
                        "mills"
                    ]
                }
            ],
            "out": [
                {
                    "id": "output_with_index"
                },
                {
                    "id": "index"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "IndexFeatureFile"
                    },
                    {
                        "position": 4,
                        "prefix": "--output",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    output_name = inputs.feature_file.path.split('/').slice(-1)[0]\n\n    if (output_name.endsWith('.gz')) {\n        return output_name + '.tbi'\n    } else {\n        return output_name + '.idx'\n    }\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Creates indices for Feature-containing files, such as VCF and BED files.\n\n###**Overview** \nCreates indices for Feature-containing files, such as VCF and BED files.\n\n###**Inputs**  \nA feature file to be indexed.  \n\n###**Outputs**  \nAn index file.\n\n###**Usage example**\n\n    java -Xmx4g -jar gatk.jar \\  \n         IndexFeatureFile \\  \n         --feature_file feature_file.vcf \\ \n         --output feature_file.vcf.idx",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-4-0-index-feature-file/14",
                "inputs": {
                    "feature_file": {
                        "doc": "Feature file (eg., VCF or BED file) to index. Must be in a tribble-supported format Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--feature-file",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Feature File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "type": "File"
                    },
                    "memory_overhead_per_job": {
                        "doc": "Memory overhead per job",
                        "label": "Memory Overhead Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "doc": "Memory per job",
                        "label": "Memory Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--quiet",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_deflater": {
                        "doc": "Whether to use the JdkDeflater (as opposed to IntelDeflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-deflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Whether to use the JdkInflater (as opposed to IntelInflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-inflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--verbosity",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "GATK IndexFeatureFile",
                "outputs": {
                    "index": {
                        "doc": "Index file",
                        "label": "Index file",
                        "outputBinding": {
                            "glob": "${\n    output_name = inputs.feature_file.path.split('/').slice(-1)[0]\n\n    if (output_name.endsWith('.gz')) {\n        return output_name + '.tbi'\n    } else {\n        return output_name + '.idx'\n    }\n}"
                        },
                        "sbg:fileTypes": "IDX",
                        "type": "File?"
                    },
                    "output_with_index": {
                        "doc": "Output file with index.",
                        "label": "Output file with index",
                        "outputBinding": {
                            "glob": "${\n    return inputs.feature_file.path.split('/').slice(-1)[0]\n}",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.feature_file)\n\n}"
                        },
                        "sbg:fileTypes": "VCF,BED,RECAL",
                        "secondaryFiles": [
                            ".idx"
                        ],
                        "type": "File"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "3c3b8e0ed4e5",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        if (inputs.memory_overhead_per_job) {\n            return inputs.memory_per_job + inputs.memory_overhead_per_job\n        } else\n            return inputs.memory_per_job\n    } else if (!inputs.memory_per_job && inputs.memory_overhead_per_job) {\n        return 2048 + inputs.memory_overhead_per_job\n    } else\n        return 2048\n}"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": [
                            "$(inputs.feature_file)"
                        ]
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk-launch --javaOptions \"-Xmx2048M\" IndexFeatureFile --feature_file /path/to/feature_file.vcf.gz --output feature_file.vcf.gz.tbi",
                "sbg:contributors": [
                    "teodora.aleksic"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-index-feature-file/43",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-4-0-index-feature-file/14",
                "sbg:image_url": null,
                "sbg:latestRevision": 14,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-index-feature-file/43",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 737.3081347667422,
            "sbg:y": 962.3083878480738
        },
        {
            "id": "GATK_IndexFeatureFile",
            "in": [
                {
                    "id": "verbosity"
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "memory_per_job"
                },
                {
                    "id": "memory_overhead_per_job"
                },
                {
                    "id": "feature_file",
                    "source": [
                        "dbsnp"
                    ]
                }
            ],
            "out": [
                {
                    "id": "output_with_index"
                },
                {
                    "id": "index"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "IndexFeatureFile"
                    },
                    {
                        "position": 4,
                        "prefix": "--output",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    output_name = inputs.feature_file.path.split('/').slice(-1)[0]\n\n    if (output_name.endsWith('.gz')) {\n        return output_name + '.tbi'\n    } else {\n        return output_name + '.idx'\n    }\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Creates indices for Feature-containing files, such as VCF and BED files.\n\n###**Overview** \nCreates indices for Feature-containing files, such as VCF and BED files.\n\n###**Inputs**  \nA feature file to be indexed.  \n\n###**Outputs**  \nAn index file.\n\n###**Usage example**\n\n    java -Xmx4g -jar gatk.jar \\  \n         IndexFeatureFile \\  \n         --feature_file feature_file.vcf \\ \n         --output feature_file.vcf.idx",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-4-0-index-feature-file/14",
                "inputs": {
                    "feature_file": {
                        "doc": "Feature file (eg., VCF or BED file) to index. Must be in a tribble-supported format Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--feature-file",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Feature File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "type": "File"
                    },
                    "memory_overhead_per_job": {
                        "doc": "Memory overhead per job",
                        "label": "Memory Overhead Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "doc": "Memory per job",
                        "label": "Memory Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--quiet",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_deflater": {
                        "doc": "Whether to use the JdkDeflater (as opposed to IntelDeflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-deflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Whether to use the JdkInflater (as opposed to IntelInflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-inflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--verbosity",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "GATK IndexFeatureFile",
                "outputs": {
                    "index": {
                        "doc": "Index file",
                        "label": "Index file",
                        "outputBinding": {
                            "glob": "${\n    output_name = inputs.feature_file.path.split('/').slice(-1)[0]\n\n    if (output_name.endsWith('.gz')) {\n        return output_name + '.tbi'\n    } else {\n        return output_name + '.idx'\n    }\n}"
                        },
                        "sbg:fileTypes": "IDX",
                        "type": "File?"
                    },
                    "output_with_index": {
                        "doc": "Output file with index.",
                        "label": "Output file with index",
                        "outputBinding": {
                            "glob": "${\n    return inputs.feature_file.path.split('/').slice(-1)[0]\n}",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.feature_file)\n\n}"
                        },
                        "sbg:fileTypes": "VCF,BED,RECAL",
                        "secondaryFiles": [
                            ".idx"
                        ],
                        "type": "File"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "3c3b8e0ed4e5",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        if (inputs.memory_overhead_per_job) {\n            return inputs.memory_per_job + inputs.memory_overhead_per_job\n        } else\n            return inputs.memory_per_job\n    } else if (!inputs.memory_per_job && inputs.memory_overhead_per_job) {\n        return 2048 + inputs.memory_overhead_per_job\n    } else\n        return 2048\n}"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": [
                            "$(inputs.feature_file)"
                        ]
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk-launch --javaOptions \"-Xmx2048M\" IndexFeatureFile --feature_file /path/to/feature_file.vcf.gz --output feature_file.vcf.gz.tbi",
                "sbg:contributors": [
                    "teodora.aleksic"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-index-feature-file/43",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-4-0-index-feature-file/14",
                "sbg:image_url": null,
                "sbg:latestRevision": 14,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-index-feature-file/43",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 737.0517058525492,
            "sbg:y": 1128.3337852690124
        },
        {
            "id": "SBG_Prepare_Intervals",
            "in": [
                {
                    "default": "File per chr with alt contig in a single file",
                    "id": "split_mode"
                },
                {
                    "id": "format"
                },
                {
                    "id": "fai_file"
                },
                {
                    "id": "bed_file",
                    "source": [
                        "intervals_file"
                    ]
                }
            ],
            "out": [
                {
                    "id": "str_arr"
                },
                {
                    "id": "names"
                },
                {
                    "id": "intervals"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.format)\n        return \"--format \" + \"\\\"\" + inputs.format + \"\\\"\"\n}"
                    }
                ],
                "baseCommand": [
                    "python",
                    "sbg_prepare_intervals.py"
                ],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Depending on selected Split Mode value, output files are generated in accordance with description below:\n\n1. File per interval - The tool creates one interval file per line of the input BED(FAI) file.\nEach interval file contains a single line (one of the lines of BED(FAI) input file).\n\n2. File per chr with alt contig in a single file - For each contig(chromosome) a single file\nis created containing all the intervals corresponding to it .\nAll the intervals (lines) other than (chr1, chr2 ... chrY or 1, 2 ... Y) are saved as\n(\"others.bed\").\n\n3. Output original BED - BED file is required for execution of this mode. If mode 3 is applied input is passed to the output.\n\n4. File per interval with alt contig in a single file - For each chromosome a single file is created for each interval.\nAll the intervals (lines) other than (chr1, chr2 ... chrY or 1, 2 ... Y) are saved as\n(\"others.bed\").\n\n##### Common issues: \nDo not use option 1 (File per interval) with exome BED or a BED with a lot of GL contigs, as it will create a large number of files.",
                "hints": [],
                "id": "bix-demo/sbgtools-demo/sbg-prepare-intervals/15",
                "inputs": {
                    "bed_file": {
                        "doc": "Input BED file containing intervals. Required for modes 3 and 4.",
                        "inputBinding": {
                            "position": 1,
                            "prefix": "--bed",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Input BED file",
                        "sbg:category": "File Input",
                        "sbg:fileTypes": "BED",
                        "type": "File?"
                    },
                    "fai_file": {
                        "doc": "FAI file is converted to BED format if BED file is not provided.",
                        "inputBinding": {
                            "position": 2,
                            "prefix": "--fai",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Input FAI file",
                        "sbg:category": "File Input",
                        "sbg:fileTypes": "FAI",
                        "type": "File?"
                    },
                    "format": {
                        "doc": "Format of the intervals in the generated files.",
                        "label": "Interval format",
                        "sbg:category": "Input",
                        "type": [
                            "null",
                            {
                                "name": "format",
                                "symbols": [
                                    "chr start end",
                                    "chr:start-end"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "split_mode": {
                        "doc": "Depending on selected Split Mode value, output files are generated in accordance with description below:  1. File per interval - The tool creates one interval file per line of the input BED(FAI) file. Each interval file contains a single line (one of the lines of BED(FAI) input file).  2. File per chr with alt contig in a single file - For each contig(chromosome) a single file is created containing all the intervals corresponding to it . All the intervals (lines) other than (chr1, chr2 ... chrY or 1, 2 ... Y) are saved as (\"others.bed\").  3. Output original BED - BED file is required for execution of this mode. If mode 3 is applied input is passed to the output.  4. File per interval with alt contig in a single file - For each chromosome a single file is created for each interval. All the intervals (lines) other than (chr1, chr2 ... chrY or 1, 2 ... Y) are saved as (\"others.bed\"). NOTE: Do not use option 1 (File per interval) with exome BED or a BED with a lot of GL contigs, as it will create a large number of files.",
                        "inputBinding": {
                            "position": 3,
                            "prefix": "--mode",
                            "separate": true,
                            "shellQuote": false,
                            "valueFrom": "${\n    mode = inputs.split_mode\n    switch (mode) {\n        case \"File per interval\":\n            return 1\n        case \"File per chr with alt contig in a single file\":\n            return 2\n        case \"Output original BED\":\n            return 3\n        case \"File per interval with alt contig in a single file\":\n            return 4\n    }\n    return 3\n}"
                        },
                        "label": "Split mode",
                        "sbg:category": "Input",
                        "type": {
                            "name": "split_mode",
                            "symbols": [
                                "File per interval",
                                "File per chr with alt contig in a single file",
                                "Output original BED",
                                "File per interval with alt contig in a single file"
                            ],
                            "type": "enum"
                        }
                    }
                },
                "label": "SBG Prepare Intervals",
                "outputs": {
                    "intervals": {
                        "doc": "Array of BED files genereted as per selected Split Mode.",
                        "label": "Intervals",
                        "outputBinding": {
                            "glob": "Intervals/*.bed"
                        },
                        "sbg:fileTypes": "BED",
                        "type": "File[]?"
                    },
                    "names": {
                        "doc": "File containing the names of created files.",
                        "label": "Output file names",
                        "outputBinding": {
                            "glob": "Intervals/names.txt",
                            "loadContents": true,
                            "outputEval": "${\n    content = self[0].contents.replace(/\\0/g, '')\n    content = content.replace('[', '')\n    content = content.replace(']', '')\n    content = content.replace(/\\'/g, \"\")\n    content = content.replace(/\\s/g, '')\n    content_arr = content.split(\",\")\n\n    return content_arr\n\n\n}"
                        },
                        "type": "string?"
                    },
                    "str_arr": {
                        "doc": "Outputs BED content as strings.",
                        "label": "String output",
                        "outputBinding": {
                            "glob": "${\n    if (inputs.bed_file) {\n        glob = inputs.bed_file.path\n        glob = glob.split('/').slice(-1)[0]\n    } else if (inputs.fai_file) {\n        glob = inputs.fai_file.path\n        glob = glob.split('/').slice(-1)[0].split('.').slice(0, -1).join('.') + '.bed'\n    }\n\n    return glob\n}",
                            "loadContents": true,
                            "outputEval": "${\n    rows = self[0].contents\n    if (rows[rows.length - 1] == '\\n') {\n        rows = rows.split(/\\r?\\n/).slice(0, -1);\n    } else {\n        rows = rows.split(/\\r?\\n/);\n    }\n    out_list = []\n    for (i = 0; i < rows.length; i++) {\n        row = rows[i];\n        chromosome = row.split(\"\\t\")[0];\n        start = row.split(\"\\t\")[1];\n        end = row.split(\"\\t\")[2];\n        if (typeof start !== \"undefined\") {\n            interval = chromosome.concat(\":\", start, \"-\", end);\n        } else {\n            interval = chromosome\n        }\n        out_list.push(interval);\n    }\n    return out_list;\n\n}"
                        },
                        "type": "string[]?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": 1000
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "",
                        "dockerPull": "images.sbgenomics.com/bogdang/sbg_prepare_intervals:1.0"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": [
                            {
                                "entry": "\"\"\"\nUsage:\n    sbg_prepare_intervals.py [options] [--fastq FILE --bed FILE --mode INT --format STR --others STR]\n\nDescription:\n    Purpose of this tool is to split BED file into files based on the selected mode.\n    If bed file is not provided fai(fasta index) file is converted to bed.\n\nOptions:\n\n    -h, --help            Show this message.\n\n    -v, -V, --version     Tool version.\n\n    -b, -B, --bed FILE    Path to input bed file.\n\n    --fai FILE            Path to input fai file.\n\n    --format STR          Output file format.\n\n    --mode INT            Select input mode.\n\n\"\"\"\n\n\nimport os\nimport sys\nimport glob\nimport shutil\nfrom docopt import docopt\n\ndefault_extension = '.bed'  # for output files\n\n\ndef create_file(contents, contig_name, extension=default_extension):\n    \"\"\"function for creating a file for all intervals in a contig\"\"\"\n\n    new_file = open(\"Intervals/\" + contig_name + extension, \"w\")\n    new_file.write(contents)\n    new_file.close()\n\n\ndef add_to_file(line, name, extension=default_extension):\n    \"\"\"function for adding a line to a file\"\"\"\n\n    new_file = open(\"Intervals/\" + name + extension, \"a\")\n    if lformat == formats[1]:\n        sep = line.split(\"\\t\")\n        line = sep[0] + \":\" + sep[1] + \"-\" + sep[2]\n    new_file.write(line)\n    new_file.close()\n\n\ndef fai2bed(fai):\n    \"\"\"function to create a bed file from fai file\"\"\"\n\n    region_thr = 10000000  # threshold used to determine starting point accounting for telomeres in chromosomes\n    basename = fai[0:fai.rfind(\".\")]\n    with open(fai, \"r\") as ins:\n        new_array = []\n        for line in ins:\n            len_reg = int(line.split()[1])\n            cutoff = 0 if (\n            len_reg < region_thr) else 0  # sd\\\\telomeres or start with 1\n            new_line = line.split()[0] + '\\t' + str(cutoff) + '\\t' + str(\n                len_reg + cutoff)\n            new_array.append(new_line)\n    new_file = open(basename + \".bed\", \"w\")\n    new_file.write(\"\\n\".join(new_array))\n    return basename + \".bed\"\n\n\ndef chr_intervals(no_of_chrms=23):\n    \"\"\"returns all possible designations for chromosome intervals\"\"\"\n\n    chrms = []\n    for i in range(1, no_of_chrms):\n        chrms.append(\"chr\" + str(i))\n        chrms.append(str(i))\n    chrms.extend([\"x\", \"y\", \"chrx\", \"chry\"])\n    return chrms\n\n\ndef mode_1(orig_file):\n    \"\"\"mode 1: every line is a new file\"\"\"\n\n    with open(orig_file, \"r\") as ins:\n        prev = \"\"\n        counter = 0\n        names = []\n        for line in ins:\n            if is_header(line):\n                continue\n            if line.split()[0] == prev:\n                counter += 1\n            else:\n                counter = 0\n            suffix = \"\" if (counter == 0) else \"_\" + str(counter)\n            create_file(line, line.split()[0] + suffix)\n            names.append(line.split()[0] + suffix)\n            prev = line.split()[0]\n\n        create_file(str(names), \"names\", extension=\".txt\")\n\n\ndef mode_2(orig_file, others_name):\n    \"\"\"mode 2: separate file is created for each chromosome, and one file is created for other intervals\"\"\"\n\n    chrms = chr_intervals()\n    names = []\n\n    with open(orig_file, 'r') as ins:\n        for line in ins:\n            if is_header(line):\n                continue\n            name = line.split()[0]\n            if name.lower() in chrms:\n                name = name\n            else:\n                name = others_name\n            try:\n                add_to_file(line, name)\n                if not name in names:\n                    names.append(name)\n            except:\n                raise Exception(\n                    \"Couldn't create or write in the file in mode 2\")\n\n        create_file(str(names), \"names\", extension=\".txt\")\n\n\ndef mode_3(orig_file, extension=default_extension):\n    \"\"\"mode 3: input file is staged to output\"\"\"\n\n    orig_name = orig_file.split(\"/\")[len(orig_file.split(\"/\")) - 1]\n    output_file = r\"./Intervals/\" + orig_name[\n                                    0:orig_name.rfind('.')] + extension\n\n    shutil.copyfile(orig_file, output_file)\n\n    names = [orig_name[0:orig_name.rfind('.')]]\n    create_file(str(names), \"names\", extension=\".txt\")\n\n\ndef mode_4(orig_file, others_name):\n    \"\"\"mode 4: every interval in chromosomes is in a separate file. Other intervals are in a single file\"\"\"\n\n    chrms = chr_intervals()\n    names = []\n\n    with open(orig_file, \"r\") as ins:\n        counter = {}\n        for line in ins:\n            if line.startswith('@'):\n                continue\n            name = line.split()[0].lower()\n            if name in chrms:\n                if name in counter:\n                    counter[name] += 1\n                else:\n                    counter[name] = 0\n                suffix = \"\" if (counter[name] == 0) else \"_\" + str(counter[name])\n                create_file(line, name + suffix)\n                names.append(name + suffix)\n                prev = name\n            else:\n                name = others_name\n                if not name in names:\n                    names.append(name)\n                try:\n                    add_to_file(line, name)\n                except:\n                    raise Exception(\n                        \"Couldn't create or write in the file in mode 4\")\n\n    create_file(str(names), \"names\", extension=\".txt\")\n\n\ndef prepare_intervals():\n    # reading input files and split mode from command line\n    args = docopt(__doc__, version='1.0')\n\n    bed_file = args['--bed']\n    fai_file = args['--fai']\n    split_mode = int(args['--mode'])\n\n    # define file name for non-chromosomal contigs\n    others_name = 'others'\n\n    global formats, lformat\n    formats = [\"chr start end\", \"chr:start-end\"]\n    lformat = args['--format']\n    if lformat == None:\n        lformat = formats[0]\n    if not lformat in formats:\n        raise Exception('Unsuported interval format')\n\n    if not os.path.exists(r\"./Intervals\"):\n        os.mkdir(r\"./Intervals\")\n    else:\n        files = glob.glob(r\"./Intervals/*\")\n        for f in files:\n            os.remove(f)\n\n    # create variable input_file taking bed_file as priority\n    if bed_file:\n        input_file = bed_file\n    elif fai_file:\n        input_file = fai2bed(fai_file)\n    else:\n        raise Exception('No input files are provided')\n\n    # calling adequate split mode function\n    if split_mode == 1:\n        mode_1(input_file)\n    elif split_mode == 2:\n        mode_2(input_file, others_name)\n    elif split_mode == 3:\n        if bed_file:\n            mode_3(input_file)\n        else:\n            raise Exception('Bed file is required for mode 3')\n    elif split_mode == 4:\n        mode_4(input_file, others_name)\n    else:\n        raise Exception('Split mode value is not set')\n\n\ndef is_header(line):\n    x = line.split('\\t')\n    try:\n        int(x[1])\n        int(x[2])\n        header = False\n    except:\n        sys.stderr.write('Line is skipped: {}'.format(line))\n        header = True\n    return header\n\n\nif __name__ == '__main__':\n    prepare_intervals()",
                                "entryname": "sbg_prepare_intervals.py"
                            },
                            "$(inputs.fai_file)",
                            "$(inputs.bed_file)"
                        ]
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "Converters"
                ],
                "sbg:cmdPreview": "python sbg_prepare_intervals.py  --format \"chr start end\" --mode 2",
                "sbg:contributors": [
                    "bix-demo",
                    "vladimirk",
                    "medjo",
                    "nikola_jovanovic",
                    "teodora.aleksic",
                    "luka.topalovic",
                    "bogdang"
                ],
                "sbg:createdBy": "vladimirk",
                "sbg:id": "h-618c514d/h-d8806994/h-ec911b59/0",
                "sbg:image_url": null,
                "sbg:latestRevision": 15,
                "sbg:license": "Apache License 2.0",
                "sbg:project": "bix-demo/sbgtools-demo",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "check for header",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Seven Bridges Genomics",
                "sbg:toolkit": "SBGTools",
                "sbg:toolkitVersion": "1.0",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 985.0001612107014,
            "sbg:y": 658.4616348529505
        },
        {
            "id": "SBG_FASTA_Indices",
            "in": [
                {
                    "id": "reference",
                    "source": [
                        "SBG_Untar_fasta/output_fasta"
                    ]
                },
                {
                    "id": "memory_per_job"
                }
            ],
            "out": [
                {
                    "id": "fasta_reference"
                },
                {
                    "id": "fasta_index"
                },
                {
                    "id": "fasta_dict"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 1,
                        "prefix": "&&",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    memory = '2048'\n    if (inputs.memory_per_job) {\n        memory = inputs.memory_per_job\n    }\n    filename = inputs.reference.path.split('/').pop()\n    basename = filename.split('.')\n    if (filename.endsWith('.gz')) {\n        basename.pop()\n    }\n    basename.pop()\n    name = basename.join('.')\n    return 'java -Xmx' + memory + 'M -jar /opt/picard.jar CreateSequenceDictionary R=' + inputs.reference.path + ' O=' + name + '.dict'\n}"
                    }
                ],
                "baseCommand": [
                    "samtools",
                    "faidx"
                ],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Tool allows creating FASTA dictionary and index simultaneously which is necessary for running GATK tools. This version of tool for indexing uses SAMtools faidx command (toolkit version0.1.19), while for the FASTA dictionary is used Picard CreateFastaDictionary (toolkit version 1.140)",
                "hints": [],
                "id": "bix-demo/sbgtools-demo/sbg-fasta-indices/12",
                "inputs": {
                    "memory_per_job": {
                        "doc": "Memory in megabytes required for each execution of the tool.",
                        "label": "Memory per job",
                        "sbg:category": "Execution",
                        "sbg:toolDefaultValue": "2048",
                        "type": "int?"
                    },
                    "reference": {
                        "doc": "FASTA file to be indexed",
                        "inputBinding": {
                            "position": 0,
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "FASTA file",
                        "sbg:category": "Input files",
                        "sbg:fileTypes": "FASTA,FA,FA.GZ,FASTA.GZ",
                        "type": "File"
                    }
                },
                "label": "SBG FASTA Indices",
                "outputs": {
                    "fasta_dict": {
                        "label": "FASTA Dictionary",
                        "outputBinding": {
                            "glob": "*.dict"
                        },
                        "sbg:fileTypes": "DICT",
                        "type": "File?"
                    },
                    "fasta_index": {
                        "label": "FASTA Index",
                        "outputBinding": {
                            "glob": "*.fai"
                        },
                        "sbg:fileTypes": "FAI",
                        "type": "File?"
                    },
                    "fasta_reference": {
                        "label": "Reference",
                        "outputBinding": {
                            "glob": "${\n    return inputs.reference.path.split('/').pop()\n}",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.reference)\n\n}"
                        },
                        "sbg:fileTypes": "FASTA",
                        "secondaryFiles": [
                            ".fai",
                            "^.dict",
                            "^^.dict"
                        ],
                        "type": "File?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "b177f5bd06db",
                        "dockerPull": "images.sbgenomics.com/nikola_jovanovic/samtoolspicard:1.0"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) return inputs.memory_per_job + 500\n    else return 2548\n}"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": [
                            "$(inputs.reference)"
                        ]
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "Indexing"
                ],
                "sbg:cmdPreview": "samtools faidx  /path/to/reference.fa.gz && java -Xmx10M -jar /opt/picard.jar CreateSequenceDictionary R=/path/to/reference.fa.gz O=reference.dict",
                "sbg:contributors": [
                    "bix-demo",
                    "vladimirk",
                    "markop",
                    "nikola_jovanovic"
                ],
                "sbg:createdBy": "bix-demo",
                "sbg:id": "admin/sbg-public-data/sbg-fasta-indices/19",
                "sbg:image_url": null,
                "sbg:latestRevision": 12,
                "sbg:license": "Apache License 2.0",
                "sbg:project": "bix-demo/sbgtools-demo",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "rev 9: Added secondary .dict support",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Sanja Mijalkovic, Seven Bridges Genomics, <sanja.mijalkovic@sbgenomics.com>",
                "sbg:toolkit": "SBGTools",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 373.33346019851314,
            "sbg:y": -130.66664127508696
        },
        {
            "id": "FastQC",
            "in": [
                {
                    "id": "threads"
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "nogroup"
                },
                {
                    "id": "nano"
                },
                {
                    "id": "memory_per_job"
                },
                {
                    "id": "limits_file"
                },
                {
                    "id": "kmers"
                },
                {
                    "id": "input_fastq",
                    "source": [
                        "fastq"
                    ]
                },
                {
                    "id": "format"
                },
                {
                    "id": "cpus_per_job"
                },
                {
                    "id": "contaminants_file"
                },
                {
                    "id": "casava"
                },
                {
                    "id": "adapters_file"
                }
            ],
            "out": [
                {
                    "id": "report_zip"
                },
                {
                    "id": "report_html"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "prefix": "",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "--noextract"
                    },
                    {
                        "position": 0,
                        "prefix": "--outdir",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "."
                    }
                ],
                "baseCommand": [
                    "fastqc"
                ],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "FastQC reads a set of sequence files and produces a quality control (QC) report from each one. These reports consist of a number of different modules, each of which will help identify a different type of potential problem in your data. \n\nSince it's necessary to convert the tool report in order to show them on Seven Bridges platform, it's recommended to use [FastQC Analysis workflow instead](https://igor.sbgenomics.com/public/apps#admin/sbg-public-data/fastqc-analysis/). \n\nFastQC is a tool which takes a FASTQ file and runs a series of tests on it to generate a comprehensive QC report.  This report will tell you if there is anything unusual about your sequence.  Each test is flagged as a pass, warning, or fail depending on how far it departs from what you would expect from a normal large dataset with no significant biases.  It is important to stress that warnings or even failures do not necessarily mean that there is a problem with your data, only that it is unusual.  It is possible that the biological nature of your sample means that you would expect this particular bias in your results.",
                "hints": [],
                "id": "bix-demo/fastqc-0-11-4-demo/fastqc-0-11-4/11",
                "inputs": {
                    "adapters_file": {
                        "doc": "Specifies a non-default file which contains the list of adapter sequences which will be explicity searched against the library. The file must contain sets of named adapters in the form name[tab]sequence.  Lines prefixed with a hash will be ignored.",
                        "inputBinding": {
                            "position": 0,
                            "prefix": "--adapters",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Adapters",
                        "sbg:altPrefix": "-a",
                        "sbg:category": "File inputs",
                        "sbg:fileTypes": "TXT",
                        "type": "File?"
                    },
                    "casava": {
                        "doc": "Files come from raw casava output. Files in the same sample group (differing only by the group number) will be analysed as a set rather than individually. Sequences with the filter flag set in the header will be excluded from the analysis. Files must have the same names given to them by casava (including being gzipped and ending with .gz) otherwise they won't be grouped together correctly.",
                        "inputBinding": {
                            "position": 0,
                            "prefix": "--casava",
                            "separate": false,
                            "shellQuote": false
                        },
                        "label": "Casava",
                        "sbg:category": "Options",
                        "type": "boolean?"
                    },
                    "contaminants_file": {
                        "doc": "Specifies a non-default file which contains the list of contaminants to screen overrepresented sequences against. The file must contain sets of named contaminants in the form name[tab]sequence.  Lines prefixed with a hash will be ignored.",
                        "inputBinding": {
                            "position": 0,
                            "prefix": "--contaminants",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Contaminants",
                        "sbg:altPrefix": "-c",
                        "sbg:category": "File inputs",
                        "sbg:fileTypes": "TXT",
                        "type": "File?"
                    },
                    "cpus_per_job": {
                        "doc": "Number of CPUs to be allocated per execution of FastQC.",
                        "label": "Number of CPUs.",
                        "sbg:category": "Execution parameters",
                        "sbg:toolDefaultValue": "Determined by the number of input files",
                        "type": "int?"
                    },
                    "format": {
                        "doc": "Bypasses the normal sequence file format detection and forces the program to use the specified format.  Valid formats are BAM, SAM, BAM_mapped, SAM_mapped and FASTQ.",
                        "inputBinding": {
                            "position": 0,
                            "prefix": "--format",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Format",
                        "sbg:altPrefix": "-f",
                        "sbg:category": "Options",
                        "sbg:toolDefaultValue": "FASTQ",
                        "type": [
                            "null",
                            {
                                "name": "format",
                                "symbols": [
                                    "bam",
                                    "sam",
                                    "bam_mapped",
                                    "sam_mapped",
                                    "fastq"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "input_fastq": {
                        "doc": "Input file.",
                        "inputBinding": {
                            "position": 100,
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Input file",
                        "sbg:category": "File inputs",
                        "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ, BAM, SAM",
                        "type": "File[]"
                    },
                    "kmers": {
                        "doc": "Specifies the length of Kmer to look for in the Kmer content module. Specified Kmer length must be between 2 and 10. Default length is 7 if not specified.",
                        "inputBinding": {
                            "position": 0,
                            "prefix": "--kmers",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Kmers",
                        "sbg:altPrefix": "-f",
                        "sbg:category": "Options",
                        "sbg:toolDefaultValue": "7",
                        "type": "int?"
                    },
                    "limits_file": {
                        "doc": "Specifies a non-default file which contains a set of criteria which will be used to determine the warn/error limits for the various modules.  This file can also be used to selectively remove some modules from the output all together.  The format needs to mirror the default limits.txt file found in the Configuration folder.",
                        "inputBinding": {
                            "position": 0,
                            "prefix": "--limits",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Limits",
                        "sbg:altPrefix": "-l",
                        "sbg:category": "File inputs",
                        "sbg:fileTypes": "TXT",
                        "type": "File?"
                    },
                    "memory_per_job": {
                        "doc": "Amount of memory allocated per execution of FastQC job.",
                        "label": "Amount of memory allocated per job execution.",
                        "sbg:category": "Execution parameters",
                        "sbg:toolDefaultValue": "Determined by the number of input files",
                        "type": "int?"
                    },
                    "nano": {
                        "doc": "Files come from naopore sequences and are in fast5 format. In this mode you can pass in directories to process and the program will take in all fast5 files within those directories and produce a single output file from the sequences found in all files.",
                        "inputBinding": {
                            "position": 0,
                            "prefix": "--nano",
                            "separate": false,
                            "shellQuote": false
                        },
                        "label": "Nano",
                        "sbg:category": "Options",
                        "type": "boolean?"
                    },
                    "nogroup": {
                        "doc": "Disable grouping of bases for reads >50bp. All reports will show data for every base in the read.  WARNING: Using this option will cause fastqc to crash and burn if you use it on really long reads, and your plots may end up a ridiculous size. You have been warned.",
                        "inputBinding": {
                            "position": 0,
                            "prefix": "--nogroup",
                            "separate": false,
                            "shellQuote": false
                        },
                        "label": "Nogroup",
                        "sbg:category": "Options",
                        "type": "boolean?"
                    },
                    "quiet": {
                        "doc": "Supress all progress messages on stdout and only report errors.",
                        "inputBinding": {
                            "position": 0,
                            "prefix": "--quiet",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:altPrefix": "-q",
                        "sbg:category": "Options",
                        "type": "boolean?"
                    },
                    "threads": {
                        "doc": "Specifies the number of files which can be processed simultaneously.  Each thread will be allocated 250MB of memory so you shouldn't run more threads than your available memory will cope with, and not more than 6 threads on a 32 bit machine.",
                        "inputBinding": {
                            "position": 0,
                            "prefix": "--threads",
                            "separate": true,
                            "shellQuote": false,
                            "valueFrom": "${\n    //if \"threads\" is not specified\n    //number of threads is determined based on number of inputs\n    if (!inputs.threads) {\n        inputs.threads = [].concat(inputs.input_fastq).length\n    }\n    return Math.min(inputs.threads, 7)\n}"
                        },
                        "label": "Threads",
                        "sbg:altPrefix": "-t",
                        "sbg:category": "Options",
                        "sbg:toolDefaultValue": "1",
                        "type": "int?"
                    }
                },
                "label": "FastQC",
                "outputs": {
                    "report_html": {
                        "doc": "FastQC reports in HTML format.",
                        "label": "Report HTMLs",
                        "outputBinding": {
                            "glob": "*.html",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.input_fastq)\n\n}"
                        },
                        "sbg:fileTypes": "HTML",
                        "type": "File[]?"
                    },
                    "report_zip": {
                        "doc": "Zip archive of the report.",
                        "label": "Report zip",
                        "outputBinding": {
                            "glob": "*_fastqc.zip",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.input_fastq)\n\n}"
                        },
                        "sbg:fileTypes": "ZIP",
                        "type": "File[]?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "759c4c8fbafd",
                        "dockerPull": "images.sbgenomics.com/mladenlsbg/fastqc:0.11.4"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": "${\n    // if cpus_per_job is set, it takes precedence\n    if (inputs.cpus_per_job) {\n        return inputs.cpus_per_job\n    }\n    // if threads parameter is set, the number of CPUs is set based on that parametere\n    else if (inputs.threads) {\n        return inputs.threads\n    }\n    // else the number of CPUs is determined by the number of input files, up to 7 -- default\n    else return Math.min([].concat(inputs.input_fastq).length, 7)\n}",
                        "ramMin": "${\n    // if memory_per_job is set, it takes precedence\n    if (inputs.memory_per_job) {\n        return inputs.memory_per_job\n    }\n    // if threads parameter is set, memory req is set based on the number of threads\n    else if (inputs.threads) {\n        return 1024 + 300 * inputs.threads\n    }\n    // else the memory req is determined by the number of input files, up to 7 -- default\n    else return (1024 + 300 * Math.min([].concat(inputs.input_fastq).length, 7))\n}"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": []
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "FASTQ-Processing",
                    "Quality-Control",
                    "Quantification"
                ],
                "sbg:cmdPreview": "fastqc  --noextract --outdir .  /path/to/input_fastq-1.fastq  /path/to/input_fastq-2.fastq",
                "sbg:contributors": [
                    "bix-demo",
                    "mladenlSBG",
                    "nikola_jovanovic"
                ],
                "sbg:createdBy": "bix-demo",
                "sbg:id": "admin/sbg-public-data/fastqc-0-11-4/19",
                "sbg:image_url": null,
                "sbg:latestRevision": 11,
                "sbg:license": "GNU General Public License v3.0 only",
                "sbg:links": [
                    {
                        "id": "http://www.bioinformatics.babraham.ac.uk/projects/fastqc/",
                        "label": "Homepage"
                    },
                    {
                        "id": "http://www.bioinformatics.babraham.ac.uk/projects/fastqc/fastqc_v0.11.4_source.zip",
                        "label": "Source Code"
                    },
                    {
                        "id": "https://wiki.hpcc.msu.edu/display/Bioinfo/FastQC+Tutorial",
                        "label": "Wiki"
                    },
                    {
                        "id": "http://www.bioinformatics.babraham.ac.uk/projects/fastqc/fastqc_v0.11.4.zip",
                        "label": "Download"
                    },
                    {
                        "id": "http://www.bioinformatics.babraham.ac.uk/projects/fastqc",
                        "label": "Publication"
                    }
                ],
                "sbg:project": "bix-demo/fastqc-0-11-4-demo",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "HTML output added.",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Babraham Institute",
                "sbg:toolkit": "FastQC",
                "sbg:toolkitVersion": "0.11.4",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 115.66668864091304,
            "sbg:y": 420.0000894202157
        },
        {
            "id": "GATK_MergeVcfs_1",
            "in": [
                {
                    "id": "verbosity"
                },
                {
                    "id": "validation_stringency"
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "reference"
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "memory_per_job"
                },
                {
                    "id": "memory_overhead_per_job"
                },
                {
                    "id": "max_records_in_ram"
                },
                {
                    "id": "input",
                    "source": [
                        "GATK_HaplotypeCaller/output_vcf"
                    ]
                },
                {
                    "id": "create_md5_file"
                },
                {
                    "id": "create_index"
                },
                {
                    "id": "compression_level"
                },
                {
                    "default": true,
                    "id": "clip_intervals"
                }
            ],
            "out": [
                {
                    "id": "output"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "MergeVcfs"
                    },
                    {
                        "position": 4,
                        "prefix": "--OUTPUT",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    function find_prefix(variants) {\n        var prefix = ''\n        var first = variants[0].path.replace(/^.*[\\\\\\/]/, '')\n\n        // Finds longest common prefix between variant names\n        for (var i = 1; i < variants.length; ++i) {\n            var j = 0;\n            var current = variants[i].path.replace(/^.*[\\\\\\/]/, '')\n\n            while (first[j] == current[j] &&\n                j < (first.length - 1) &&\n                j < (current.length - 1)) ++j\n\n            // Inits prefixs or shortens it\n            if (i == 1 || prefix.length > j)\n                prefix = first.slice(0, j)\n        }\n\n        // Clips trailing characters\n        while (prefix.endsWith('.') || prefix.endsWith('_') || prefix.endsWith('-'))\n            prefix = prefix.slice(0, prefix.length - 1)\n\n        return prefix\n    }\n\n\n    var variants = [].concat(inputs.input)\n\n    if (inputs.clip_intervals && variants.length > 1) {\n        var first = variants[0].path.replace(/^.*[\\\\\\/]/, '')\n\n        var extensions = ''\n\n        if (first.endsWith('.g.vcf'))\n            extensions = '.g.vcf'\n        else if (first.endsWith('.vcf'))\n            extensions = '.vcf'\n        else if (first.endsWith('.g.vcf.gz'))\n            extensions = '.g.vcf.gz'\n        else if (first.endsWith('.vcf.gz'))\n            extensions = '.vcf.gz'\n\n        var prefix = find_prefix(variants)\n\n        if (prefix.length > 0)\n            return prefix + extensions\n        else\n            return variants[0].path.replace(/^.*[\\\\\\/]/, '')\n    } else\n        return variants[0].path.replace(/^.*[\\\\\\/]/, '')\n}"
                    },
                    {
                        "position": 4,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    inputs = inputs.input\n\n    cmd = []\n\n    for (i = 0; i < inputs.length; i++) {\n        cmd.push('--INPUT', inputs[i].path)\n    }\n\n    return cmd.join(' ')\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Merges multiple VCF files into one VCF file. Input files must be sorted by their contigs and, within contigs, by start position. The input files must have the same sample and contig lists. An index file is created and a sequence dictionary is required by default.",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-mergevcfs/15",
                "inputs": {
                    "clip_intervals": {
                        "doc": "Clip intervals name from output file name",
                        "label": "Clip Intervals",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "compression_level": {
                        "doc": "Compression level for all compressed files created (e.g. BAM and GELI). Default value: 5.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--COMPRESSION_LEVEL",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Compression Level",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "5",
                        "type": "int?"
                    },
                    "create_index": {
                        "doc": "Whether to create a BAM index when writing a coordinate-sorted BAM file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--CREATE_INDEX",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Index",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "true",
                        "type": "boolean?"
                    },
                    "create_md5_file": {
                        "doc": "Whether to create an MD5 digest for any BAM or FASTQ files created. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--CREATE_MD5_FILE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Md5 File",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "input": {
                        "doc": "VCF input files File format is determined by file extension. This argument must be specified at least once. Required.",
                        "label": "Input",
                        "sbg:altPrefix": "-I",
                        "sbg:category": "Required Arguments",
                        "type": "File[]"
                    },
                    "max_records_in_ram": {
                        "doc": "When writing SAM files that need to be sorted, this will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort a SAM file, and increases the amount of RAM needed. Default value: 500000.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--MAX_RECORDS_IN_RAM",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Records In Ram",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "500000",
                        "type": "int?"
                    },
                    "memory_overhead_per_job": {
                        "doc": "Memory overhead per job.",
                        "label": "Memory overhead per jobin MB",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "doc": "Memory per job in MB.",
                        "label": "Memory per job in MB",
                        "sbg:category": "Execution",
                        "sbg:toolDefaultValue": "2048",
                        "type": "int?"
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--QUIET",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "reference": {
                        "doc": "Reference sequence file. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--REFERENCE_SEQUENCE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reference",
                        "sbg:category": "Optional Arguments",
                        "secondaryFiles": [
                            ".fai",
                            "^.dict"
                        ],
                        "type": "File?"
                    },
                    "use_jdk_deflater": {
                        "doc": "Whether to use the JdkDeflater (as opposed to IntelDeflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--USE_JDK_DEFLATER",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Whether to use the JdkInflater (as opposed to IntelInflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--USE_JDK_INFLATER",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "validation_stringency": {
                        "doc": "Validation stringency for all SAM files read by this program. Setting stringency to SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: STRICT. Possible values: {STRICT, LENIENT, SILENT}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--VALIDATION_STRINGENCY",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Validation Stringency",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "STRICT",
                        "type": [
                            "null",
                            {
                                "name": "validation_stringency",
                                "symbols": [
                                    "STRICT",
                                    "LENIENT",
                                    "SILENT"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--VERBOSITY",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "INFO",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "GATK MergeVcfs",
                "outputs": {
                    "output": {
                        "doc": "The merged VCF file. File format is determined by file extension.",
                        "label": "The merged VCF file.",
                        "outputBinding": {
                            "glob": "${\n    inputs = [].concat(inputs.input)\n\n    if (inputs[0].path.endsWith('.gz'))\n        return '*.vcf.gz'\n    else\n        return '*.vcf'\n}",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.input)\n\n}"
                        },
                        "sbg:fileTypes": "VCF",
                        "type": "File?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        if (inputs.memory_overhead_per_job) {\n            return inputs.memory_per_job + inputs.memory_overhead_per_job\n        } else\n            return inputs.memory_per_job\n    } else if (!inputs.memory_per_job && inputs.memory_overhead_per_job) {\n        return 2048 + inputs.memory_overhead_per_job\n    } else\n        return 2048\n}"
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": []
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk --java-options \"-Xmx1M\" MergeVcfs --OUTPUT input-1.vcf  --INPUT /path/to/input-1.vcf --INPUT /path/to/input-2.vcf --INPUT /path/to/input-3.vcf",
                "sbg:contributors": [
                    "teodora.aleksic",
                    "vladimirk"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-mergevcfs/31",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-mergevcfs/15",
                "sbg:image_url": null,
                "sbg:latestRevision": 15,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-mergevcfs/31",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 1701.9638875893365,
            "sbg:y": 442.14276546878887
        },
        {
            "id": "GATK_MergeVcfs",
            "in": [
                {
                    "id": "verbosity"
                },
                {
                    "id": "validation_stringency"
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "reference"
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "memory_per_job"
                },
                {
                    "id": "memory_overhead_per_job"
                },
                {
                    "id": "max_records_in_ram"
                },
                {
                    "id": "input",
                    "source": [
                        "GATK_GenotypeGVCFs/vcf"
                    ]
                },
                {
                    "id": "create_md5_file"
                },
                {
                    "id": "create_index"
                },
                {
                    "id": "compression_level"
                },
                {
                    "default": true,
                    "id": "clip_intervals"
                }
            ],
            "out": [
                {
                    "id": "output"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "MergeVcfs"
                    },
                    {
                        "position": 4,
                        "prefix": "--OUTPUT",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    function find_prefix(variants) {\n        var prefix = ''\n        var first = variants[0].path.replace(/^.*[\\\\\\/]/, '')\n\n        // Finds longest common prefix between variant names\n        for (var i = 1; i < variants.length; ++i) {\n            var j = 0;\n            var current = variants[i].path.replace(/^.*[\\\\\\/]/, '')\n\n            while (first[j] == current[j] &&\n                j < (first.length - 1) &&\n                j < (current.length - 1)) ++j\n\n            // Inits prefixs or shortens it\n            if (i == 1 || prefix.length > j)\n                prefix = first.slice(0, j)\n        }\n\n        // Clips trailing characters\n        while (prefix.endsWith('.') || prefix.endsWith('_') || prefix.endsWith('-'))\n            prefix = prefix.slice(0, prefix.length - 1)\n\n        return prefix\n    }\n\n\n    var variants = [].concat(inputs.input)\n\n    if (inputs.clip_intervals && variants.length > 1) {\n        var first = variants[0].path.replace(/^.*[\\\\\\/]/, '')\n\n        var extensions = ''\n\n        if (first.endsWith('.g.vcf'))\n            extensions = '.g.vcf'\n        else if (first.endsWith('.vcf'))\n            extensions = '.vcf'\n        else if (first.endsWith('.g.vcf.gz'))\n            extensions = '.g.vcf.gz'\n        else if (first.endsWith('.vcf.gz'))\n            extensions = '.vcf.gz'\n\n        var prefix = find_prefix(variants)\n\n        if (prefix.length > 0)\n            return prefix + extensions\n        else\n            return variants[0].path.replace(/^.*[\\\\\\/]/, '')\n    } else\n        return variants[0].path.replace(/^.*[\\\\\\/]/, '')\n}"
                    },
                    {
                        "position": 4,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    inputs = inputs.input\n\n    cmd = []\n\n    for (i = 0; i < inputs.length; i++) {\n        cmd.push('--INPUT', inputs[i].path)\n    }\n\n    return cmd.join(' ')\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Merges multiple VCF files into one VCF file. Input files must be sorted by their contigs and, within contigs, by start position. The input files must have the same sample and contig lists. An index file is created and a sequence dictionary is required by default.",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-mergevcfs/15",
                "inputs": {
                    "clip_intervals": {
                        "doc": "Clip intervals name from output file name",
                        "label": "Clip Intervals",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "compression_level": {
                        "doc": "Compression level for all compressed files created (e.g. BAM and GELI). Default value: 5.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--COMPRESSION_LEVEL",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Compression Level",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "5",
                        "type": "int?"
                    },
                    "create_index": {
                        "doc": "Whether to create a BAM index when writing a coordinate-sorted BAM file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--CREATE_INDEX",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Index",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "true",
                        "type": "boolean?"
                    },
                    "create_md5_file": {
                        "doc": "Whether to create an MD5 digest for any BAM or FASTQ files created. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--CREATE_MD5_FILE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Md5 File",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "input": {
                        "doc": "VCF input files File format is determined by file extension. This argument must be specified at least once. Required.",
                        "label": "Input",
                        "sbg:altPrefix": "-I",
                        "sbg:category": "Required Arguments",
                        "type": "File[]"
                    },
                    "max_records_in_ram": {
                        "doc": "When writing SAM files that need to be sorted, this will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort a SAM file, and increases the amount of RAM needed. Default value: 500000.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--MAX_RECORDS_IN_RAM",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Records In Ram",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "500000",
                        "type": "int?"
                    },
                    "memory_overhead_per_job": {
                        "doc": "Memory overhead per job.",
                        "label": "Memory overhead per jobin MB",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "doc": "Memory per job in MB.",
                        "label": "Memory per job in MB",
                        "sbg:category": "Execution",
                        "sbg:toolDefaultValue": "2048",
                        "type": "int?"
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--QUIET",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "reference": {
                        "doc": "Reference sequence file. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--REFERENCE_SEQUENCE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reference",
                        "sbg:category": "Optional Arguments",
                        "secondaryFiles": [
                            ".fai",
                            "^.dict"
                        ],
                        "type": "File?"
                    },
                    "use_jdk_deflater": {
                        "doc": "Whether to use the JdkDeflater (as opposed to IntelDeflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--USE_JDK_DEFLATER",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Whether to use the JdkInflater (as opposed to IntelInflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--USE_JDK_INFLATER",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "validation_stringency": {
                        "doc": "Validation stringency for all SAM files read by this program. Setting stringency to SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: STRICT. Possible values: {STRICT, LENIENT, SILENT}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--VALIDATION_STRINGENCY",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Validation Stringency",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "STRICT",
                        "type": [
                            "null",
                            {
                                "name": "validation_stringency",
                                "symbols": [
                                    "STRICT",
                                    "LENIENT",
                                    "SILENT"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--VERBOSITY",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "INFO",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "GATK MergeVcfs",
                "outputs": {
                    "output": {
                        "doc": "The merged VCF file. File format is determined by file extension.",
                        "label": "The merged VCF file.",
                        "outputBinding": {
                            "glob": "${\n    inputs = [].concat(inputs.input)\n\n    if (inputs[0].path.endsWith('.gz'))\n        return '*.vcf.gz'\n    else\n        return '*.vcf'\n}",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.input)\n\n}"
                        },
                        "sbg:fileTypes": "VCF",
                        "type": "File?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        if (inputs.memory_overhead_per_job) {\n            return inputs.memory_per_job + inputs.memory_overhead_per_job\n        } else\n            return inputs.memory_per_job\n    } else if (!inputs.memory_per_job && inputs.memory_overhead_per_job) {\n        return 2048 + inputs.memory_overhead_per_job\n    } else\n        return 2048\n}"
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": []
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk --java-options \"-Xmx1M\" MergeVcfs --OUTPUT input-1.vcf  --INPUT /path/to/input-1.vcf --INPUT /path/to/input-2.vcf --INPUT /path/to/input-3.vcf",
                "sbg:contributors": [
                    "teodora.aleksic",
                    "vladimirk"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-mergevcfs/31",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-mergevcfs/15",
                "sbg:image_url": null,
                "sbg:latestRevision": 15,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-mergevcfs/31",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 1900.130568668466,
            "sbg:y": 220.63094443603117
        },
        {
            "id": "SBG_Pair_FASTQs_by_Metadata",
            "in": [
                {
                    "id": "fastq_list",
                    "source": [
                        "SBG_FASTQ_Quality_Adjuster/result"
                    ]
                }
            ],
            "out": [
                {
                    "id": "tuple_list"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "'Pairing"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "FASTQs!'"
                    }
                ],
                "baseCommand": [
                    "echo"
                ],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Tool accepts list of FASTQ files groups them into separate lists. This grouping is done using metadata values and their hierarchy (Sample ID > Library ID > Platform unit ID > File segment number) which should create unique combinations for each pair of FASTQ files. Important metadata fields are Sample ID, Library ID, Platform unit ID and File segment number. Not all of these four metadata fields are required, but the present set has to be sufficient to create unique combinations for each pair of FASTQ files. Files with no paired end metadata are grouped in the same way as the ones with paired end metadata, generally they should be alone in a separate list. Files with no metadata set will be grouped together. \n\nIf there are more than two files in a group, this might create errors further down most pipelines and the user should check if the metadata fields for those files are set properly.",
                "hints": [],
                "id": "bix-demo/sbgtools-demo/sbg-pair-fastqs-by-metadata/12",
                "inputs": {
                    "fastq_list": {
                        "doc": "List of the FASTQ files with properly set metadata fileds.",
                        "label": "List of FASTQ files",
                        "sbg:fileTypes": "FASTQ, FQ, FASTQ.GZ, FQ.GZ",
                        "type": "File[]"
                    }
                },
                "label": "SBG Pair FASTQs by Metadata",
                "outputs": {
                    "tuple_list": {
                        "doc": "List of grouped FASTQ files by metadata fields.",
                        "label": "List of grouped FASTQ files",
                        "outputBinding": {
                            "outputEval": "${\n    function get_meta_map(m, file, meta) {\n        if (meta in file.metadata) {\n            return m[file.metadata[meta]]\n        } else {\n            return m['Undefined']\n        }\n    }\n\n    function create_new_map(map, file, meta) {\n        if (meta in file.metadata) {\n            map[file.metadata[meta]] = {}\n            return map[file.metadata[meta]]\n        } else {\n            map['Undefined'] = {}\n            return map['Undefined']\n        }\n    }\n\n    arr = [].concat(inputs.fastq_list)\n    map = {}\n\n    for (i in arr) {\n\n        sm_map = get_meta_map(map, arr[i], 'sample_id')\n        if (!sm_map) sm_map = create_new_map(map, arr[i], 'sample_id')\n\n        lb_map = get_meta_map(sm_map, arr[i], 'library_id')\n        if (!lb_map) lb_map = create_new_map(sm_map, arr[i], 'library_id')\n\n        pu_map = get_meta_map(lb_map, arr[i], 'platform_unit_id')\n        if (!pu_map) pu_map = create_new_map(lb_map, arr[i], 'platform_unit_id')\n\n        if ('file_segment_number' in arr[i].metadata) {\n            if (pu_map[arr[i].metadata['file_segment_number']]) {\n                a = pu_map[arr[i].metadata['file_segment_number']]\n                ar = [].concat(a)\n                ar = ar.concat(arr[i])\n                pu_map[arr[i].metadata['file_segment_number']] = ar\n            } else pu_map[arr[i].metadata['file_segment_number']] = [].concat(arr[i])\n        } else {\n            if (pu_map['Undefined']) {\n                a = pu_map['Undefined']\n                ar = [].concat(a)\n                ar = ar.concat(arr[i])\n                pu_map['Undefined'] = ar\n            } else {\n                pu_map['Undefined'] = [].concat(arr[i])\n            }\n        }\n    }\n    tuple_list = []\n    for (sm in map)\n        for (lb in map[sm])\n            for (pu in map[sm][lb]) {\n                for (fsm in map[sm][lb][pu]) {\n                    list = map[sm][lb][pu][fsm]\n                    tuple_list.push(list)\n                }\n            }\n    return tuple_list\n}"
                        },
                        "sbg:fileTypes": "FASTQ,FQ,FASTQ.GZ,FQ.GZ",
                        "type": "File[]?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "d41a0837ab81",
                        "dockerPull": "images.sbgenomics.com/nikola_jovanovic/alpine:1"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": 1024
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": [
                            "$(inputs.fastq_list)"
                        ]
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "Converters",
                    "Other"
                ],
                "sbg:cmdPreview": "echo 'Pairing FASTQs!'",
                "sbg:contributors": [
                    "bix-demo",
                    "vladimirk",
                    "markop",
                    "nikola_jovanovic"
                ],
                "sbg:createdBy": "bix-demo",
                "sbg:id": "admin/sbg-public-data/sbg-pair-fastqs-by-metadata/14",
                "sbg:image_url": null,
                "sbg:latestRevision": 12,
                "sbg:license": "Apache License 2.0",
                "sbg:project": "bix-demo/sbgtools-demo",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Changed docker image to images.sbgenomics.com.",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "",
                "sbg:toolkit": "SBGTools",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 163.58977860670942,
            "sbg:y": 199.48723191481605
        },
        {
            "id": "GATK_MergeVcfs_2",
            "in": [
                {
                    "id": "verbosity"
                },
                {
                    "id": "validation_stringency"
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "reference"
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "memory_per_job"
                },
                {
                    "id": "memory_overhead_per_job"
                },
                {
                    "id": "max_records_in_ram"
                },
                {
                    "id": "input",
                    "source": [
                        "INDEL_GATK_VariantFiltration/filtered_vcf",
                        "SNP_GATK_VariantFiltration/filtered_vcf"
                    ]
                },
                {
                    "id": "create_md5_file"
                },
                {
                    "id": "create_index"
                },
                {
                    "id": "compression_level"
                },
                {
                    "id": "clip_intervals"
                }
            ],
            "out": [
                {
                    "id": "output"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "MergeVcfs"
                    },
                    {
                        "position": 4,
                        "prefix": "--OUTPUT",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    function find_prefix(variants) {\n        var prefix = ''\n        var first = variants[0].path.replace(/^.*[\\\\\\/]/, '')\n\n        // Finds longest common prefix between variant names\n        for (var i = 1; i < variants.length; ++i) {\n            var j = 0;\n            var current = variants[i].path.replace(/^.*[\\\\\\/]/, '')\n\n            while (first[j] == current[j] &&\n                j < (first.length - 1) &&\n                j < (current.length - 1)) ++j\n\n            // Inits prefixs or shortens it\n            if (i == 1 || prefix.length > j)\n                prefix = first.slice(0, j)\n        }\n\n        // Clips trailing characters\n        while (prefix.endsWith('.') || prefix.endsWith('_') || prefix.endsWith('-'))\n            prefix = prefix.slice(0, prefix.length - 1)\n\n        return prefix\n    }\n\n\n    var variants = [].concat(inputs.input)\n\n    if (inputs.clip_intervals && variants.length > 1) {\n        var first = variants[0].path.replace(/^.*[\\\\\\/]/, '')\n\n        var extensions = ''\n\n        if (first.endsWith('.g.vcf'))\n            extensions = '.g.vcf'\n        else if (first.endsWith('.vcf'))\n            extensions = '.vcf'\n        else if (first.endsWith('.g.vcf.gz'))\n            extensions = '.g.vcf.gz'\n        else if (first.endsWith('.vcf.gz'))\n            extensions = '.vcf.gz'\n\n        var prefix = find_prefix(variants)\n\n        if (prefix.length > 0)\n            return prefix + extensions\n        else\n            return variants[0].path.replace(/^.*[\\\\\\/]/, '')\n    } else\n        return variants[0].path.replace(/^.*[\\\\\\/]/, '')\n}"
                    },
                    {
                        "position": 4,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    inputs = inputs.input\n\n    cmd = []\n\n    for (i = 0; i < inputs.length; i++) {\n        cmd.push('--INPUT', inputs[i].path)\n    }\n\n    return cmd.join(' ')\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Merges multiple VCF files into one VCF file. Input files must be sorted by their contigs and, within contigs, by start position. The input files must have the same sample and contig lists. An index file is created and a sequence dictionary is required by default.",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-mergevcfs/15",
                "inputs": {
                    "clip_intervals": {
                        "doc": "Clip intervals name from output file name",
                        "label": "Clip Intervals",
                        "sbg:category": "Optional Arguments",
                        "type": "boolean?"
                    },
                    "compression_level": {
                        "doc": "Compression level for all compressed files created (e.g. BAM and GELI). Default value: 5.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--COMPRESSION_LEVEL",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Compression Level",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "5",
                        "type": "int?"
                    },
                    "create_index": {
                        "doc": "Whether to create a BAM index when writing a coordinate-sorted BAM file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--CREATE_INDEX",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Index",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "true",
                        "type": "boolean?"
                    },
                    "create_md5_file": {
                        "doc": "Whether to create an MD5 digest for any BAM or FASTQ files created. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--CREATE_MD5_FILE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Md5 File",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "input": {
                        "doc": "VCF input files File format is determined by file extension. This argument must be specified at least once. Required.",
                        "label": "Input",
                        "sbg:altPrefix": "-I",
                        "sbg:category": "Required Arguments",
                        "type": "File[]"
                    },
                    "max_records_in_ram": {
                        "doc": "When writing SAM files that need to be sorted, this will specify the number of records stored in RAM before spilling to disk. Increasing this number reduces the number of file handles needed to sort a SAM file, and increases the amount of RAM needed. Default value: 500000.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--MAX_RECORDS_IN_RAM",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Records In Ram",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "500000",
                        "type": "int?"
                    },
                    "memory_overhead_per_job": {
                        "doc": "Memory overhead per job.",
                        "label": "Memory overhead per jobin MB",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "doc": "Memory per job in MB.",
                        "label": "Memory per job in MB",
                        "sbg:category": "Execution",
                        "sbg:toolDefaultValue": "2048",
                        "type": "int?"
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--QUIET",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "reference": {
                        "doc": "Reference sequence file. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--REFERENCE_SEQUENCE",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reference",
                        "sbg:category": "Optional Arguments",
                        "secondaryFiles": [
                            ".fai",
                            "^.dict"
                        ],
                        "type": "File?"
                    },
                    "use_jdk_deflater": {
                        "doc": "Whether to use the JdkDeflater (as opposed to IntelDeflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--USE_JDK_DEFLATER",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Whether to use the JdkInflater (as opposed to IntelInflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--USE_JDK_INFLATER",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "validation_stringency": {
                        "doc": "Validation stringency for all SAM files read by this program. Setting stringency to SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: STRICT. Possible values: {STRICT, LENIENT, SILENT}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--VALIDATION_STRINGENCY",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Validation Stringency",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "STRICT",
                        "type": [
                            "null",
                            {
                                "name": "validation_stringency",
                                "symbols": [
                                    "STRICT",
                                    "LENIENT",
                                    "SILENT"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--VERBOSITY",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "INFO",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "GATK MergeVcfs",
                "outputs": {
                    "output": {
                        "doc": "The merged VCF file. File format is determined by file extension.",
                        "label": "The merged VCF file.",
                        "outputBinding": {
                            "glob": "${\n    inputs = [].concat(inputs.input)\n\n    if (inputs[0].path.endsWith('.gz'))\n        return '*.vcf.gz'\n    else\n        return '*.vcf'\n}",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.input)\n\n}"
                        },
                        "sbg:fileTypes": "VCF",
                        "type": "File?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        if (inputs.memory_overhead_per_job) {\n            return inputs.memory_per_job + inputs.memory_overhead_per_job\n        } else\n            return inputs.memory_per_job\n    } else if (!inputs.memory_per_job && inputs.memory_overhead_per_job) {\n        return 2048 + inputs.memory_overhead_per_job\n    } else\n        return 2048\n}"
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": []
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk --java-options \"-Xmx1M\" MergeVcfs --OUTPUT input-1.vcf  --INPUT /path/to/input-1.vcf --INPUT /path/to/input-2.vcf --INPUT /path/to/input-3.vcf",
                "sbg:contributors": [
                    "teodora.aleksic",
                    "vladimirk"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-mergevcfs/31",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "admin/sbg-public-data/gatk-mergevcfs/15",
                "sbg:image_url": null,
                "sbg:latestRevision": 15,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-mergevcfs/31",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 2703.333440621696,
            "sbg:y": 266.6927176062019
        },
        {
            "id": "BWA_INDEX_1",
            "in": [
                {
                    "id": "total_memory"
                },
                {
                    "id": "reference",
                    "source": [
                        "reference"
                    ]
                },
                {
                    "id": "prefix_of_the_index_to_be_output"
                },
                {
                    "id": "do_not_add_alt_contig_to_reference"
                },
                {
                    "id": "bwt_construction"
                },
                {
                    "id": "block_size"
                },
                {
                    "id": "add_64_to_fasta_name"
                }
            ],
            "out": [
                {
                    "id": "indexed_reference"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "${\n    reference_file = inputs.reference.path.split('/')[inputs.reference.path.split('/').length - 1]\n    ext = reference_file.split('.')[reference_file.split('.').length - 1]\n    if (ext == 'tar') {\n        return 'echo Index files passed without any processing!'\n    } else {\n\n        cp_alt_cmd = ''\n\n        if (!inputs.do_not_add_alt_contig_to_reference) {\n            if (reference_file.search('38') >= 0) {\n                cp_alt_cmd = 'cp /opt/hs38DH.fa.alt ' + reference_file + '.alt ; '\n            }\n        }\n\n        index_cmd = 'bwa index ' + reference_file + ' '\n\n        return cp_alt_cmd + index_cmd\n    }\n}"
                    },
                    {
                        "position": 1,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    reference_file = inputs.reference.path.split('/')[inputs.reference.path.split('/').length - 1]\n    ext = reference_file.split('.')[reference_file.split('.').length - 1]\n    if (ext == 'tar' || !inputs.bwt_construction) {\n        return ''\n    } else {\n        return '-a ' + inputs.bwt_construction\n    }\n}"
                    },
                    {
                        "position": 1,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    reference_file = inputs.reference.path.split('/')[inputs.reference.path.split('/').length - 1]\n    ext = reference_file.split('.')[reference_file.split('.').length - 1]\n    if (ext == 'tar' || !inputs.prefix) {\n        return ''\n    } else {\n        return '-p ' + inputs.prefix\n    }\n}"
                    },
                    {
                        "position": 1,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    reference_file = inputs.reference.path.split('/')[inputs.reference.path.split('/').length - 1]\n    ext = reference_file.split('.')[reference_file.split('.').length - 1]\n    if (ext == 'tar' || !inputs.block_size) {\n        return ''\n    } else {\n        return '-b ' + inputs.block_size\n    }\n}"
                    },
                    {
                        "position": 1,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    reference_file = inputs.reference.path.split('/')[inputs.reference.path.split('/').length - 1]\n    ext = reference_file.split('.')[reference_file.split('.').length - 1]\n    if (ext == 'tar' || !inputs.add_64_to_fasta_name) {\n        return ''\n    } else {\n        return '-6 '\n    }\n}"
                    },
                    {
                        "position": 1,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    reference_file = inputs.reference.path.split('/')[inputs.reference.path.split('/').length - 1]\n    ext = reference_file.split('.')[reference_file.split('.').length - 1]\n    if (ext == 'tar') {\n        return ''\n    } else {\n        extensions = ' *.amb' + ' *.ann' + ' *.bwt' + ' *.pac' + ' *.sa'\n        if (!inputs.do_not_add_alt_contig_to_reference) {\n            if (reference_file.search('38') >= 0) {\n                extensions = extensions + ' *.alt ; '\n            }\n        }\n        tar_cmd = 'tar -cf ' + reference_file + '.tar ' + reference_file + extensions\n        return ' ; ' + tar_cmd\n    }\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "BWA INDEX constructs the FM-index (Full-text index in Minute space) for the reference genome.\nGenerated index files will be used with BWA MEM, BWA ALN, BWA SAMPE and BWA SAMSE tools.\n\nIf input reference file has TAR extension it is assumed that BWA indices came together with it. BWA INDEX will only pass that TAR to the output. If input is not TAR, the creation of BWA indices and its packing in TAR file (together with the reference) will be performed.\n\nTAR also contains alt reference from bwa.kit suggested by the author of the tool.",
                "hints": [],
                "id": "vladimirk/bwa-mem-bundle-0-7-17-demo/bwa-index/3",
                "inputs": {
                    "add_64_to_fasta_name": {
                        "doc": "Index files named as <in.fasta>64 instead of <in.fasta>.*.",
                        "label": "Output index files renamed by adding 64",
                        "sbg:category": "Configuration",
                        "type": "boolean?"
                    },
                    "block_size": {
                        "doc": "Block size for the bwtsw algorithm (effective with -a bwtsw).",
                        "label": "Block size",
                        "sbg:category": "Configuration",
                        "sbg:toolDefaultValue": "10000000",
                        "type": "int?"
                    },
                    "bwt_construction": {
                        "doc": "Algorithm for constructing BWT index. Available options are:s\tIS linear-time algorithm for constructing suffix array. It requires 5.37N memory where N is the size of the database. IS is moderately fast, but does not work with database larger than 2GB. IS is the default algorithm due to its simplicity. The current codes for IS algorithm are reimplemented by Yuta Mori. bwtsw\tAlgorithm implemented in BWT-SW. This method works with the whole human genome. Warning: `-a bwtsw' does not work for short genomes, while `-a is' and `-a div' do not work not for long genomes.",
                        "label": "Bwt construction",
                        "sbg:category": "Configuration",
                        "sbg:toolDefaultValue": "auto",
                        "type": [
                            "null",
                            {
                                "name": "bwt_construction",
                                "symbols": [
                                    "bwtsw",
                                    "is",
                                    "div"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "do_not_add_alt_contig_to_reference": {
                        "doc": "Do not add alt contigs file to TAR bundle.",
                        "label": "Do not add alt contigs file to TAR bundle",
                        "sbg:toolDefaultValue": "False",
                        "type": "boolean?"
                    },
                    "prefix_of_the_index_to_be_output": {
                        "doc": "Prefix of the index [same as fasta name].",
                        "label": "Prefix of the index to be output",
                        "sbg:category": "Configuration",
                        "type": "string?"
                    },
                    "reference": {
                        "doc": "Input reference fasta of TAR file with reference and indices.",
                        "label": "Reference",
                        "sbg:category": "File input",
                        "sbg:fileTypes": "FASTA,FA,FA.GZ,FASTA.GZ,TAR",
                        "type": "File"
                    },
                    "total_memory": {
                        "doc": "Total memory [GB] to be reserved for the tool (Default value is 1.5 x size_of_the_reference).",
                        "label": "Total memory [Gb]",
                        "sbg:category": "Configuration",
                        "type": "int?"
                    }
                },
                "label": "BWA INDEX",
                "outputs": {
                    "indexed_reference": {
                        "doc": "TARed fasta with its BWA indices.",
                        "label": "TARed fasta with its BWA indices",
                        "outputBinding": {
                            "glob": "${\n    reference_file = inputs.reference.path.split('/')[inputs.reference.path.split('/').length - 1]\n    ext = reference_file.split('.')[reference_file.split('.').length - 1]\n    if (ext == 'tar') {\n        return reference_file\n    } else {\n        return reference_file + '.tar'\n    }\n}",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.reference)\n\n}"
                        },
                        "sbg:fileTypes": "TAR",
                        "type": "File?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "2f813371e803",
                        "dockerPull": "images.sbgenomics.com/vladimirk/bwa:0.7.17"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    reference_file = inputs.reference.path.split('/')[inputs.reference.path.split('/').length - 1]\n    ext = reference_file.split('.')[reference_file.split('.').length - 1]\n\n    GB_1 = 1024 * 1024 * 1024\n    reads_size = inputs.reference.size\n\n    if (!reads_size) {\n        reads_size = GB_1\n    }\n\n    if (inputs.total_memory) {\n        return inputs.total_memory * 1024\n    } else if (ext == 'tar') {\n        return 128\n    } {\n        return (parseInt(1.5 * reads_size / (1024 * 1024)))\n    }\n}"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": [
                            "$(inputs.reference)"
                        ]
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "Indexing",
                    "FASTA-Processing"
                ],
                "sbg:cmdPreview": "cp /opt/hs38DH.fa.alt reference38.fasta.alt ; bwa index reference38.fasta            ; tar -cf reference38.fasta.tar reference38.fasta *.amb *.ann *.bwt *.pac *.sa *.alt ;",
                "sbg:contributors": [
                    "vladimirk"
                ],
                "sbg:createdBy": "vladimirk",
                "sbg:id": "h-e0b67355/h-c5380c77/h-fbe3939f/0",
                "sbg:image_url": null,
                "sbg:latestRevision": 3,
                "sbg:license": "GNU Affero General Public License v3.0, MIT License",
                "sbg:links": [
                    {
                        "id": "http://bio-bwa.sourceforge.net/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://github.com/lh3/bwa",
                        "label": "Source code"
                    },
                    {
                        "id": "http://bio-bwa.sourceforge.net/bwa.shtml",
                        "label": "Wiki"
                    },
                    {
                        "id": "http://sourceforge.net/projects/bio-bwa/",
                        "label": "Download"
                    },
                    {
                        "id": "http://www.ncbi.nlm.nih.gov/pubmed/19451168",
                        "label": "Publication"
                    }
                ],
                "sbg:project": "vladimirk/bwa-mem-bundle-0-7-17-demo",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "docs",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Heng Li",
                "sbg:toolkit": "BWA",
                "sbg:toolkitVersion": "0.7.17",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 55.38462453763157,
            "sbg:y": 44.6153840905817
        },
        {
            "id": "GATK_ApplyBQSR",
            "in": [
                {
                    "id": "verbosity"
                },
                {
                    "id": "use_original_qualities"
                },
                {
                    "id": "use_jdk_inflater"
                },
                {
                    "id": "use_jdk_deflater"
                },
                {
                    "id": "static_quantized_quals"
                },
                {
                    "id": "seconds_between_progress_updates"
                },
                {
                    "id": "sample"
                },
                {
                    "id": "round_down_quantized"
                },
                {
                    "id": "reference"
                },
                {
                    "id": "read_validation_stringency"
                },
                {
                    "id": "read_name"
                },
                {
                    "id": "read_index"
                },
                {
                    "id": "read_filter"
                },
                {
                    "id": "quiet"
                },
                {
                    "id": "quantize_quals"
                },
                {
                    "id": "preserve_qscores_less_than"
                },
                {
                    "id": "pl_filter_name"
                },
                {
                    "id": "minimum_mapping_quality"
                },
                {
                    "id": "min_read_length"
                },
                {
                    "id": "memory_per_job"
                },
                {
                    "id": "memory_overhead_per_job"
                },
                {
                    "id": "maximum_mapping_quality"
                },
                {
                    "id": "max_read_length"
                },
                {
                    "id": "max_fragment_length"
                },
                {
                    "id": "library"
                },
                {
                    "id": "lenient"
                },
                {
                    "id": "keep_reverse"
                },
                {
                    "id": "keep_read_group"
                },
                {
                    "id": "intervals_string"
                },
                {
                    "id": "intervals_file",
                    "source": [
                        "SBG_Prepare_Intervals/intervals"
                    ]
                },
                {
                    "id": "interval_set_rule"
                },
                {
                    "id": "interval_merging_rule"
                },
                {
                    "id": "interval_exclusion_padding"
                },
                {
                    "id": "input_cram"
                },
                {
                    "id": "input_bam",
                    "source": [
                        "BWA_MEM_Bundle/aligned_reads"
                    ]
                },
                {
                    "default": true,
                    "id": "include_interval_name_in_output_name"
                },
                {
                    "id": "global_q_score_prior"
                },
                {
                    "id": "filter_too_short"
                },
                {
                    "id": "exclude_intervas_string"
                },
                {
                    "id": "exclude_intervals_file"
                },
                {
                    "id": "emit_original_quals"
                },
                {
                    "id": "dont_require_soft_clips_both_ends"
                },
                {
                    "id": "disable_tool_default_read_filters"
                },
                {
                    "id": "disable_sequence_dictionary_validation"
                },
                {
                    "id": "disable_read_filter"
                },
                {
                    "id": "disable_bam_index_caching"
                },
                {
                    "id": "create_output_variant_md5"
                },
                {
                    "id": "create_output_variant_index"
                },
                {
                    "id": "create_output_bam_md5"
                },
                {
                    "id": "cloud_prefetch_buffer"
                },
                {
                    "id": "cloud_index_prefetch_buffer"
                },
                {
                    "id": "bqsr_recal_file",
                    "source": [
                        "GATK_BaseRecalibrator/recalibration_file"
                    ]
                },
                {
                    "id": "black_listed_lanes"
                },
                {
                    "id": "black_list"
                },
                {
                    "id": "ambig_filter_frac"
                },
                {
                    "id": "ambig_filter_bases"
                },
                {
                    "id": "add_output_vcf_command_line"
                },
                {
                    "id": "add_output_sam_program_record"
                }
            ],
            "out": [
                {
                    "id": "output"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "/opt/gatk"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "--java-options"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    if (inputs.memory_per_job) {\n        return '\\\"-Xmx'.concat(inputs.memory_per_job, 'M') + '\\\"'\n    }\n    return '\\\"-Xmx2048M\\\"'\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "ApplyBQSR"
                    },
                    {
                        "position": 4,
                        "prefix": "--output",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    interval_name = ''\n\n    if (inputs.include_interval_name_in_output_name) {\n        if (inputs.intervals_file) {\n            interval_path = [].concat(inputs.intervals_file)[0].path\n            interval_name = interval_path.split('/')[interval_path.split('/').length - 1].split('.')\n            interval_name.pop()\n            interval_name = '_' + interval_name.join('')\n        }\n    }\n    input = ''\n    if (inputs.input_cram) {\n        input = [].concat(inputs.input_cram)[0].path.split('/').slice(-1)[0]\n    }\n    if (inputs.input_bam) {\n        input = [].concat(inputs.input_bam)[0].path.split('/').slice(-1)[0]\n    }\n    input = input.split('.')\n    input = input.slice(0, -1).join('.') + interval_name + '.recalibrated.' + input.slice(-1)\n    return input\n}"
                    },
                    {
                        "position": 4,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "--create-output-bam-index"
                    },
                    {
                        "position": 104,
                        "separate": false,
                        "shellQuote": false,
                        "valueFrom": "${\n    interval_name = ''\n    interval_name = ''\n\n    if (inputs.include_interval_name_in_output_name) {\n        if (inputs.intervals_file) {\n            interval_path = [].concat(inputs.intervals_file)[0].path\n            interval_name = interval_path.split('/')[interval_path.split('/').length - 1].split('.')\n            interval_name.pop()\n            interval_name = '_' + interval_name.join('')\n        }\n    }\n    ext = 'bam'\n    input = ''\n    if (inputs.input_cram) {\n        return ''\n    }\n    if (inputs.input_bam) {\n        input = [].concat(inputs.input_bam)[0].path.split('/').slice(-1)[0]\n        input = input.split('.')\n        input_bai = input.slice(0, -1).join('.') + interval_name + '.recalibrated.bai'\n        input_bam_bai = input.slice(0, -1).join('.') + interval_name + '.recalibrated.bam.bai'\n\n        return ' && mv ' + input_bai + ' ' + input_bam_bai\n    }\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "Apply base quality score recalibration.\n\n###**Overview**  \n\nThis tool performs the second pass in a two-stage process called Base Quality Score Recalibration (BQSR). Specifically, it recalibrates the base qualities of the input reads based on the recalibration table produced by the BaseRecalibrator tool, and outputs a recalibrated BAM or CRAM file.\n\n####**Summary of the BQSR procedure**\n\nThe goal of this procedure is to correct for systematic bias that affect the assignment of base quality scores by the sequencer. The first pass consists of calculating error empirically and finding patterns in how error varies with basecall features over all bases. The relevant observations are written to a recalibration table. The second pass consists of applying numerical corrections to each individual basecall based on the patterns identified in the first step (recorded in the recalibration table) and write out the recalibrated data to a new BAM or CRAM file.\n\n###**Inputs**  \n\n- A BAM or CRAM file containing input read data\n- The covariates table (= recalibration file) generated by BaseRecalibrator on the input BAM or CRAM file\n\n###**Output**  \n\nA BAM or CRAM file containing the recalibrated read data\n\n###**Usage example**  \n\n    ./gatk-launch ApplyBQSR \\   \n         -R reference.fasta \\ \n         -I input.bam \\  \n         -BQSR recalibration.table \\  \n         -O output.bam  \n\n###**Notes**\n\n- This tool replaces the use of PrintReads for the application of base quality score recalibration as practiced in earlier versions of GATK (2.x and 3.x).\n- You should only run ApplyBQSR with the covariates table created from the input BAM or CRAM file(s).\n- Original qualities can be retained in the output file under the \"OQ\" tag if desired. See the `--emit_original_quals` argument for details.  \n\n###**IMPORTANT NOTICE**  \n\nTools in GATK that require a fasta reference file also look for the reference file's corresponding *.fai* (fasta index) and *.dict* (fasta dictionary) files. The fasta index file allows random access to reference bases and the dictionary file is a dictionary of the contig names and sizes contained within the fasta reference. These two secondary files are essential for GATK to work properly. To append these two files to your fasta reference please use the '***SBG FASTA Indices***' tool within your GATK based workflow before using any of the GATK tools.",
                "hints": [],
                "id": "vladimirk/gatk-4-0-demo-1/gatk-4-0-applybqsr/29",
                "inputs": {
                    "add_output_sam_program_record": {
                        "doc": "If true, adds a PG tag to created SAM/BAM/CRAM files. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--add-output-sam-program-record",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Add Output Sam Program Record",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "true",
                        "type": "boolean?"
                    },
                    "add_output_vcf_command_line": {
                        "doc": "If true, adds a command line header line to created VCF files. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--add-output-vcf-command-line",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Add Output Vcf Command Line",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "true",
                        "type": "boolean?"
                    },
                    "ambig_filter_bases": {
                        "doc": "Threshold number of ambiguous bases. If null, uses threshold fraction; otherwise, overrides threshold fraction. Cannot be used in conjunction with argument(s) maxAmbiguousBaseFraction.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-bases",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Bases",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "int?"
                    },
                    "ambig_filter_frac": {
                        "doc": "Threshold fraction of ambiguous bases Default value: 0.05.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--ambig-filter-frac",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ambig Filter Frac",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "sbg:toolDefaultValue": "0",
                        "type": "float?"
                    },
                    "black_list": {
                        "doc": "This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--black-list",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Black List",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "sbg:toolDefaultValue": null,
                        "type": "string?"
                    },
                    "black_listed_lanes": {
                        "doc": "Keep reads with platform units not on the list This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--black-listed-lanes",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Black Listed Lanes",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "sbg:toolDefaultValue": null,
                        "type": "string?"
                    },
                    "bqsr_recal_file": {
                        "doc": "Input recalibration table for BQSR Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--bqsr-recal-file",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Bqsr Recal File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Required Arguments",
                        "sbg:toolDefaultValue": null,
                        "type": "File"
                    },
                    "cloud_index_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Defaults to cloudPrefetchBuffer if unset. Default value: -1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-index-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Index Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "-1",
                        "type": "int?"
                    },
                    "cloud_prefetch_buffer": {
                        "doc": "Size of the cloud-only prefetch buffer (in MB; 0 to disable). Default value: 40.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--cloud-prefetch-buffer",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Cloud Prefetch Buffer",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "40",
                        "type": "int?"
                    },
                    "create_output_bam_md5": {
                        "doc": "If true, create a MD5 digest for any BAM/SAM/CRAM file created Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-bam-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Bam Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "create_output_variant_index": {
                        "doc": "If true, create a VCF index when writing a coordinate-sorted VCF file. Default value: true. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "true",
                        "type": "boolean?"
                    },
                    "create_output_variant_md5": {
                        "doc": "If true, create a a MD5 digest any VCF file created. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--create-output-variant-md5",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Create Output Variant Md5",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "disable_bam_index_caching": {
                        "doc": "If true, don't cache bam indexes, this will reduce memory requirements but may harm performance if many intervals are specified. Caching is automatically disabled if there are no intervals specified. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-bam-index-caching",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Bam Index Caching",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "disable_read_filter": {
                        "doc": "Read filters to be disabled before analysis  This argument may be specified 0 or more times. Default value: null. Possible Values: {WellformedReadFilter}",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Read Filter",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": null,
                        "type": [
                            "null",
                            {
                                "name": "disable_read_filter",
                                "symbols": [
                                    "GoodCigarReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "disable_sequence_dictionary_validation": {
                        "doc": "If specified, do not check the sequence dictionaries from our inputs for compatibility. Use at your own risk! Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-sequence-dictionary-validation",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Sequence Dictionary Validation",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "disable_tool_default_read_filters": {
                        "doc": "Disable all tool default read filters Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--disable-tool-default-read-filters",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Disable Tool Default Read Filters",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "dont_require_soft_clips_both_ends": {
                        "doc": "Allow a read to be filtered out based on having only 1 soft-clipped block. By default, both ends must have a soft-clipped block, setting this flag requires only 1 soft-clipped block. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--dont-require-soft-clips-both-ends",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Dont Require Soft Clips Both Ends",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "emit_original_quals": {
                        "doc": "Emit original base qualities under the OQ tag Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--emit-original-quals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Emit Original Quals",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "exclude_intervals_file": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervals File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File?"
                    },
                    "exclude_intervas_string": {
                        "doc": "One or more genomic intervals to exclude from processing This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--exclude-intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Exclude Intervas String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "filter_too_short": {
                        "doc": "Value for which reads with less than this number of aligned bases is considered too short Default value: 30.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--filter-too-short",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Filter Too Short",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "sbg:toolDefaultValue": "30",
                        "type": "int?"
                    },
                    "global_q_score_prior": {
                        "doc": "Global Qscore Bayesian prior to use for BQSR Default value: -1.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--global-q-score-prior",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Global Q Score Prior",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "-1",
                        "type": "float?"
                    },
                    "include_interval_name_in_output_name": {
                        "doc": "Include interval name in output name.",
                        "label": "Include Interval Name In Output Name",
                        "sbg:toolDefaultValue": "FALSE",
                        "type": "boolean?"
                    },
                    "input_bam": {
                        "doc": "BAM/SAM file containing reads This argument must be specified at least once.",
                        "inputBinding": {
                            "itemSeparator": " --input ",
                            "position": 4,
                            "prefix": "--input",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Input bam",
                        "sbg:category": "Required Arguments",
                        "sbg:fileTypes": "BAM",
                        "secondaryFiles": [
                            ".bai"
                        ],
                        "type": "File[]?"
                    },
                    "input_cram": {
                        "doc": "CRAM file containing reads This argument must be specified at least once.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--input",
                            "shellQuote": false
                        },
                        "label": "Input cram",
                        "sbg:category": "Required Arguments",
                        "sbg:fileTypes": "CRAM",
                        "secondaryFiles": [
                            ".crai"
                        ],
                        "type": "File[]?"
                    },
                    "interval_exclusion_padding": {
                        "doc": "Amount of padding (in bp) to add to each interval you are excluding. Default value: 0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-exclusion-padding",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Exclusion Padding",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "0",
                        "type": "int?"
                    },
                    "interval_merging_rule": {
                        "doc": "Interval merging rule for abutting intervals  Default value: ALL. Possible values: {ALL, OVERLAPPING_ONLY}",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-merging-rule",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Padding",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "0",
                        "type": "string?"
                    },
                    "interval_set_rule": {
                        "doc": "Set merging approach to use for combining interval inputs Default value: UNION. Possible values: {UNION, INTERSECTION}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--interval-set-rule",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Interval Set Rule",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "UNION",
                        "type": [
                            "null",
                            {
                                "name": "interval_set_rule",
                                "symbols": [
                                    "UNION",
                                    "INTERSECTION"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "intervals_file": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Intervals File",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "TXT, BED",
                        "type": "File?"
                    },
                    "intervals_string": {
                        "doc": "One or more genomic intervals over which to operate This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--intervals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Intervals String",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "type": "string?"
                    },
                    "keep_read_group": {
                        "doc": "The name of the read group to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-read-group",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Read Group",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "sbg:toolDefaultValue": null,
                        "type": "string?"
                    },
                    "keep_reverse": {
                        "doc": "Keep only reads on the reverse strand Required. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--keep-reverse",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Keep Reverse",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "type": "boolean?"
                    },
                    "lenient": {
                        "doc": "Lenient processing of VCF files Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--lenient",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Lenient",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "library": {
                        "doc": "The name of the library to keep Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--library",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Library",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "sbg:toolDefaultValue": null,
                        "type": "string?"
                    },
                    "max_fragment_length": {
                        "doc": "Keep only read pairs with fragment length at most equal to the given value Default value: 1000000.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-fragment-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Fragment Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "sbg:toolDefaultValue": "1000000",
                        "type": "int?"
                    },
                    "max_read_length": {
                        "doc": "Keep only reads with length at most equal to the specified value Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--max-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Max Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "sbg:toolDefaultValue": null,
                        "type": "int?"
                    },
                    "maximum_mapping_quality": {
                        "doc": "Maximum mapping quality to keep (inclusive) Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--maximum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Maximum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "sbg:toolDefaultValue": "null",
                        "type": "int?"
                    },
                    "memory_overhead_per_job": {
                        "label": "Memory Overhead Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "memory_per_job": {
                        "label": "Memory Per Job",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "min_read_length": {
                        "doc": "Keep only reads with length at least equal to the specified value Default value: 1.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--min-read-length",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Min Read Length",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "sbg:toolDefaultValue": "1",
                        "type": "int?"
                    },
                    "minimum_mapping_quality": {
                        "doc": "Minimum mapping quality to keep (inclusive) Default value: 10.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--minimum-mapping-quality",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Minimum Mapping Quality",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "sbg:toolDefaultValue": "10",
                        "type": "int?"
                    },
                    "pl_filter_name": {
                        "doc": "Keep reads with RG:PL attribute containing this string This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--pl-filter-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Pl Filter Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "sbg:toolDefaultValue": null,
                        "type": "string?"
                    },
                    "preserve_qscores_less_than": {
                        "doc": "Don't recalibrate bases with quality scores less than this threshold Default value: 6.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--preserve-qscores-less-than",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Preserve Qscores Less Than",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "6",
                        "type": "int?"
                    },
                    "quantize_quals": {
                        "doc": "Quantize quality scores to a given number of levels Default value: 0. Cannot be used in conjuction with argument(s) staticQuantizationQuals (SQQ) roundDown (RDQ).",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--quantize-quals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quantize Quals",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "0",
                        "type": "int?"
                    },
                    "quiet": {
                        "doc": "Whether to suppress job-summary info on System.err. Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--quiet",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Quiet",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "read_filter": {
                        "doc": "Read filters to be applied before analysis This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-filter",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Filter",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "null",
                        "type": [
                            "null",
                            {
                                "name": "read_filter",
                                "symbols": [
                                    "AlignmentAgreesWithHeaderReadFilter",
                                    "AllowAllReadsReadFilter",
                                    "AmbiguousBaseReadFilter",
                                    "CigarContainsNoNOperator",
                                    "FirstOfPairReadFilter",
                                    "FragmentLengthReadFilter",
                                    "GoodCigarReadFilter",
                                    "HasReadGroupReadFilter",
                                    "LibraryReadFilter",
                                    "MappedReadFilter",
                                    "MappingQualityAvailableReadFilter",
                                    "MappingQualityNotZeroReadFilter",
                                    "MappingQualityReadFilter",
                                    "MatchingBasesAndQualsReadFilter",
                                    "MateDifferentStrandReadFilter",
                                    "MateOnSameContigOrNoMappedMateReadFilter",
                                    "MetricsReadFilter",
                                    "NonZeroFragmentLengthReadFilter",
                                    "NonZeroReferenceLengthAlignmentReadFilter",
                                    "NotDuplicateReadFilter",
                                    "NotOpticalDuplicateReadFilter",
                                    "NotSecondaryAlignmentReadFilter",
                                    "NotSupplementaryAlignmentReadFilter",
                                    "OverclippedReadFilter",
                                    "PairedReadFilter",
                                    "PassesVendorQualityCheckReadFilter",
                                    "PlatformReadFilter",
                                    "PlatformUnitReadFilter",
                                    "PrimaryLineReadFilter",
                                    "ProperlyPairedReadFilter",
                                    "ReadGroupBlackListReadFilter",
                                    "ReadGroupReadFilter",
                                    "ReadLengthEqualsCigarLengthReadFilter",
                                    "ReadLengthReadFilter",
                                    "ReadNameReadFilter",
                                    "ReadStrandFilter",
                                    "SampleReadFilter",
                                    "SecondOfPairReadFilter",
                                    "SeqIsStoredReadFilter",
                                    "ValidAlignmentEndReadFilter",
                                    "ValidAlignmentStartReadFilter",
                                    "WellformedReadFilter"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "read_index": {
                        "doc": "Indices to use for the read inputs. If specified, an index must be provided for every read input and in the same order as the read inputs. If this argument is not specified, the path to the index for each input will be inferred automatically. This argument may be specified 0 or more times. Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-index",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Index",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "null",
                        "type": "string?"
                    },
                    "read_name": {
                        "doc": "Keep only reads with this read name Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-name",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Name",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "sbg:toolDefaultValue": null,
                        "type": "string?"
                    },
                    "read_validation_stringency": {
                        "doc": "Validation stringency for all SAM/BAM/CRAM/SRA files read by this program. The default stringency value SILENT can improve performance when processing a BAM file in which variable-length data (read, qualities, tags) do not otherwise need to be decoded. Default value: SILENT. Possible values: {STRICT, LENIENT, SILENT}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--read-validation-stringency",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Read Validation Stringency",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "SILENT",
                        "type": [
                            "null",
                            {
                                "name": "read_validation_stringency",
                                "symbols": [
                                    "STRICT",
                                    "LENIENT",
                                    "SILENT"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "reference": {
                        "doc": "Reference sequence Default value: null.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--reference",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Reference",
                        "sbg:category": "Optional Arguments",
                        "sbg:fileTypes": "FASTA, FA",
                        "secondaryFiles": [
                            ".fai",
                            "^.dict"
                        ],
                        "type": "File?"
                    },
                    "round_down_quantized": {
                        "doc": "Round quals down to nearest quantized qual Default value: false. Possible values: {true, false} Cannot be used in conjuction with argument(s) quantizationLevels (qq).",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--round-down-quantized",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Round Down Quantized",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "sample": {
                        "doc": "The name of the sample(s) to keep, filtering out all others This argument must be specified at least once. Required.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--sample",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sample",
                        "sbg:altPrefix": "",
                        "sbg:category": "Conditional Arguments for readFilter",
                        "sbg:toolDefaultValue": null,
                        "type": "string?"
                    },
                    "seconds_between_progress_updates": {
                        "doc": "Output traversal statistics every time this many seconds elapse Default value: 10.0.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--seconds-between-progress-updates",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Seconds Between Progress Updates",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "10",
                        "type": "float?"
                    },
                    "static_quantized_quals": {
                        "doc": "Use static quantized quality scores to a given number of levels (with -bqsr) This argument may be specified 0 or more times. Default value: null. Cannot be used in conjuction with argument(s) quantizationLevels (qq).",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--static-quantized-quals",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Static Quantized Quals",
                        "sbg:altPrefix": "",
                        "sbg:category": "Advanced Arguments",
                        "sbg:toolDefaultValue": "null",
                        "type": "int?"
                    },
                    "use_jdk_deflater": {
                        "doc": "Whether to use the JdkDeflater (as opposed to IntelDeflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-deflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Deflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "use_jdk_inflater": {
                        "doc": "Whether to use the JdkInflater (as opposed to IntelInflater) Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-jdk-inflater",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Jdk Inflater",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "use_original_qualities": {
                        "doc": "Use the base quality scores from the OQ tag Default value: false. Possible values: {true, false}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--use-original-qualities",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use Original Qualities",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "false",
                        "type": "boolean?"
                    },
                    "verbosity": {
                        "doc": "Control verbosity of logging. Default value: INFO. Possible values: {ERROR, WARNING, INFO, DEBUG}.",
                        "inputBinding": {
                            "position": 4,
                            "prefix": "--verbosity",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbosity",
                        "sbg:altPrefix": "",
                        "sbg:category": "Optional Arguments",
                        "sbg:toolDefaultValue": "INFO",
                        "type": [
                            "null",
                            {
                                "name": "verbosity",
                                "symbols": [
                                    "ERROR",
                                    "WARNING",
                                    "INFO",
                                    "DEBUG"
                                ],
                                "type": "enum"
                            }
                        ]
                    }
                },
                "label": "GATK ApplyBQSR",
                "outputs": {
                    "output": {
                        "doc": "Recalibrated BAM/SAM/CRAM file",
                        "label": "Output",
                        "outputBinding": {
                            "glob": "${\n    if (inputs.input_cram) {\n        input = [].concat(inputs.input_cram)[0].path.split('/').slice(-1)[0]\n    }\n    if (inputs.input_bam) {\n        input = [].concat(inputs.input_bam)[0].path.split('/').slice(-1)[0]\n    }\n    input = input.split('.').slice(-1)[0]\n\n    return '*.' + input\n}",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.input)\n\n}"
                        },
                        "sbg:fileTypes": "BAM,SAM,CRAM",
                        "secondaryFiles": [
                            ".bai",
                            ".crai"
                        ],
                        "type": "File?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": 1,
                        "ramMin": "${\n    if (inputs.memory_per_job) {\n        if (inputs.memory_overhead_per_job) {\n            return inputs.memory_per_job + inputs.memory_overhead_per_job\n        } else\n            return inputs.memory_per_job\n    } else if (!inputs.memory_per_job && inputs.memory_overhead_per_job) {\n        return 2048 + inputs.memory_overhead_per_job\n    } else\n        return 2048\n}"
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "",
                        "dockerPull": "images.sbgenomics.com/teodora_aleksic/gatk:4.0.2.0"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": []
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "GATK-4"
                ],
                "sbg:cmdPreview": "/opt/gatk --java-options \"-Xmx2048M\" ApplyBQSR --bqsr-recal-file /path/to/bqsr.grp --output input_cram-1_1.recalibrated.cram  --create-output-bam-index",
                "sbg:contributors": [
                    "nikola_jovanovic",
                    "vladimirk",
                    "teodora.aleksic"
                ],
                "sbg:copyOf": "vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-applybqsr/67",
                "sbg:createdBy": "teodora.aleksic",
                "sbg:id": "h-02670849/h-7c497cc4/h-d6e563ae/0",
                "sbg:image_url": null,
                "sbg:latestRevision": 29,
                "sbg:license": "Open source BSD (3-clause) license",
                "sbg:links": [
                    {
                        "id": "https://software.broadinstitute.org/gatk/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/documentation/tooldocs/current/",
                        "label": "Documentation"
                    },
                    {
                        "id": "https://software.broadinstitute.org/gatk/download/",
                        "label": "Download"
                    }
                ],
                "sbg:project": "vladimirk/gatk-4-0-demo-1",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Copy of vladimirk/whole-exome-pipeline-bwa-gatk-4-0-with-metrics-demo/gatk-applybqsr/67",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Broad Institute",
                "sbg:toolkit": "GATK",
                "sbg:toolkitVersion": "4.0.2.0",
                "sbg:validationErrors": [],
                "sbg:wrapperAuthor": "filip_tubic",
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 1268.0774601465412,
            "sbg:y": 270.2566226756189,
            "scatter": "intervals_file"
        },
        {
            "id": "BWA_MEM_Bundle",
            "in": [
                {
                    "id": "wgs_hg38_mode_threads"
                },
                {
                    "id": "verbose_level"
                },
                {
                    "id": "use_soft_clipping"
                },
                {
                    "id": "unpaired_read_penalty"
                },
                {
                    "default": 15,
                    "id": "total_memory"
                },
                {
                    "default": 8,
                    "id": "threads"
                },
                {
                    "id": "speficy_distribution_parameters"
                },
                {
                    "default": 2,
                    "id": "sort_memory"
                },
                {
                    "id": "smart_pairing_in_input_fastq"
                },
                {
                    "id": "skip_seeds"
                },
                {
                    "id": "skip_pairing"
                },
                {
                    "id": "skip_mate_rescue"
                },
                {
                    "id": "select_seeds"
                },
                {
                    "id": "seed_occurrence_for_the_3rd_round"
                },
                {
                    "id": "score_for_a_sequence_match"
                },
                {
                    "id": "sambamba_threads"
                },
                {
                    "id": "rg_sample_id"
                },
                {
                    "id": "rg_platform_unit_id"
                },
                {
                    "id": "rg_platform"
                },
                {
                    "id": "rg_median_fragment_length"
                },
                {
                    "id": "rg_library_id"
                },
                {
                    "id": "rg_id"
                },
                {
                    "id": "rg_data_submitting_center"
                },
                {
                    "default": 1,
                    "id": "reserved_threads"
                },
                {
                    "id": "reference_index_tar",
                    "source": [
                        "BWA_INDEX_1/indexed_reference"
                    ]
                },
                {
                    "id": "read_type"
                },
                {
                    "id": "read_group_header"
                },
                {
                    "id": "output_name"
                },
                {
                    "id": "output_in_xa"
                },
                {
                    "id": "output_header"
                },
                {
                    "id": "output_format"
                },
                {
                    "id": "output_alignments"
                },
                {
                    "id": "num_bases_reproducibility"
                },
                {
                    "id": "mismatch_penalty"
                },
                {
                    "id": "minimum_seed_length"
                },
                {
                    "id": "minimum_output_score"
                },
                {
                    "id": "mate_rescue_rounds"
                },
                {
                    "id": "mark_shorter"
                },
                {
                    "id": "insert_string_to_header"
                },
                {
                    "id": "input_reads",
                    "source": [
                        "SBG_Pair_FASTQs_by_Metadata/tuple_list"
                    ]
                },
                {
                    "id": "ignore_alt_file"
                },
                {
                    "id": "gap_open_penalties"
                },
                {
                    "id": "gap_extension_penalties"
                },
                {
                    "id": "filter_out_secondary_alignments"
                },
                {
                    "id": "dropoff"
                },
                {
                    "id": "drop_chains_fraction"
                },
                {
                    "id": "discard_exact_matches"
                },
                {
                    "id": "discard_chain_length"
                },
                {
                    "default": "RemoveDuplicates",
                    "id": "deduplication"
                },
                {
                    "id": "clipping_penalty"
                },
                {
                    "id": "band_width"
                },
                {
                    "id": "append_comment"
                }
            ],
            "out": [
                {
                    "id": "samblaster_log"
                },
                {
                    "id": "aligned_reads"
                }
            ],
            "run": {
                "$namespaces": {
                    "sbg": "https://sevenbridges.com"
                },
                "arguments": [
                    {
                        "position": 0,
                        "shellQuote": false,
                        "valueFrom": "${\n    cmd = \"/bin/bash -c \\\"\"\n    return cmd\n}"
                    },
                    {
                        "position": 1,
                        "shellQuote": false,
                        "valueFrom": "${\n    reference_file = inputs.reference_index_tar.path.split('/')[inputs.reference_index_tar.path.split('/').length - 1]\n    return 'tar -xf ' + reference_file + ' ; '\n\n}"
                    },
                    {
                        "position": 2,
                        "shellQuote": false,
                        "valueFrom": "${\n    reference_file = inputs.reference_index_tar.path.split('/')[inputs.reference_index_tar.path.split('/').length - 1]\n    if (reference_file.endsWith('.tar')) {\n        reference_file = reference_file.substring(0, reference_file.length - 4)\n    }\n\n\n    if (!inputs.ignore_alt_file) {\n        if (reference_file.search('38') >= 0) {\n            return 'cp /opt/hs38DH.fa.alt ' + reference_file + '.alt ; '\n        }\n    }\n\n}"
                    },
                    {
                        "position": 3,
                        "shellQuote": false,
                        "valueFrom": "bwa"
                    },
                    {
                        "position": 4,
                        "shellQuote": false,
                        "valueFrom": "mem"
                    },
                    {
                        "position": 116,
                        "prefix": "",
                        "separate": false,
                        "shellQuote": false,
                        "valueFrom": "${\n    ///////////////////////////////////////////\n    ///  SAMBAMBA VIEW   //////////////////////\n    ///////////////////////////////////////////\n    function common_substring(a, b) {\n        var i = 0;\n\n        while (a[i] === b[i] && i < a.length) {\n            i = i + 1;\n        }\n\n        return a.slice(0, i);\n    }\n\n    // Set output file name\n    if (inputs.input_reads[0] instanceof Array) {\n        input_1 = inputs.input_reads[0][0] // scatter mode\n        input_2 = inputs.input_reads[0][1]\n    } else if (inputs.input_reads instanceof Array) {\n        input_1 = inputs.input_reads[0]\n        input_2 = inputs.input_reads[1]\n    } else {\n        input_1 = [].concat(inputs.input_reads)[0]\n        input_2 = input_1\n    }\n    full_name = input_1.path.split('/')[input_1.path.split('/').length - 1]\n\n    if (inputs.output_name) {\n        name = inputs.output_name\n    } else if (inputs.input_reads.length == 1) {\n        name = full_name\n\n        if (name.slice(-3, name.length) === '.gz' || name.slice(-3, name.length) === '.GZ')\n            name = name.slice(0, -3)\n        if (name.slice(-3, name.length) === '.fq' || name.slice(-3, name.length) === '.FQ')\n            name = name.slice(0, -3)\n        if (name.slice(-6, name.length) === '.fastq' || name.slice(-6, name.length) === '.FASTQ')\n            name = name.slice(0, -6)\n\n    } else {\n        full_name2 = input_2.path.split('/')[input_2.path.split('/').length - 1]\n        name = common_substring(full_name, full_name2)\n\n        if (name.slice(-1, name.length) === '_' || name.slice(-1, name.length) === '.')\n            name = name.slice(0, -1)\n        if (name.slice(-2, name.length) === 'p_' || name.slice(-1, name.length) === 'p.')\n            name = name.slice(0, -2)\n        if (name.slice(-2, name.length) === 'P_' || name.slice(-1, name.length) === 'P.')\n            name = name.slice(0, -2)\n        if (name.slice(-3, name.length) === '_p_' || name.slice(-3, name.length) === '.p.')\n            name = name.slice(0, -3)\n        if (name.slice(-3, name.length) === '_pe' || name.slice(-3, name.length) === '.pe')\n            name = name.slice(0, -3)\n    }\n\n    // Read number of threads if defined\n    if (inputs.sambamba_threads) {\n        threads = inputs.sambamba_threads\n    } else if (inputs.threads) {\n        threads = inputs.threads\n    } else if (inputs.wgs_hg38_mode_threads) {\n        MAX_THREADS = 36\n        ref_name_arr = inputs.reference_index_tar.path.split('/')\n        ref_name = ref_name_arr[ref_name_arr.length - 1]\n        if (ref_name.search('38') >= 0) {\n            threads = inputs.wgs_hg38_mode_threads\n        } else {\n            threads = MAX_THREADS\n        }\n    } else {\n        threads = 8\n    }\n\n    if (inputs.filter_out_secondary_alignments) {\n        filt_sec = ' --filter \\'not secondary_alignment\\' '\n    } else {\n        filt_sec = ' '\n    }\n\n    // Set output command\n    sambamba_path = 'sambamba'\n    if (inputs.output_format == 'BAM') {\n        return \"| \" + sambamba_path + \" view -t \" + threads + filt_sec + \"-f bam -S /dev/stdin -o \" + name + \".bam\"\n    } else if (inputs.output_format == 'SAM') { // SAM\n        return \"> \" + name + \".sam\"\n    } else { // SortedBAM is considered default\n        return \"| \" + sambamba_path + \" view -t \" + threads + filt_sec + \"-f bam -l 0 -S /dev/stdin\"\n    }\n\n}"
                    },
                    {
                        "position": 117,
                        "separate": false,
                        "shellQuote": false,
                        "valueFrom": "${\n    ///////////////////////////////////////////\n    ///  SAMBAMBA SORT   //////////////////////\n    ///////////////////////////////////////////\n\n    function common_substring(a, b) {\n        var i = 0;\n        while (a[i] === b[i] && i < a.length) {\n            i = i + 1;\n        }\n\n        return a.slice(0, i);\n    }\n\n    // Set output file name\n    if (inputs.input_reads[0] instanceof Array) {\n        input_1 = inputs.input_reads[0][0] // scatter mode\n        input_2 = inputs.input_reads[0][1]\n    } else if (inputs.input_reads instanceof Array) {\n        input_1 = inputs.input_reads[0]\n        input_2 = inputs.input_reads[1]\n    } else {\n        input_1 = [].concat(inputs.input_reads)[0]\n        input_2 = input_1\n    }\n    full_name = input_1.path.split('/')[input_1.path.split('/').length - 1]\n\n    if (inputs.output_name) {\n        name = inputs.output_name\n    } else if (inputs.input_reads.length == 1) {\n        name = full_name\n        if (name.slice(-3, name.length) === '.gz' || name.slice(-3, name.length) === '.GZ')\n            name = name.slice(0, -3)\n        if (name.slice(-3, name.length) === '.fq' || name.slice(-3, name.length) === '.FQ')\n            name = name.slice(0, -3)\n        if (name.slice(-6, name.length) === '.fastq' || name.slice(-6, name.length) === '.FASTQ')\n            name = name.slice(0, -6)\n\n    } else {\n        full_name2 = input_2.path.split('/')[input_2.path.split('/').length - 1]\n        name = common_substring(full_name, full_name2)\n\n        if (name.slice(-1, name.length) === '_' || name.slice(-1, name.length) === '.')\n            name = name.slice(0, -1)\n        if (name.slice(-2, name.length) === 'p_' || name.slice(-1, name.length) === 'p.')\n            name = name.slice(0, -2)\n        if (name.slice(-2, name.length) === 'P_' || name.slice(-1, name.length) === 'P.')\n            name = name.slice(0, -2)\n        if (name.slice(-3, name.length) === '_p_' || name.slice(-3, name.length) === '.p.')\n            name = name.slice(0, -3)\n        if (name.slice(-3, name.length) === '_pe' || name.slice(-3, name.length) === '.pe')\n            name = name.slice(0, -3)\n    }\n\n    //////////////////////////\n    // Set sort memory size\n\n    reads_size = 0 // Not used because of situations when size does not exist!\n    GB_1 = 1024 * 1024 * 1024\n    if (reads_size < GB_1) {\n        suggested_memory = 4\n        suggested_cpus = 1\n    } else if (reads_size < 10 * GB_1) {\n        suggested_memory = 15\n        suggested_cpus = 8\n    } else {\n        suggested_memory = 58\n        suggested_cpus = 31\n    }\n\n\n    if (!inputs.total_memory) {\n        total_memory = suggested_memory\n    } else {\n        total_memory = inputs.total_memory\n    }\n\n    // TODO:Rough estimation, should be fine-tuned!\n    if (total_memory > 16) {\n        sorter_memory = parseInt(total_memory / 3)\n    } else {\n        sorter_memory = 5\n    }\n\n    if (inputs.sort_memory) {\n        sorter_memory_string = inputs.sort_memory + 'GiB'\n    } else sorter_memory_string = sorter_memory + 'GiB'\n\n    // Read number of threads if defined\n    if (inputs.sambamba_threads) {\n        threads = inputs.sambamba_threads\n    } else if (inputs.threads) {\n        threads = inputs.threads\n    } else if (inputs.wgs_hg38_mode_threads) {\n        MAX_THREADS = 36\n        ref_name_arr = inputs.reference_index_tar.path.split('/')\n        ref_name = ref_name_arr[ref_name_arr.length - 1]\n        if (ref_name.search('38') >= 0) {\n            threads = inputs.wgs_hg38_mode_threads\n        } else {\n            threads = MAX_THREADS\n        }\n    } else {\n        threads = 8\n    }\n\n\n    sambamba_path = 'sambamba'\n\n    // Coordinate Sorted BAM is default\n    if (!((inputs.output_format == 'BAM') || (inputs.output_format == 'SAM'))) {\n        append = ''\n        if (inputs.output_format == 'Queryname Sorted BAM') {\n            append = ' --sort-by-name'\n        } else if (inputs.output_format == 'Natural Sorted BAM') {\n            append = ' --natural-sort'\n        }\n        cmd = \"| \" + sambamba_path + \" sort -t \" + threads + append\n        return cmd + \" -m \" + sorter_memory_string + \" --tmpdir ./ -o \" + name + \".bam -l 5 /dev/stdin\"\n    } else return \"\"\n}"
                    },
                    {
                        "position": 115,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    ///////////////////////////////////////////\n    ///  SAMBLASTER      //////////////////////\n    ///////////////////////////////////////////\n    function common_substring(a, b) {\n        var i = 0;\n\n        while (a[i] === b[i] && i < a.length) {\n            i = i + 1;\n        }\n\n        return a.slice(0, i);\n    }\n    // Set output file name\n    if (inputs.input_reads[0] instanceof Array) {\n        input_1 = inputs.input_reads[0][0] // scatter mode\n        input_2 = inputs.input_reads[0][1]\n    } else if (inputs.input_reads instanceof Array) {\n        input_1 = inputs.input_reads[0]\n        input_2 = inputs.input_reads[1]\n    } else {\n        input_1 = [].concat(inputs.input_reads)[0]\n        input_2 = input_1\n    }\n    full_name = input_1.path.split('/')[input_1.path.split('/').length - 1]\n\n    if (inputs.output_name) {\n        name = inputs.output_name\n    } else if (inputs.input_reads.length == 1) {\n        name = full_name\n\n        if (name.slice(-3, name.length) === '.gz' || name.slice(-3, name.length) === '.GZ')\n            name = name.slice(0, -3)\n        if (name.slice(-3, name.length) === '.fq' || name.slice(-3, name.length) === '.FQ')\n            name = name.slice(0, -3)\n        if (name.slice(-6, name.length) === '.fastq' || name.slice(-6, name.length) === '.FASTQ')\n            name = name.slice(0, -6)\n\n    } else {\n        full_name2 = input_2.path.split('/')[input_2.path.split('/').length - 1]\n        name = common_substring(full_name, full_name2)\n\n        if (name.slice(-1, name.length) === '_' || name.slice(-1, name.length) === '.')\n            name = name.slice(0, -1)\n        if (name.slice(-2, name.length) === 'p_' || name.slice(-1, name.length) === 'p.')\n            name = name.slice(0, -2)\n        if (name.slice(-2, name.length) === 'P_' || name.slice(-1, name.length) === 'P.')\n            name = name.slice(0, -2)\n        if (name.slice(-3, name.length) === '_p_' || name.slice(-3, name.length) === '.p.')\n            name = name.slice(0, -3)\n        if (name.slice(-3, name.length) === '_pe' || name.slice(-3, name.length) === '.pe')\n            name = name.slice(0, -3)\n    }\n\n    if (inputs.deduplication == \"MarkDuplicates\") {\n        inputs.mark_shorter ? cmd = \"| samblaster -M -i /dev/stdin -o /dev/stdout 2>\" + name + \".samblaster.log\" : cmd = \"| samblaster -i /dev/stdin -o /dev/stdout 2>\" + name + \".samblaster.log\"\n        return cmd\n    } else if (inputs.deduplication == \"RemoveDuplicates\") {\n        inputs.mark_shorter ? cmd = \"| samblaster -M -r -i /dev/stdin -o /dev/stdout 2>\" + name + \".samblaster.log\" : cmd = \"| samblaster -r -i /dev/stdin -o /dev/stdout 2>\" + name + \".samblaster.log\"\n        return cmd\n    } else {\n        return \"\"\n    }\n}"
                    },
                    {
                        "position": 6,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n\n    if (inputs.read_group_header) {\n        return '-R ' + inputs.read_group_header\n    }\n\n    function add_param(key, val) {\n        if (!val) {\n            return\n        }\n        param_list.push(key + ':' + val)\n    }\n\n    param_list = []\n\n    // Set output file name\n    if (inputs.input_reads[0] instanceof Array) {\n        input_1 = inputs.input_reads[0][0] // scatter mode\n    } else if (inputs.input_reads instanceof Array) {\n        input_1 = inputs.input_reads[0]\n    } else {\n        input_1 = [].concat(inputs.input_reads)[0]\n    }\n\n    //Read metadata for input reads\n    read_metadata = input_1.metadata\n    if (!read_metadata) read_metadata = []\n\n    if (inputs.rg_id) {\n        add_param('ID', inputs.rg_id)\n    } else {\n        add_param('ID', '1')\n    }\n\n\n    if (inputs.rg_data_submitting_center) {\n        add_param('CN', inputs.rg_data_submitting_center)\n    } else if ('data_submitting_center' in read_metadata) {\n        add_param('CN', read_metadata.data_submitting_center)\n    }\n\n    if (inputs.rg_library_id) {\n        add_param('LB', inputs.rg_library_id)\n    } else if ('library_id' in read_metadata) {\n        add_param('LB', read_metadata.library_id)\n    }\n\n    if (inputs.rg_median_fragment_length) {\n        add_param('PI', inputs.rg_median_fragment_length)\n    }\n\n\n    if (inputs.rg_platform) {\n        add_param('PL', inputs.rg_platform)\n    } else if ('platform' in read_metadata) {\n        if (read_metadata.platform == 'HiSeq X Ten') {\n            rg_platform = 'Illumina'\n        } else {\n            rg_platform = read_metadata.platform\n        }\n        add_param('PL', rg_platform)\n    }\n\n    if (inputs.rg_platform_unit_id) {\n        add_param('PU', inputs.rg_platform_unit_id)\n    } else if ('platform_unit_id' in read_metadata) {\n        add_param('PU', read_metadata.platform_unit_id)\n    }\n\n    if (inputs.rg_sample_id) {\n        add_param('SM', inputs.rg_sample_id)\n    } else if ('sample_id' in read_metadata) {\n        add_param('SM', read_metadata.sample_id)\n    }\n\n    return \"-R '@RG\\\\t\" + param_list.join('\\\\t') + \"'\"\n\n}"
                    },
                    {
                        "position": 106,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    /////// Set input reads in the correct order depending of the paired end from metadata\n\n    // Set output file name\n    if (inputs.input_reads[0] instanceof Array) {\n        input_reads = inputs.input_reads[0] // scatter mode\n    } else {\n        input_reads = inputs.input_reads = [].concat(inputs.input_reads)\n    }\n\n\n    //Read metadata for input reads\n    read_metadata = input_reads[0].metadata\n    if (!read_metadata) read_metadata = []\n\n    order = 0 // Consider this as normal order given at input: pe1 pe2\n\n    // Check if paired end 1 corresponds to the first given read\n    if (read_metadata == []) {\n        order = 0\n    } else if ('paired_end' in read_metadata) {\n        pe1 = read_metadata.paired_end\n        if (pe1 != 1) order = 1 // change order\n    }\n\n    // Return reads in the correct order\n    if (input_reads.length == 1) {\n        return input_reads[0].path // Only one read present\n    } else if (input_reads.length == 2) {\n        if (order == 0) return input_reads[0].path + ' ' + input_reads[1].path\n        else return input_reads[1].path + ' ' + input_reads[0].path\n    }\n\n}"
                    },
                    {
                        "position": 7,
                        "prefix": "-t",
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    MAX_THREADS = 36\n    suggested_threads = 8\n\n    if (inputs.threads) {\n        threads = inputs.threads\n    } else if (inputs.wgs_hg38_mode_threads) {\n        ref_name_arr = inputs.reference_index_tar.path.split('/')\n        ref_name = ref_name_arr[ref_name_arr.length - 1]\n        if (ref_name.search('38') >= 0) {\n            threads = inputs.wgs_hg38_mode_threads\n        } else {\n            threads = MAX_THREADS\n        }\n    } else {\n        threads = suggested_threads\n    }\n\n    return threads\n}"
                    },
                    {
                        "position": 15,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    name = ''\n    metadata = [].concat(inputs.reference_index_tar)[0].metadata\n\n    if (metadata && metadata.reference_genome) {\n        name = metadata.reference_genome\n    } else {\n        reference_file = inputs.reference_index_tar.path.split('/')[inputs.reference_index_tar.path.split('/').length - 1]\n        name = reference_file.slice(0, -4) // cut .tar extension \n    }\n\n    return name\n}"
                    },
                    {
                        "position": 10005,
                        "separate": true,
                        "shellQuote": false,
                        "valueFrom": "${\n    cmd = \";declare -i pipe_statuses=(\\\\${PIPESTATUS[*]});len=\\\\${#pipe_statuses[@]};declare -i tot=0;echo \\\\${pipe_statuses[*]};for (( i=0; i<\\\\${len}; i++ ));do if [ \\\\${pipe_statuses[\\\\$i]} -ne 0 ];then tot=\\\\${pipe_statuses[\\\\$i]}; fi;done;if [ \\\\$tot -ne 0 ]; then >&2 echo Error in piping. Pipe statuses: \\\\${pipe_statuses[*]};fi; if [ \\\\$tot -ne 0 ]; then false;fi\\\"\"\n    return cmd\n}"
                    }
                ],
                "baseCommand": [],
                "class": "CommandLineTool",
                "cwlVersion": "v1.0",
                "doc": "**BWA MEM** is an algorithm designed for aligning sequence reads onto a large reference genome. BWA MEM is implemented as a component of BWA. The algorithm can automatically choose between performing end-to-end and local alignments. BWA MEM is capable of outputting multiple alignments, and finding chimeric reads. It can be applied to a wide range of read lengths, from 70 bp to several megabases. \n\nIn order to obtain possibilities for additional fast processing of aligned reads, two tools are embedded together into the same package with BWA MEM (0.7.17): Samblaster. (0.1.22) and Sambamba (v0.6.7). \nIf deduplication of alignments is needed, it can be done by setting the parameter 'Duplication'. **Samblaster** will be used internally to perform this action.\nBesides the standard BWA MEM SAM output file, BWA MEM package has been extended to support two additional output options: a BAM file obtained by piping through **Sambamba view** while filtering out the secondary alignments, as well as a Coordinate Sorted BAM option that additionally pipes the output through **Sambamba sort**, along with an accompanying .bai file produced by **Sambamba sort** as side effect. Sorted BAM is the default output of BWA MEM. Parameters responsible for these additional features are 'Filter out secondary alignments' and 'Output format'. Passing data from BWA MEM to Samblaster and Sambamba tools has been done through the pipes which saves processing times of two read and write of aligned reads into the hard drive. \n\nFor input reads fastq files of total size less than 10 GB we suggest using the default setting for parameter 'total memory' of 15GB, for larger files we suggest using 58 GB of memory and 32 CPU cores.\n\n**Important:**\nIn order to work BWA MEM Bundle requires fasta reference file accompanied with **bwa fasta indices** in TAR file.\nThere is the **known issue** with samblaster. It does not support processing when number of sequences in fasta is larger than 32768. If this is the case do not use deduplication option because the output BAM will be corrupted.",
                "hints": [],
                "id": "vladimirk/bwa-mem-bundle-0-7-17-demo/bwa-mem-bundle-0-7-17/11",
                "inputs": {
                    "append_comment": {
                        "doc": "Append FASTA/FASTQ comment to SAM output.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-C",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Append comment",
                        "sbg:category": "BWA Input/output options",
                        "type": "boolean?"
                    },
                    "band_width": {
                        "doc": "Band width for banded alignment.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-w",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Band width",
                        "sbg:category": "BWA Algorithm options",
                        "sbg:toolDefaultValue": "100",
                        "type": "int?"
                    },
                    "clipping_penalty": {
                        "doc": "Penalty for 5'- and 3'-end clipping.",
                        "inputBinding": {
                            "itemSeparator": ",",
                            "position": 5,
                            "prefix": "-L",
                            "separate": false,
                            "shellQuote": false
                        },
                        "label": "Clipping penalty",
                        "sbg:category": "BWA Scoring options",
                        "sbg:toolDefaultValue": "[5,5]",
                        "type": "int[]?"
                    },
                    "deduplication": {
                        "doc": "Use Samblaster for finding duplicates on sequence reads.",
                        "label": "PCR duplicate detection",
                        "sbg:category": "Samblaster parameters",
                        "sbg:toolDefaultValue": "MarkDuplicates",
                        "type": [
                            "null",
                            {
                                "name": "deduplication",
                                "symbols": [
                                    "None",
                                    "MarkDuplicates",
                                    "RemoveDuplicates"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "discard_chain_length": {
                        "doc": "Discard a chain if seeded bases shorter than INT.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-W",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Discard chain length",
                        "sbg:category": "BWA Algorithm options",
                        "sbg:toolDefaultValue": "0",
                        "type": "int?"
                    },
                    "discard_exact_matches": {
                        "doc": "Discard full-length exact matches.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-e",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Discard exact matches",
                        "sbg:category": "BWA Algorithm options",
                        "type": "boolean?"
                    },
                    "drop_chains_fraction": {
                        "doc": "Drop chains shorter than FLOAT fraction of the longest overlapping chain.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-D",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Drop chains fraction",
                        "sbg:category": "BWA Algorithm options",
                        "sbg:toolDefaultValue": "0.50",
                        "type": "float?"
                    },
                    "dropoff": {
                        "doc": "Off-diagonal X-dropoff.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-d",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Dropoff",
                        "sbg:category": "BWA Algorithm options",
                        "sbg:toolDefaultValue": "100",
                        "type": "int?"
                    },
                    "filter_out_secondary_alignments": {
                        "doc": "Filter out secondary alignments. Sambamba view tool will be used to perform this internally.",
                        "label": "Filter out secondary alignments",
                        "sbg:category": "Execution",
                        "sbg:toolDefaultValue": "False",
                        "type": "boolean?"
                    },
                    "gap_extension_penalties": {
                        "doc": "Gap extension penalty; a gap of size k cost '{-O} + {-E}*k'. This array can't have more than two values.",
                        "inputBinding": {
                            "itemSeparator": ",",
                            "position": 5,
                            "prefix": "-E",
                            "separate": false,
                            "shellQuote": false
                        },
                        "label": "Gap extension",
                        "sbg:category": "BWA Scoring options",
                        "sbg:toolDefaultValue": "[1,1]",
                        "type": "int[]?"
                    },
                    "gap_open_penalties": {
                        "doc": "Gap open penalties for deletions and insertions. This array can't have more than two values.",
                        "inputBinding": {
                            "itemSeparator": ",",
                            "position": 5,
                            "prefix": "-O",
                            "separate": false,
                            "shellQuote": false
                        },
                        "label": "Gap open penalties",
                        "sbg:category": "BWA Scoring options",
                        "sbg:toolDefaultValue": "[6,6]",
                        "type": "int[]?"
                    },
                    "ignore_alt_file": {
                        "doc": "Treat ALT contigs as part of the primary assembly (i.e. ignore <idxbase>.alt file).",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-j",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Ignore ALT file",
                        "sbg:category": "BWA Input/output options",
                        "type": "boolean?"
                    },
                    "input_reads": {
                        "doc": "Input sequence reads.",
                        "label": "Input reads",
                        "sbg:category": "Input files",
                        "sbg:fileTypes": "FASTQ, FASTQ.GZ, FQ, FQ.GZ",
                        "type": "File[]"
                    },
                    "insert_string_to_header": {
                        "doc": "Insert STR to header if it starts with @; or insert lines in FILE.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-H",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Insert string to output SAM or BAM header",
                        "sbg:category": "BWA Input/output options",
                        "type": "string?"
                    },
                    "mark_shorter": {
                        "doc": "Mark shorter split hits as secondary.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-M",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mark shorter",
                        "sbg:category": "BWA Input/output options",
                        "type": "boolean?"
                    },
                    "mate_rescue_rounds": {
                        "doc": "Perform at most INT rounds of mate rescues for each read.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-m",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mate rescue rounds",
                        "sbg:category": "BWA Algorithm options",
                        "sbg:toolDefaultValue": "50",
                        "type": "string?"
                    },
                    "minimum_output_score": {
                        "doc": "Minimum alignment score for a read to be output in SAM/BAM.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-T",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Minimum alignment score for a read to be output in SAM/BAM",
                        "sbg:category": "BWA Input/output options",
                        "sbg:toolDefaultValue": "30",
                        "type": "int?"
                    },
                    "minimum_seed_length": {
                        "doc": "Minimum seed length for BWA MEM.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-k",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Minimum seed length",
                        "sbg:category": "BWA Algorithm options",
                        "sbg:toolDefaultValue": "19",
                        "type": "int?"
                    },
                    "mismatch_penalty": {
                        "doc": "Penalty for a mismatch.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-B",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Mismatch penalty",
                        "sbg:category": "BWA Scoring options",
                        "sbg:toolDefaultValue": "4",
                        "type": "int?"
                    },
                    "num_bases_reproducibility": {
                        "doc": "process INT input bases in each batch regardless of nThreads (for reproducibility)",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-K",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Number of bases to process reproducibility",
                        "type": "int?"
                    },
                    "output_alignments": {
                        "doc": "Output all alignments for SE or unpaired PE.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-a",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Output alignments",
                        "sbg:category": "BWA Input/output options",
                        "type": "boolean?"
                    },
                    "output_format": {
                        "doc": "Specify output format.",
                        "label": "Output format",
                        "sbg:category": "Execution",
                        "sbg:toolDefaultValue": "Coordinate Sorted BAM",
                        "type": [
                            "null",
                            {
                                "name": "output_format",
                                "symbols": [
                                    "SAM",
                                    "BAM",
                                    "Coordinate Sorted BAM",
                                    "Queryname Sorted BAM",
                                    "Natural Sorted BAM"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "output_header": {
                        "doc": "Output the reference FASTA header in the XR tag.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-V",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Output header",
                        "sbg:category": "BWA Input/output options",
                        "type": "boolean?"
                    },
                    "output_in_xa": {
                        "doc": "If there are <INT hits with score >80% of the max score, output all in XA. This array should have no more than two values.",
                        "inputBinding": {
                            "itemSeparator": ",",
                            "position": 5,
                            "prefix": "-h",
                            "separate": false,
                            "shellQuote": false
                        },
                        "label": "Output in XA",
                        "sbg:category": "BWA Input/output options",
                        "sbg:toolDefaultValue": "[5, 200]",
                        "type": "int[]?"
                    },
                    "output_name": {
                        "doc": "Name of the output BAM file.",
                        "label": "Output SAM/BAM file name",
                        "sbg:category": "Configuration",
                        "type": "string?"
                    },
                    "read_group_header": {
                        "doc": "Read group header line such as '@RG\\tID:foo\\tSM:bar'.  This value takes precedence over per-attribute parameters.",
                        "label": "Read group header",
                        "sbg:category": "BWA Read Group Options",
                        "sbg:toolDefaultValue": "Constructed from per-attribute parameters or inferred from metadata.",
                        "type": "string?"
                    },
                    "read_type": {
                        "doc": "Sequencing technology-specific settings; Setting -x changes multiple parameters unless overriden. pacbio: -k17 -W40 -r10 -A1 -B1 -O1 -E1 -L0  (PacBio reads to ref). ont2d: -k14 -W20 -r10 -A1 -B1 -O1 -E1 -L0  (Oxford Nanopore 2D-reads to ref). intractg: -B9 -O16 -L5  (intra-species contigs to ref).",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-x",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Sequencing technology-specific settings",
                        "sbg:category": "BWA Scoring options",
                        "type": [
                            "null",
                            {
                                "name": "read_type",
                                "symbols": [
                                    "pacbio",
                                    "ont2d",
                                    "intractg"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "reference_index_tar": {
                        "doc": "Reference fasta file with BWA index files packed in TAR.",
                        "label": "Reference Index TAR",
                        "sbg:category": "Input files",
                        "sbg:fileTypes": "TAR",
                        "type": "File"
                    },
                    "reserved_threads": {
                        "doc": "Reserved number of threads on the instance used by scheduler.",
                        "label": "Reserved number of threads on the instance",
                        "sbg:category": "Configuration",
                        "sbg:toolDefaultValue": "1",
                        "type": "int?"
                    },
                    "rg_data_submitting_center": {
                        "doc": "Specify the data submitting center for RG line.",
                        "label": "Data submitting center",
                        "sbg:category": "BWA Read Group Options",
                        "type": "string?"
                    },
                    "rg_id": {
                        "doc": "Read group ID",
                        "label": "Read group ID",
                        "sbg:category": "Configuration",
                        "sbg:toolDefaultValue": "1",
                        "type": "string?"
                    },
                    "rg_library_id": {
                        "doc": "Specify the identifier for the sequencing library preparation, which will be placed in RG line.",
                        "label": "Library ID",
                        "sbg:category": "BWA Read Group Options",
                        "sbg:toolDefaultValue": "Inferred from metadata",
                        "type": "string?"
                    },
                    "rg_median_fragment_length": {
                        "doc": "Specify the median fragment length for RG line.",
                        "label": "Median fragment length",
                        "sbg:category": "BWA Read Group Options",
                        "type": "string?"
                    },
                    "rg_platform": {
                        "doc": "Specify the version of the technology that was used for sequencing, which will be placed in RG line.",
                        "label": "Platform",
                        "sbg:category": "BWA Read Group Options",
                        "sbg:toolDefaultValue": "Inferred from metadata",
                        "type": [
                            "null",
                            {
                                "name": "rg_platform",
                                "symbols": [
                                    "454",
                                    "Helicos",
                                    "Illumina",
                                    "Solid",
                                    "IonTorrent"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "rg_platform_unit_id": {
                        "doc": "Specify the platform unit (lane/slide) for RG line - An identifier for lanes (Illumina), or for slides (SOLiD) in the case that a library was split and ran over multiple lanes on the flow cell or slides.",
                        "label": "Platform unit ID",
                        "sbg:category": "BWA Read Group Options",
                        "sbg:toolDefaultValue": "Inferred from metadata",
                        "type": "string?"
                    },
                    "rg_sample_id": {
                        "doc": "Specify the sample ID for RG line - A human readable identifier for a sample or specimen, which could contain some metadata information. A sample or specimen is material taken from a biological entity for testing, diagnosis, propagation, treatment, or research purposes, including but not limited to tissues, body fluids, cells, organs, embryos, body excretory products, etc.",
                        "label": "Sample ID",
                        "sbg:category": "BWA Read Group Options",
                        "sbg:toolDefaultValue": "Inferred from metadata",
                        "type": "string?"
                    },
                    "sambamba_threads": {
                        "doc": "Number of threads to pass to Sambamba sort, if used.",
                        "label": "Sambamba Sort threads",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "score_for_a_sequence_match": {
                        "doc": "Score for a sequence match, which scales options -TdBOELU unless overridden.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-A",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Score for a sequence match",
                        "sbg:category": "BWA Scoring options",
                        "sbg:toolDefaultValue": "1",
                        "type": "int?"
                    },
                    "seed_occurrence_for_the_3rd_round": {
                        "doc": "Seed occurrence for the 3rd round seeding.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-y",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Seed occurrence for the 3rd round",
                        "sbg:category": "BWA Algorithm options",
                        "sbg:toolDefaultValue": "20",
                        "type": "int?"
                    },
                    "select_seeds": {
                        "doc": "Look for internal seeds inside a seed longer than {-k} * FLOAT.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-r",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Select seeds",
                        "sbg:category": "BWA Algorithm options",
                        "sbg:toolDefaultValue": "1.5",
                        "type": "float?"
                    },
                    "skip_mate_rescue": {
                        "doc": "Skip mate rescue.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-S",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Skip mate rescue",
                        "sbg:category": "BWA Algorithm options",
                        "type": "boolean?"
                    },
                    "skip_pairing": {
                        "doc": "Skip pairing; mate rescue performed unless -S also in use.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-P",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Skip pairing",
                        "sbg:category": "BWA Algorithm options",
                        "type": "boolean?"
                    },
                    "skip_seeds": {
                        "doc": "Skip seeds with more than INT occurrences.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-c",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Skip seeds with more than INT occurrences",
                        "sbg:category": "BWA Algorithm options",
                        "sbg:toolDefaultValue": "500",
                        "type": "int?"
                    },
                    "smart_pairing_in_input_fastq": {
                        "doc": "Smart pairing in input FASTQ file (ignoring in2.fq).",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-p",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Smart pairing in input FASTQ file",
                        "sbg:category": "BWA Input/output options",
                        "type": "boolean?"
                    },
                    "sort_memory": {
                        "doc": "Amount of RAM [Gb] to give to the sorting algorithm (if not provided will be set to one third of the total memory).",
                        "label": "Memory for BAM sorting",
                        "sbg:category": "Execution",
                        "type": "int?"
                    },
                    "speficy_distribution_parameters": {
                        "doc": "Specify the mean, standard deviation (10% of the mean if absent), max (4 sigma from the mean if absent) and min of the insert size distribution.FR orientation only. This array can have maximum four values, where first two should be specified as FLOAT and last two as INT.",
                        "inputBinding": {
                            "itemSeparator": " -I ",
                            "position": 5,
                            "prefix": "-I",
                            "separate": false,
                            "shellQuote": false
                        },
                        "label": "Specify distribution parameters",
                        "sbg:category": "BWA Input/output options",
                        "type": "float[]?"
                    },
                    "threads": {
                        "doc": "Number of threads for BWA, Samblaster and Sambamba sort process.",
                        "label": "Threads",
                        "sbg:category": "Execution",
                        "sbg:toolDefaultValue": "8",
                        "type": "int?"
                    },
                    "total_memory": {
                        "doc": "Total memory to be used by the tool in GB. It's sum of BWA, Sambamba Sort and Samblaster. For fastq files of total size less than 10GB, we suggest using the default setting of 15GB, for larger files we suggest using 58GB of memory (and 32CPU cores).",
                        "label": "Total memory",
                        "sbg:category": "Execution",
                        "sbg:toolDefaultValue": "15",
                        "type": "int?"
                    },
                    "unpaired_read_penalty": {
                        "doc": "Penalty for an unpaired read pair.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-U",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Unpaired read penalty",
                        "sbg:category": "BWA Scoring options",
                        "sbg:toolDefaultValue": "17",
                        "type": "int?"
                    },
                    "use_soft_clipping": {
                        "doc": "Use soft clipping for supplementary alignments.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-Y",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Use soft clipping",
                        "sbg:category": "BWA Input/output options",
                        "type": "boolean?"
                    },
                    "verbose_level": {
                        "doc": "Verbose level: 1=error, 2=warning, 3=message, 4+=debugging.",
                        "inputBinding": {
                            "position": 5,
                            "prefix": "-v",
                            "separate": true,
                            "shellQuote": false
                        },
                        "label": "Verbose level",
                        "sbg:category": "BWA Input/output options",
                        "sbg:toolDefaultValue": "3",
                        "type": [
                            "null",
                            {
                                "name": "verbose_level",
                                "symbols": [
                                    "1",
                                    "2",
                                    "3",
                                    "4"
                                ],
                                "type": "enum"
                            }
                        ]
                    },
                    "wgs_hg38_mode_threads": {
                        "doc": "Lower the number of threads if HG38 reference genome is used.",
                        "label": "Optimize threads for HG38",
                        "sbg:category": "Execution",
                        "sbg:toolDefaultValue": "False",
                        "type": "int?"
                    }
                },
                "label": "BWA MEM Bundle",
                "outputs": {
                    "aligned_reads": {
                        "doc": "Aligned reads.",
                        "label": "Aligned SAM/BAM",
                        "outputBinding": {
                            "glob": "{*.sam,*.bam}",
                            "outputEval": "${\n    return inheritMetadata(self, inputs.input_reads)\n\n}"
                        },
                        "sbg:fileTypes": "SAM, BAM",
                        "secondaryFiles": [
                            ".bai",
                            "^.bai"
                        ],
                        "type": "File?"
                    },
                    "samblaster_log": {
                        "doc": "Log file for Samblaster mark duplicates",
                        "label": "Samblaster log",
                        "outputBinding": {
                            "glob": "*.samblaster.log"
                        },
                        "sbg:fileTypes": "LOG",
                        "type": "File?"
                    }
                },
                "requirements": [
                    {
                        "class": "ShellCommandRequirement"
                    },
                    {
                        "class": "InlineJavascriptRequirement",
                        "expressionLib": [
                            "var updateMetadata = function(file, key, value) {\n    file['metadata'][key] = value;\n    return file;\n};\n\n\nvar setMetadata = function(file, metadata) {\n    if (!('metadata' in file))\n        file['metadata'] = metadata;\n    else {\n        for (var key in metadata) {\n            file['metadata'][key] = metadata[key];\n        }\n    }\n    return file\n};\n\nvar inheritMetadata = function(o1, o2) {\n    var commonMetadata = {};\n    if (!Array.isArray(o2)) {\n        o2 = [o2]\n    }\n    for (var i = 0; i < o2.length; i++) {\n        var example = o2[i]['metadata'];\n        for (var key in example) {\n            if (i == 0)\n                commonMetadata[key] = example[key];\n            else {\n                if (!(commonMetadata[key] == example[key])) {\n                    delete commonMetadata[key]\n                }\n            }\n        }\n    }\n    if (!Array.isArray(o1)) {\n        o1 = setMetadata(o1, commonMetadata)\n    } else {\n        for (var i = 0; i < o1.length; i++) {\n            o1[i] = setMetadata(o1[i], commonMetadata)\n        }\n    }\n    return o1;\n};\n\nvar toArray = function(file) {\n    return [].concat(file);\n};\n\nvar groupBy = function(files, key) {\n    var groupedFiles = [];\n    var tempDict = {};\n    for (var i = 0; i < files.length; i++) {\n        var value = files[i]['metadata'][key];\n        if (value in tempDict)\n            tempDict[value].push(files[i]);\n        else tempDict[value] = [files[i]];\n    }\n    for (var key in tempDict) {\n        groupedFiles.push(tempDict[key]);\n    }\n    return groupedFiles;\n};\n\nvar orderBy = function(files, key, order) {\n    var compareFunction = function(a, b) {\n        if (a['metadata'][key].constructor === Number) {\n            return a['metadata'][key] - b['metadata'][key];\n        } else {\n            var nameA = a['metadata'][key].toUpperCase();\n            var nameB = b['metadata'][key].toUpperCase();\n            if (nameA < nameB) {\n                return -1;\n            }\n            if (nameA > nameB) {\n                return 1;\n            }\n            return 0;\n        }\n    };\n\n    files = files.sort(compareFunction);\n    if (order == undefined || order == \"asc\")\n        return files;\n    else\n        return files.reverse();\n};"
                        ]
                    },
                    {
                        "class": "DockerRequirement",
                        "dockerImageId": "",
                        "dockerPull": "images.sbgenomics.com/vladimirk/bwa:0.7.17"
                    },
                    {
                        "class": "ResourceRequirement",
                        "coresMin": "${\n    // Calculate suggested number of CPUs depending of the input reads size\n    if (inputs.input_reads.constructor == Array) {\n        if (inputs.input_reads[1]) {\n            reads_size = inputs.input_reads[0].size + inputs.input_reads[1].size\n        } else {\n            reads_size = inputs.input_reads[0].size\n        }\n    } else {\n        reads_size = inputs.input_reads.size\n    }\n    if (!reads_size) {\n        reads_size = 0\n    }\n\n\n    GB_1 = 1024 * 1024 * 1024\n    if (reads_size < GB_1) {\n        suggested_cpus = 1\n    } else if (reads_size < 10 * GB_1) {\n        suggested_cpus = 8\n    } else {\n        suggested_cpus = 31\n    }\n\n    if (inputs.reserved_threads) {\n        return inputs.reserved_threads\n    } else if (inputs.threads) {\n        return inputs.threads\n    } else if (inputs.sambamba_threads) {\n        return inputs.sambamba_threads\n    } else {\n        return suggested_cpus\n    }\n}",
                        "ramMin": "${\n\n    // Calculate suggested number of CPUs depending of the input reads size\n    if (inputs.input_reads.constructor == Array) {\n        if (inputs.input_reads[1]) {\n            reads_size = inputs.input_reads[0].size + inputs.input_reads[1].size\n        } else {\n            reads_size = inputs.input_reads[0].size\n        }\n    } else {\n        reads_size = inputs.input_reads.size\n    }\n    if (!reads_size) {\n        reads_size = 0\n    }\n\n    GB_1 = 1024 * 1024 * 1024\n    if (reads_size < GB_1) {\n        suggested_memory = 4\n    } else if (reads_size < 10 * GB_1) {\n        suggested_memory = 15\n    } else {\n        suggested_memory = 58\n    }\n\n    if (inputs.total_memory) {\n        return inputs.total_memory * 1024\n    } else if (inputs.sort_memory) {\n        return inputs.sort_memory * 1024\n    } else {\n        return suggested_memory * 1024\n    }\n}"
                    },
                    {
                        "class": "InitialWorkDirRequirement",
                        "listing": [
                            "$(inputs.reference_index_tar)"
                        ]
                    }
                ],
                "sbg:appVersion": [
                    "v1.0"
                ],
                "sbg:categories": [
                    "Alignment",
                    "FASTQ-Processing"
                ],
                "sbg:cmdPreview": "/bin/bash -c \" tar -xf reference.HG38.fasta.tar ;  cp /opt/hs38DH.fa.alt reference.HG38.fasta.alt ;  bwa mem  -R '@RG\\tID:1\\tPL:Illumina\\tSM:dnk_sample' -t 10  reference.HG38.fasta  /path/to/LP6005524-DNA_C01_lane_7.sorted.converted.filtered.pe_2.gz /path/to/LP6005524-DNA_C01_lane_7.sorted.converted.filtered.pe_1.gz   | sambamba view -t 10 -f bam -l 0 -S /dev/stdin | sambamba sort -t 10 --natural-sort -m 5GiB --tmpdir ./ -o LP6005524-DNA_C01_lane_7.sorted.converted.filtered.bam -l 5 /dev/stdin  ;declare -i pipe_statuses=(\\${PIPESTATUS[*]});len=\\${#pipe_statuses[@]};declare -i tot=0;echo \\${pipe_statuses[*]};for (( i=0; i<\\${len}; i++ ));do if [ \\${pipe_statuses[\\$i]} -ne 0 ];then tot=\\${pipe_statuses[\\$i]}; fi;done;if [ \\$tot -ne 0 ]; then >&2 echo Error in piping. Pipe statuses: \\${pipe_statuses[*]};fi; if [ \\$tot -ne 0 ]; then false;fi\"",
                "sbg:contributors": [
                    "vladimirk"
                ],
                "sbg:createdBy": "vladimirk",
                "sbg:id": "h-f920a80c/h-4491ef0b/h-bb01c6cb/0",
                "sbg:image_url": null,
                "sbg:latestRevision": 11,
                "sbg:license": "BWA: GNU Affero General Public License v3.0, MIT License. Sambamba: GNU GENERAL PUBLIC LICENSE. Samblaster: The MIT License (MIT)",
                "sbg:links": [
                    {
                        "id": "http://bio-bwa.sourceforge.net/",
                        "label": "Homepage"
                    },
                    {
                        "id": "https://github.com/lh3/bwa",
                        "label": "Source code"
                    },
                    {
                        "id": "http://bio-bwa.sourceforge.net/bwa.shtml",
                        "label": "Wiki"
                    },
                    {
                        "id": "http://sourceforge.net/projects/bio-bwa/",
                        "label": "Download"
                    },
                    {
                        "id": "http://arxiv.org/abs/1303.3997",
                        "label": "Publication"
                    },
                    {
                        "id": "http://www.ncbi.nlm.nih.gov/pubmed/19451168",
                        "label": "Publication BWA Algorithm"
                    }
                ],
                "sbg:project": "vladimirk/bwa-mem-bundle-0-7-17-demo",
                "sbg:publisher": "sbg",
                "sbg:revisionNotes": "Do_not_use_alt_38 parameter removed due to redundancy",
                "sbg:sbgMaintained": false,
                "sbg:toolAuthor": "Heng Li",
                "sbg:toolkit": "BWA",
                "sbg:toolkitVersion": "0.7.17",
                "sbg:validationErrors": [],
                "stdin": "",
                "stdout": "",
                "successCodes": [],
                "temporaryFailCodes": []
            },
            "sbg:x": 367.6924870903057,
            "sbg:y": 99.99999792335989,
            "scatter": "input_reads"
        }
    ]
}